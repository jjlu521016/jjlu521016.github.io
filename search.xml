<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java并发编程之线程池</title>
      <link href="/2020/06/18/java/juc/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"/>
      <url>/2020/06/18/java/juc/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是线程池："><a href="#什么是线程池：" class="headerlink" title="什么是线程池："></a>什么是线程池：</h2><p><strong>java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池</strong></p><h2 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h2><p>在说线程池之前，我们不得不提下线程。为什么有了线程还需要使用线程池技术呢？下面我们简单的了解下。</p><p><img src="/images/2020/06/18/c2f89700-b146-11ea-a314-095877051747.png" alt="image.png"></p><p><strong>1. 创建/销毁线程伴随着系统开销，过于频繁的创建/销毁线程，会很大程度上影响处理效率</strong></p><p>例如：</p><p>创建线程消耗时间T1</p><p>执行任务消耗时间T2</p><p>销毁线程消耗时间T3</p><p>如果T1 + T3 远大于 T2，那么是不是说开启一个线程来执行这个任务代价有点大</p><p>2.<strong>线程并发数量过多，抢占系统资源从而导致阻塞</strong></p><p>线程能共享系统资源，如果同时执行的线程过多，就有可能导致系统资源不足而产生阻塞的情况</p><p>3.<strong>对线程进行一些简单的管理</strong></p><p>比如：延时执行、定时循环执行的策略</p><h2 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h2><a id="more"></a><p>在线程池中存在几个概念：</p><p><code>核心线程数</code>指的是线程池的基本大小；</p><p><code>最大线程数</code>指的是，同一时刻线程池中线程的数量最大不能超过该值；</p><p><code>任务队列</code>是当任务较多时，线程池中线程的数量已经达到了核心线程数，这时候就是用任务队列来存储我们提交的任务。 </p><p>与其他池化技术不同的是，线程池是基于<code>生产者-消费者</code>模式来实现的，任务的提交方是生产者，线程池是消费者。当我们需要执行某个任务时，只需要把任务扔到线程池中即可。线程池中执行任务的流程如下图如下。</p><p><img src="/images/2020/06/18/d2a00170-b146-11ea-a314-095877051747.png" alt="image.png"></p><h2 id="ThreadPoolExecutor简介"><a href="#ThreadPoolExecutor简介" class="headerlink" title="ThreadPoolExecutor简介"></a>ThreadPoolExecutor简介</h2><p>ThreadPoolExecutor</p><p>在JUC包下，已经提供了线程池的具体的实现：<code>ThreadPoolExecutor</code>。ThreadPoolExecutor提供了很多的构造方法，其中最复杂的构造方法有7个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>corePoolSize</code>线程池的核心线程数。</p><p>在任务提交到线程池的时候，</p><p>线程数 &lt;= corePoolSize 就会新创建的一个线程来执行任务</p><p>线程数 &gt; corePoolSize 就将任务添加到<code>workQueue</code>中。</p></li><li><p><code>maximumPoolSize</code>：线程池中允许存在的最大线程数量。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当`workQueue`满了以后，再有新的任务进入到线程池时，会判断再新建一个线程是否会超过maximumPoolSize，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果会超过，则不创建线程，而是执行拒绝策略。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果不会超过maximumPoolSize，则会创建新的线程来执行任务。</span><br></pre></td></tr></table></figure><ul><li><code>keepAliveTime</code>：空闲线程等待工作的超时时间 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当线程池中的线程数量大于corePoolSize时，大于corePoolSize这部分的线程如果没有任务去处理，那么就表示它们是空闲</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">的，这个时候是不允许它们一直存在的，而是允许它们最多空闲一段时间，这段时间就是keepAliveTime，时间的单位就是</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit。</span><br></pre></td></tr></table></figure><ul><li><code>unit</code>：空闲线程允许存活时间的单位<br>   <code>TimeUnit</code>是一个枚举值，它可以是纳秒、微妙、毫秒、秒、分、小时、天。</li><li><code>workQueue</code>：任务队列，用来存放任务。该队列的类型是阻塞队列。<pre><code>常用阻塞队列有`ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue`等。 </code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**关于阻塞队列下面会介绍隐藏的一些坑。**</span><br></pre></td></tr></table></figure><ul><li><code>threadFactory</code>：线程池工厂，用来创建线程。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实际项目中，为了便于后期排查问题，在创建线程时需要为线程赋予一定的名称</span><br></pre></td></tr></table></figure><ul><li><code>handler</code>：拒绝策略。<br><img src="/images/2020/06/18/e010dcd0-b146-11ea-a314-095877051747.png" alt="image.png"><br>当任务队列已满，线程数量达到maximumPoolSize后，线程池就不会再接收新的任务了，这个时候就需要使用拒绝策略来决定最终是怎么处理这个任务。<code>默认情况下AbortPolicy，表示无法处理新任务，直接抛出异常</code>。在ThreadPoolExecutor类中定义了四个内部类，分别表示四种拒绝策略。我们也可以通过实现<code>RejectExecutionHandler</code>接口来实现自定义的拒绝策略。</li></ul><p><code>AbortPocily</code>：不再接收新任务，直接抛出异常。</p><p><code>CallerRunsPolicy</code>：提交任务的线程自己处理。</p><p><code>DiscardPolicy</code>：不处理，直接丢弃。</p><p><code>DiscardOldestPolicy</code>：丢弃任务队列中排在最前面的任务，并执行当前任务。（排在队列最前面的任务并不一定是在队列中待的时间最长的任务，因为有可能是按照优先级排序的队列）</p><p><strong><code>知识延伸</code></strong>,想深入理解的同学可以看下相关的源码可以加深印象。</p><p><code>dubbo</code>中的线程池继承了<code>ThreadPoolExecutor.AbortPolicy</code>，重写了<code>rejectedExecution</code>方法，并且<code>dubbo</code>线程模型的所有拒绝策略都是使用的<code>AbortPolicyWithReport</code>。</p><p><code>Netty</code>很像JDK中的CallerRunsPolicy，舍不得丢弃任务。不同的是，CallerRunsPolicy是直接在调用者线程执行的任务。而 Netty是新建了一个线程来处理的。</p><p><code>ActiveMq</code>中的策略属于最大努力执行任务型，当触发拒绝策略时，在尝试一分钟的时间重新将任务塞进任务队列，当一分钟超时还没成功时，就抛出异常。</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors创建返回ThreadPoolExecutor对象的方法共有三种：</p><ul><li>Executors#newCachedThreadPool  创建可缓存的线程池</li><li>Executors#newSingleThreadExecutor 创建单线程的线程池</li><li>Executors#newFixedThreadPool 创建固定长度的线程池</li></ul><p>看过《<a href="https://yq.aliyun.com/attachment/download/?spm=a2c4e.11153940.0.0.49d73524UHXvow&amp;id=5585" target="_blank" rel="noopener"><strong>阿里巴巴开发规范</strong></a>》的都知道，有这么一条</p><p>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。</p><p>下面我们根据相关源码来看下为什么有这条规约。</p><p><code>CachedThreadPool</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * corePoolSize =&gt; 0，核心线程池的数量为0</span><br><span class="line">  * maximumPoolSize =&gt; Integer.MAX_VALUE，可以认为最大线程数是无限的</span><br><span class="line">  * keepAliveTime =&gt; 60L</span><br><span class="line">  * unit =&gt; 秒</span><br><span class="line">  * workQueue =&gt; SynchronousQueue</span><br><span class="line">  */</span><br><span class="line">  public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">     return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                   60L, TimeUnit.SECONDS,</span><br><span class="line">                                   new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当一个任务提交时，corePoolSize为0不创建核心线程，SynchronousQueue是一个不存储元素的队列，可以理解为队里永远是满的，因此最终会创建非核心线程来执行任务。</p><p>对于非核心线程空闲60s时将被回收。因为Integer.MAX_VALUE非常大 (2^32 -1)，<strong>可以认为是可以无限创建线程的</strong>，在资源有限的情况下容易引起OOM异常</p><p><code>newSingleThreadExecutor</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * corePoolSize =&gt; 1，核心线程池的数量为1</span><br><span class="line"> * maximumPoolSize =&gt; 1，只可以创建一个非核心线程</span><br><span class="line"> * keepAliveTime =&gt; 0L</span><br><span class="line"> * unit =&gt; 秒</span><br><span class="line"> * workQueue =&gt; LinkedBlockingQueue</span><br><span class="line"> */</span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new FinalizableDelegatedExecutorService</span><br><span class="line">          (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当一个任务提交时，首先会创建一个核心线程来执行任务，如果超过核心线程的数量，将会放入队列中，因为<strong>LinkedBlockingQueue是长度为Integer.MAX_VALUE的队列</strong>，可以认为是无界队列，因此往队列中可以插入无限多的任务，在资源有限的时候容易引起OOM异常，因为无界队列，<strong>maximumPoolSize和keepAliveTime参数将无效。</strong></p><p><code>newFixedThreadPool</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">    * corePoolSize =&gt; 1，核心线程池的数量为1</span><br><span class="line">    * maximumPoolSize =&gt; 1，只可以创建一个非核心线程</span><br><span class="line">    * keepAliveTime =&gt; 0L</span><br><span class="line">    * unit =&gt; 秒</span><br><span class="line">    * workQueue =&gt; LinkedBlockingQueue</span><br><span class="line">    * LinkedBlockingQueue和SingleThreadExecutor类似，唯一的区别就是核心线程数不同，</span><br><span class="line">    * 并且由于使用的是LinkedBlockingQueue，在资源有限的时候容易引起OOM异常</span><br><span class="line">    */</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">       return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                     threadFactory);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>综上所述：</p><p><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code> </p><p>允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而引起OOM异常</p><p><code>CachedThreadPool</code> </p><p>允许创建的线程数为Integer.MAX_VALUE，可能会创建大量的线程，从而引起OOM异常</p><p>这就是为什么禁止使用Executors去创建线程池，而是推荐自己去创建ThreadPoolExecutor的原因</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(翻译)理解并发的核心概念一</title>
      <link href="/2020/06/18/%E7%BF%BB%E8%AF%91/JUC/%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%80.html"/>
      <url>/2020/06/18/%E7%BF%BB%E8%AF%91/JUC/%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%80.html</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://dzone.com/asset/download/210335" target="_blank" rel="noopener">https://dzone.com/asset/download/210335</a></p><p><a href="/raw/Understanding_the_Core_Concurrency_Concepts.pdf">pdf资源:</a>  </p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>从Java创建开始，Java就支持键并发线程和锁等概念。本参考将有帮助Java开发人员使用多线程程序来了解核心并发概念以及如何应用它们。</p><h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2 概念"></a>2 概念</h1><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Atomicity(原子性)</td><td style="text-align:left">一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，因此部分状态是不可能的</td></tr><tr><td style="text-align:left">Visibility(可见性)</td><td style="text-align:left">一个线程看到另一线程所做的更改时的条件</td></tr></tbody></table><p>表1 并发的概念</p><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><a id="more"></a><p>当多个线程在共享资源上执行一系列操作时，就会出现竞争状态，并且根据每个线程的操作顺序，存在几种可能的结果。 下面的代码不是线程安全的，并且该值可以多次初始化，因为check-then-act（检查null，然后进行初始化）表明延迟初始化的字段不是原子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> T value;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">      value = initialize();</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h2 id="数据冲突"><a href="#数据冲突" class="headerlink" title="数据冲突"></a>数据冲突</h2><p>当2个或更多线程尝试在不同步的情况下访问相同的非<code>final</code>变量时，就会发生数据冲突。 不使用同步可能会导致所做的更改对其他线程不可见，因此读取过时的数据是可能的，这又可能导致无限循环，损坏的数据结构或计算不正确的后果。 此代码可能会导致无限循环，因为读取器线程可能永远不会观察到写入器线程所做的更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> shouldFinish;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123; shouldFinish = <span class="keyword">true</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!shouldFinish) &#123;</span><br><span class="line">      iteration++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Finished after: "</span> + iteration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataRace</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Waiter waiter = <span class="keyword">new</span> Waiter();</span><br><span class="line">    Thread waiterThread = <span class="keyword">new</span> Thread(waiter);</span><br><span class="line">    waiterThread.start();</span><br><span class="line">    waiter.finish();</span><br><span class="line">    waiterThread.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h1 id="3-JMM-happens-before关系"><a href="#3-JMM-happens-before关系" class="headerlink" title="3 JMM happens-before关系"></a>3 JMM happens-before关系</h1><p>Java内存模型是根据诸如读取和写入字段以及在监视器上进行同步之类的操作定义的。 可以通过<strong>happens-before关系</strong></p><p>来对操作进行排序，该关系可以用来推断一个线程何时看到另一个线程的操作的结果以及什么构成了正确同步的程序。</p><p>​</p><p>happens-before关系规则</p><ul><li><code>Thread#start</code>的方法在线程的所有操作之前执行</li><li>在释放当前控制器之后，后序的请求才可以获取控制器。</li><li>写入<code>volatile</code>变量的操作在所有后序读取该变量的操作之前执行。</li><li>写入<code>final</code>型变量的操作在发布该对象的引用之前执行</li><li>线程的所有操作在从<code>Thread#join</code>方法返回之前执行</li></ul><p>​</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2921034/f7wnf8gn05.png" alt="happens-before插图"></p><p>上图中，<code>Action X</code>在<code>Action Y</code>之前执行，因此<code>线程1</code>在<code>Action X</code>以前执行的所有操作对<code>线程2</code>在<code>Action Y</code>之后的所有操作可见。</p><p>​</p><h1 id="4-标准同步功能"><a href="#4-标准同步功能" class="headerlink" title="4 标准同步功能"></a>4 标准同步功能</h1><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><strong>synchronized关键字</strong></h3><p><code>synchronized</code>关键字用来防止不同的线程同时进入一段代码。它确保了操作的原子性，因为你只有获得了这段代码的锁才能进入这段代码，使得该锁所保护的数据可以在独占模式下操作。除此以外，它还确保了别的线程在获得了同样的锁之后，能够观察到之前线程的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicOperation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> counter0;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> counter1;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      counter0++;</span><br><span class="line">      counter1++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>关键字也可以在方法级。</p><table><thead><tr><th style="text-align:left">方法的类型</th><th style="text-align:left">用作监视器的参考</th></tr></thead><tbody><tr><td style="text-align:left">静态方法(static)</td><td style="text-align:left">将持有该方法的类作为加锁对象</td></tr><tr><td style="text-align:left">非静态方法(non-static)</td><td style="text-align:left">加锁this指针</td></tr></tbody></table><p>表格2 监视器在整个方法同步时使用</p><p>​</p><p>锁是可以重入的，所以，如果线程已持有该锁，则它可以再次成功获取它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reentrantcy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doFirst();</span><br><span class="line">    doSecond();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"First operation is successful."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Second operation is successful."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>不同的竞争等级会影响监视器的获取方式：</p><table><thead><tr><th style="text-align:left">状态</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">init</td><td style="text-align:left">刚刚创建，没有被获取</td></tr><tr><td style="text-align:left">biased</td><td style="text-align:left">锁下的代码只被一个线程执行，不会产生冲突</td></tr><tr><td style="text-align:left">thin</td><td style="text-align:left">控制器被几个线程无冲突的获取。使用CAS（compare and swap）来管理这个锁</td></tr><tr><td style="text-align:left">fat</td><td style="text-align:left">产生冲突。JVM请求操作系统互斥，并让操作系统调度程序处理线程停放和唤醒。</td></tr></tbody></table><p>表3 监视器的状态</p><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p><code>wait/notify/notifyAll</code>方法在<code>Object</code>类中声明。<code>wait</code>方法用来将线程状态改变为<code>WAITING</code>或是<code>TIMED_WAITING</code>(如果传入了超时时间值)。如果需要唤醒一个线程，下列的操作都可以实现：</p><ul><li>另一个线程调用<code>notify</code>方法，唤醒在控制器上等待的任意的一个线程</li><li>另一个线程调用<code>notifyAll</code>方法，唤醒在该控制器上等待的所有线程</li><li><code>Thread#interrupt</code>方法被调用，在这种情况下，会抛出<code>InterruptedException</code></li></ul><p>最常用的一个模式是一个条件性循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConditionLoop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> condition;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForCondition</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">satisfyCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    condition = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>记住，要想使用对象上的<code>wait/notify/notifyAll</code>方法，你首先需要获取对象的锁。</li><li>总是在一个条件性循环中等待，从而解决如果另一个线程在wait开始之前满足条件并且调用了<code>notifyAll</code>而导致的顺序问题。而且它还防止线程由于伪唤起继续执行。</li><li>时刻确保你在调用<code>notify/notifyAll</code>之前已经满足了等待条件。如果不这样的话，将只会发出一个唤醒通知，但是在该等待条件上的线程永远无法跳出其等待循环。</li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><strong>volatile关键字</strong></h3><p><code>volatile</code>关键字解决了可见性（<strong>visibility</strong>）问题，并且使值的更改原子化，因为这里存在一个<code>happens-before</code>关系：对<code>volatile</code>值的更改会在所有后续读取该值的操作之前执行。因此，它确保了后序所有的读取操作能够看到之前的更改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFlag</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> shouldStop;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!shouldStop) &#123;</span><br><span class="line">      <span class="comment">//do smth</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Stopped."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shouldStop = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    VolatileFlag flag = <span class="keyword">new</span> VolatileFlag();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(flag);</span><br><span class="line">    thread.start();</span><br><span class="line">    flag.stop();</span><br><span class="line">    thread.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a><strong>Atomics</strong></h3><p><strong><code>java.util.concurrent.atomic</code>**</strong>包中包含了一组支持在单一值上进行多种原子性操作的类，从而从加锁中解脱出来。**</p><p><strong>使用**</strong><code>AtomicXXX</code><strong><strong>类，可以实现原子性的</strong></strong><code>check-then-act</code><strong>**操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckThenAct</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; value = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value.compareAndSet(<span class="keyword">null</span>, <span class="string">"Initialized value"</span>)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Initialized only once."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java.util.concurrent.atomic包中</strong><code>AtomicInteger</code>和<code>AtomicLong</code>都用<code>increment/decrement</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Increment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldState = state.getAndIncrement();</span><br><span class="line">    System.out.println(<span class="string">"Advanced: '"</span> + oldState + <span class="string">"' -&gt; '"</span> + (oldState + <span class="number">1</span>) + <span class="string">"'."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想要创建一个计数器，并不需要原子性的读操作，可以考虑使用<code>LongAdder</code>替代<code>AtomicLong/AtomicInteger</code>，<code>LongAdder</code>在多个单元格中维护该值，并在需要时对这些值同时递增，从而在高并发的情况下性能更好。</p><p>​</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>在线程中包含数据并且不需要锁定的一种方法是使用ThreadLocal存储。从概念上将，ThreadLocal就好像是在每个线程中都有自己版本的变量。ThreadLocal常用来存储只属于线程自己的值，例如当前的事务以及其它资源。另外，它还能用来维护单个线程专有的计数器，统计或是ID生成器。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Transaction&gt; currentTransaction </span><br><span class="line">      = ThreadLocal.withInitial(NullTransaction::<span class="keyword">new</span>);</span><br><span class="line">  <span class="function">Transaction <span class="title">currentTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Transaction current = currentTransaction.get();</span><br><span class="line">    <span class="keyword">if</span> (current.isNull()) &#123;</span><br><span class="line">      current = <span class="keyword">new</span> TransactionImpl();</span><br><span class="line">      currentTransaction.set(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>发布对象是指该对象的引用对当前的域之外也可见（比如，从getter方法中获取一个引用）。要确保一个对象被安全的发布(即在初始化完成之后发布)，可能需要使用同步。可以通过以下方法实现安全的发布：</p><ul><li>静态初始化方法。只有一个线程能够初始化静态变量因为该类的初始化是在一个排它锁之下完成的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInitializer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Publishing an immutable object without additional initialization</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Year year = Year.of(<span class="number">2017</span>); </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; keywords;</span><br><span class="line">  <span class="comment">// Using static initializer to construct a complex object</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// Creating mutable set</span></span><br><span class="line">    Set&lt;String&gt; keywordsSet = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line">    <span class="comment">// Initializing state</span></span><br><span class="line">    keywordsSet.add(<span class="string">"java"</span>);</span><br><span class="line">    keywordsSet.add(<span class="string">"concurrency"</span>);</span><br><span class="line">    <span class="comment">// Making set unmodifiable </span></span><br><span class="line">    keywords = Collections.unmodifiableSet(keywordsSet); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>volatile关键字。读线程总是能获取最近的值，因为写线程总是在后续的读取之前进行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> String state;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Atomics。例如AtomicInteger将一个值存储为volatile类型，所以这里和volatile变量的规则相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Atomics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state.compareAndSet(<span class="number">0</span>, state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Final类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Final</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String state;</span><br><span class="line">  Final(String state) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>确保<code>this</code>引用不会再初始化过程中泄漏</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisEscapes</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"> ThisEscapes(String name) &#123;</span><br><span class="line">   Cache.putIntoCache(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ThisEscapes&gt; CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIntoCache</span><span class="params">(ThisEscapes thisEscapes)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 'this' reference escaped before the object is fully constructed.</span></span><br><span class="line">   CACHE.putIfAbsent(thisEscapes.getName(), thisEscapes);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正确同步的域</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synchronization</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String state;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="keyword">null</span>)</span><br><span class="line">      state = <span class="string">"Initial"</span>;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​</p><h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><p>不变对象的一个非常棒的属性是线程安全(<strong>thread-safe)</strong>，所有无需在其上进行同步。使一个对象成为不变对象的要求为：</p><ul><li>所有的字段为<code>final</code>类型</li><li>所有字段可以是可变对象或不可变对象，但不能越过对象的范围，从而对象的状态在构建后不能更改。</li><li><code>this</code>引用在初始化期间不会泄露</li><li>该类为final类型，所以无法在子类中修改其行为</li></ul><p>不可变对象的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Marked as final - subclassing is forbidden</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Artist</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Immutable object, field is final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name; </span><br><span class="line">  <span class="comment">// Collection of immutable objects, field is final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Track&gt; tracks; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Artist</span><span class="params">(String name, List&lt;Track&gt; tracks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">// Defensive copy</span></span><br><span class="line">    List&lt;Track&gt; copy = <span class="keyword">new</span> ArrayList&lt;&gt;(tracks); </span><br><span class="line">    <span class="comment">// Making mutable collection unmodifiable</span></span><br><span class="line">    <span class="keyword">this</span>.tracks = Collections.unmodifiableList(copy); </span><br><span class="line">    <span class="comment">// 'this' is not passed to anywhere during construction</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getters, equals, hashCode, toString</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Marked as final - subclassing is forbidden</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Track</span> </span>&#123; </span><br><span class="line">  <span class="comment">// Immutable object, field is final</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String title; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Track</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getters, equals, hashCode, toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h1 id="线程-Threads"><a href="#线程-Threads" class="headerlink" title="线程(Threads)"></a>线程(Threads)</h1><p><code>java.lang.Thread</code>类用来表示一个应用或是一个JVM现场。其代码通常在某个进程类的上下文中执行。（使用<code>Thread#currentThread</code>来获取当前线程本身）</p><table><thead><tr><th style="text-align:left">线程状态</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">NEW</td><td style="text-align:left">还未启动</td></tr><tr><td style="text-align:left">RUNNABLE</td><td style="text-align:left">启动并运行</td></tr><tr><td style="text-align:left">BLOCKED</td><td style="text-align:left">在控制器上等待 - 该线程正视图获取锁并进入关键区域</td></tr><tr><td style="text-align:left">WAITING</td><td style="text-align:left">等待另一个线程执行特殊操作(notify/notifyAll,LockSupport#unpark)</td></tr><tr><td style="text-align:left">TIMED_WAITING</td><td style="text-align:left">和WAITING类似，但是有超时设置</td></tr><tr><td style="text-align:left">TERMINATED</td><td style="text-align:left">终止</td></tr></tbody></table><p>表4 线程状态</p><table><thead><tr><th style="text-align:left">Thread方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">start</td><td style="text-align:left">启动一个Thread实例并且执行run()方法</td></tr><tr><td style="text-align:left">join</td><td style="text-align:left">阻塞直到线程完成</td></tr><tr><td style="text-align:left">interrupt</td><td style="text-align:left">中断线程。如果该线程在响应终端的方法中阻塞着，则会在另一个线程中抛出InterruptedException，否则将会被设置为中断状态。</td></tr><tr><td style="text-align:left">stop,suspend,resume,destroy</td><td style="text-align:left">这些方法都已经失效</td></tr></tbody></table><p>表5 线程协调方法</p><h3 id="如何处理InterruptedException？"><a href="#如何处理InterruptedException？" class="headerlink" title="如何处理InterruptedException？"></a>如何处理InterruptedException？</h3><ul><li>如果可能的话，清理所有资源并在当前级别上完成线程执行。</li><li>声明当前的方法会抛出<code>InterruptedException</code></li><li>如果一个方法并没有被声明抛出<code>InterruptedException</code>，应该使用<code>Thread.currentThread().interrupt()</code>将中断标识回复为true，然后在该层抛出异常。将中断标识设为true很重要，它使得异常在可以在更高的层次上进行处。</li></ul><h3 id="未知的-Unexpected-的异常处理"><a href="#未知的-Unexpected-的异常处理" class="headerlink" title="未知的(Unexpected )的异常处理"></a>未知的(Unexpected )的异常处理</h3><p>线程可以指定一个UncaughtExceptionHandler，它将接收任何导致线程突然终止的未捕获异常的通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.setUncaughtExceptionHandler((failedThread, exception) -&gt; &#123;</span><br><span class="line">  logger.error(<span class="string">"Caught unexpected exception in thread '&#123;&#125;'."</span>,</span><br><span class="line">      failedThread.getName(), exception);</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(翻译)理解并发的核心概念二</title>
      <link href="/2020/06/18/%E7%BF%BB%E8%AF%91/JUC/%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BA%8C.html"/>
      <url>/2020/06/18/%E7%BF%BB%E8%AF%91/JUC/%E7%BF%BB%E8%AF%91-%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BA%8C.html</url>
      
        <content type="html"><![CDATA[<p><strong>接上文连接</strong></p><h1 id="Liveness"><a href="#Liveness" class="headerlink" title="Liveness"></a>Liveness</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>当多个线程在等待彼此释放持有的资源，从而形成了资源占有和等待的循环时，就产生了死锁。可能产生死锁的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> amount;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">long</span> amount)</span> </span>&#123; <span class="keyword">this</span>.amount += amount; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">minus</span><span class="params">(<span class="keyword">long</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.amount &lt; amount)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">this</span>.amount -= amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferWithDeadlock</span><span class="params">(<span class="keyword">long</span> amount, Account first, Account second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (first) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (second) &#123;</span><br><span class="line">        first.minus(amount);</span><br><span class="line">        second.plus(amount);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果在同一时间发生死锁：</p><ul><li>一个线程正在尝试从第一个帐户转移到第二个帐户，并且已经获得了第一个帐户的锁定。</li><li>与此同时，另一个线程正在尝试从第二个帐户转移到第一个帐户，并且已经获得了第二个帐户的锁定。</li></ul><p>避免死锁的方法有：</p><ul><li>顺序加锁 - 总是按相同的顺序获得锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> amount;</span><br><span class="line">  <span class="comment">// Some methods are omitted</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferWithLockOrdering</span><span class="params">(<span class="keyword">long</span> amount, Account first, Account second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> lockOnFirstAccountFirst = first.id &lt; second.id;</span><br><span class="line">    Account firstLock = lockOnFirstAccountFirst  ? first  : second;</span><br><span class="line">    Account secondLock = lockOnFirstAccountFirst ? second : first;</span><br><span class="line">    <span class="keyword">synchronized</span> (firstLock) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (secondLock) &#123;</span><br><span class="line">        first.minus(amount);</span><br><span class="line">        second.plus(amount);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>带超时的锁 - 不要在获得锁定后无限期阻塞，而是释放所有锁定并重试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> amount;</span><br><span class="line">  <span class="comment">// Some methods are omitted</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferWithTimeout</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">long</span> amount, Account first, Account second, <span class="keyword">int</span> retries, <span class="keyword">long</span> timeoutMillis</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> attempt = <span class="number">0</span>; attempt &lt; retries; attempt++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (first.lock.tryLock(timeoutMillis, TimeUnit.MILLISECONDS))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (second.lock.tryLock(timeoutMillis, TimeUnit.MILLISECONDS))</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              first.minus(amount);</span><br><span class="line">              second.plus(amount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">              second.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          first.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><hr><p>JVM可以检测到监视器死锁，并将在线程转储中打印死锁信息。</p><hr><h2 id="活锁和线程饥饿"><a href="#活锁和线程饥饿" class="headerlink" title="活锁和线程饥饿"></a>活锁和线程饥饿</h2><p>当线程花费所有时间协商对资源的访问或检测并避免死锁，从而没有线程真正取得进展时，就会发生活锁。 当线程长时间保持锁定而使某些线程“饥饿”而没有取得进展时，就会发生饥饿。</p><h2 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h2><h3 id="线程池（Thread-pools）"><a href="#线程池（Thread-pools）" class="headerlink" title="线程池（Thread pools）"></a>线程池（Thread pools）</h3><p>线程池的核心接口是<code>ExecutorService</code>，<code>java.util.concurrent</code>还提供了一个静态工厂<code>Executors</code>，它包含创建具有最常见配置的线程池的工厂方法。</p><p>工厂方法如下：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">newSingleThreadExecutor</td><td style="text-align:left">返回一个只有一个线程的ExecutorService</td></tr><tr><td style="text-align:left">newFixedThreadPool</td><td style="text-align:left">返回一个具有固定数目线程的ExecutorService</td></tr><tr><td style="text-align:left">newCachedThreadPool</td><td style="text-align:left">返回一个可变大小的线程池ExecutorService</td></tr><tr><td style="text-align:left">newSingleThreadScheduledExecutor</td><td style="text-align:left">返回只有一个线程的ScheduledExecutorService</td></tr><tr><td style="text-align:left">newScheduledThreadPool</td><td style="text-align:left">返回包含一组线程的ScheduledExecutorService</td></tr><tr><td style="text-align:left">newWorkStealingPool</td><td style="text-align:left">返回一个带有并行级别的ExecutorService</td></tr></tbody></table><p>表6 静态工厂方法</p><p>​</p><p>​</p><hr><p>当调整线程池大小时，最好基于机器运行该应用时分配的逻辑内核数。可以通过调用<code>Runtime.getRuntime().availableProcessors()</code>来获得该值。</p><hr><table><thead><tr><th style="text-align:left">实现类</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ThreadPoolExecutor</td><td style="text-align:left">默认实现，带有可选的线程大小调整池，单个工作队列和可配置的策略（用于拒绝任务）（通过RejectedExecutionHandler）和线程创建（通过ThreadFactory）。</td></tr><tr><td style="text-align:left">ScheduledThreadPoolExecutor</td><td style="text-align:left">ThreadPoolExecutor的扩展，可以创建定期任务</td></tr><tr><td style="text-align:left">ForkJoinPool</td><td style="text-align:left">作业存储池：池中的所有线程都尝试查找并运行提交的任务或其他活动任务创建的任务。</td></tr></tbody></table><p>表7 线城市的实现</p><p>任务通过<code>ExecutorService#submit</code>，<code>ExecutorService#invokeAll</code>或<code>ExecutorService#invokeAny</code>提交，它们对不同类型的任务有多种重载。</p><p>任务的功能性接口：</p><table><thead><tr><th style="text-align:left">接口</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Runnable</td><td style="text-align:left">一个没有返回值的任务</td></tr><tr><td style="text-align:left">Callable</td><td style="text-align:left">一个包含返回值的计算。它还声明可以抛出原始异常，所以不需要对检查异常进行包装</td></tr></tbody></table><p>表8 任务功能接口</p><p>​</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>Future</code>是对所有的异步计算的抽象。它表示这些计算的结果，在某些时候可用。大多数的<code>ExecutorService</code>方法都是用<code>Future</code>作为返回值。它包含检查当前future的状态以及阻塞当前读取操作直至结果可以被读取等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(() -&gt; <span class="string">"result"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  String result = future.get(<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">  System.out.println(<span class="string">"Result is '"</span> + result + <span class="string">"'."</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  Thread.currentThread().interrupt();</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getCause());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> future.isDone();</span><br></pre></td></tr></table></figure><h2 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h2><p><strong>Lock</strong><br><code>java.util.concurrent.locks</code>包中有一个标准的<code>Lock</code>接口，<code>ReentrantLock</code>实现复制了<code>synchronized</code>关键字的功能，同时提供了一些额外的功能，比如获取当前锁状态的信息，非阻塞的<code>tryBlock()</code>方法，以及可中断的锁。下面是使用具体的<code>ReentrantLock</code>实例的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h4 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock(读写锁)"></a>ReadWriteLock(读写锁)</h4><p><code>java.util.concurrent.locks</code>包还包含了<code>ReadWriteLock</code>接口（以及<code>ReentrantReadWriteLock</code>实现），它被定义为一组读写锁，支持多个同步读者和单一写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Statistic</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p><strong>CountDownLatch</strong><br><code>CountDownLatch</code>通过一个数值初始化。线程会调用<code>await()</code>方法阻塞自己，等待计数值为0后再继续运行。其它的线程（或是同一个线程）调用<code>countDown()</code>来减少计数。一旦计数为0后，该倒计时器便不可以重复使用。用来在达到某个条件后，启动一组未知数量的线程</p><p>​</p><p><strong>CompletableFuture</strong><br><code>CompletableFuture</code>是异步计算的一个抽象。不同于<code>Future</code>，只能通过阻塞获取结果，该类支持注册回调以创建在结果或异常可用时要执行的任务管道。 在创建过程中（通过<code>CompletableFuture＃supplyAsync / runAsync</code>）或在添加回调过程（*异步家族的方法）期间，都可以指定执行程序的执行者（如果未指定标准全局<code>ForkJoinPool＃commonPool</code>）。</p><hr><p>注意，如果<code>CompletableFuture</code>已完成，则通过非<code>*async</code>方法注册的回调将在调用者的线程中执行。</p><hr><p>如果有多个futures，则可以使用<code>CompletableFuture＃allOf</code>来获取所有futures都完成的future，或者使用<code>CompletableFuture＃anyOf</code>来完成任何future就可以完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor0 = Executors.newWorkStealingPool();</span><br><span class="line">ExecutorService executor1 = Executors.newWorkStealingPool();</span><br><span class="line"><span class="comment">//Completed when both of the futures are completed</span></span><br><span class="line">CompletableFuture&lt;String&gt; waitingForAll = CompletableFuture</span><br><span class="line">    .allOf(</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">"first"</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">"second"</span>, executor1)</span><br><span class="line">    )</span><br><span class="line">    .thenApply(ignored -&gt; <span class="string">" is completed."</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">"Concurrency Refcard"</span>, executor0)</span><br><span class="line">    <span class="comment">//Using same executor</span></span><br><span class="line">    .thenApply(result -&gt; <span class="string">"Java "</span> + result)</span><br><span class="line">    <span class="comment">//Using different executor</span></span><br><span class="line">    .thenApplyAsync(result -&gt; <span class="string">"Dzone "</span> + result, executor1)</span><br><span class="line">    <span class="comment">//Completed when this and other future are completed</span></span><br><span class="line">    .thenCombine(waitingForAll, (first, second) -&gt; first + second)</span><br><span class="line">    <span class="comment">//Implicitly using ForkJoinPool#commonPool as the executor</span></span><br><span class="line">    .thenAcceptAsync(result -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"Result is '"</span> + result + <span class="string">"'."</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//Generic handler</span></span><br><span class="line">    .whenComplete((ignored, exception) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (exception != <span class="keyword">null</span>)</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//First blocking call - blocks until it is not finished.</span></span><br><span class="line">future.join();</span><br><span class="line">future</span><br><span class="line">    <span class="comment">//Executes in the current thread (which is main).</span></span><br><span class="line">    .thenRun(() -&gt; System.out.println(<span class="string">"Current thread is '"</span> + Thread.currentThread().getName() + <span class="string">"'."</span>))</span><br><span class="line">    <span class="comment">//Implicitly using ForkJoinPool#commonPool as the executor</span></span><br><span class="line">    .thenRunAsync(() -&gt; System.out.println(<span class="string">"Current thread is '"</span> + Thread.currentThread().getName() + <span class="string">"'."</span>))</span><br></pre></td></tr></table></figure><p>​</p><h2 id="Concurrent-collections"><a href="#Concurrent-collections" class="headerlink" title="Concurrent collections"></a>Concurrent collections</h2><p>使集合成为线程安全的最简单方法是使用<code>Collections＃synchronized*</code>系列方法。 由于此解决方案在高并发下表现不佳，因此java.util.concurrent提供了针对并发使用进行了优化的各种数据结构。</p><h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><table><thead><tr><th style="text-align:left">实现</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">CopyOnWriteArrayList</td><td style="text-align:left">它提供了copy-on-write的语义，其中对数据结构的每次修改都会导致新的数据内部副本（因此，写入代价非常昂贵，而读取却很便宜）。 数据结构上的迭代器始终会在创建迭代器时看到其快照。</td></tr></tbody></table><p>表9 <em>Lists in</em><code>java.util.concurrent</code></p><p>​</p><h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><table><thead><tr><th style="text-align:left">实现</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ConcurrentHashMap</td><td style="text-align:left">它通常充当存储桶的哈希表。 读操作通常不会阻塞并反映最近完成的写操作的结果。只需将其CAS（compare-and-set）到存储区中即可，将第一个节点写入空容器中，而其他写入则需要锁（存储桶的第一个节点用作锁）。</td></tr><tr><td style="text-align:left">ConcurrentSkipListMap</td><td style="text-align:left">它提供并发访问以及类似于<code>TreeMap</code>的排序map功能。 性能范围与<code>TreeMap</code>相似，只要它们不修改映射的同一部分，通常多个线程就可以在不争用的情况下从映射读取和写入。</td></tr></tbody></table><p><strong>Table 10</strong>: <em>Maps in</em><code>java.util.concurrent</code></p><h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><table><thead><tr><th style="text-align:left">实现</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">CopyOnWriteArraySet</td><td style="text-align:left">与CopyOnWriteArrayList相似，它使用写时复制语义来实现Set接口。</td></tr><tr><td style="text-align:left">ConcurrentSkipListSet</td><td style="text-align:left">与ConcurrentSkipListMap相似，但是实现Set接口。</td></tr></tbody></table><p><strong>Table 11:</strong> <em>Sets in</em><code>java.util.concurrent</code></p><p>​</p><hr><p>创建并发集的另一种方法是包装 concurrent map:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>&lt;T&gt; concurrentSet = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;T, <span class="built_in">Boolean</span>&gt;());</span><br></pre></td></tr></table></figure><hr><h4 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h4><p>​<br>队列充当“生产者”和“消费者”之间的管道。 项目以相同的“先进先出”（FIFO）顺序放入管道的另一端并从管道的另一端出来。 <code>BlockingQueue</code>接口扩展了<code>Queue</code>，以提供有关如何处理队列可能已满（当生产者添加项目时）或为空（当消费者读取或删除项目时）的情况的其他选择。 在这些情况下，<code>BlockingQueue</code>提供的方法将永远阻塞或在指定时间段内阻塞，等待条件由于另一个线程的动作而改变。链表支持的无界无阻塞队列</p><table><thead><tr><th style="text-align:left">时间</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ConcurrentLinkedQueue</td><td style="text-align:left">链表支持的无界无阻塞队列</td></tr><tr><td style="text-align:left">LinkedBlockingQueue</td><td style="text-align:left">由链表支持的可选有界阻塞队列。</td></tr><tr><td style="text-align:left">PriorityBlockingQueue</td><td style="text-align:left">最小堆支持的无限制阻塞队列。 将根据与队列关联的比较器的顺序（而不是FIFO顺序）从队列中删除项目。</td></tr><tr><td style="text-align:left">DelayQueue</td><td style="text-align:left">无限制的元素队列，每个元素都有一个延迟值。 元素只有在延迟已过时才能删除，并且按照最旧的过期项目的顺序删除。</td></tr><tr><td style="text-align:left">SynchronousQueue</td><td style="text-align:left">一个长度为0的队列，生产者和使用者在其中阻塞直到对方到达为止。 当两个线程都到达时，值直接从生产者转移到消费者。 在线程之间传输数据时很有用。</td></tr></tbody></table><p><strong>Table 12:</strong> <em>Queues in</em><code>java.util.concurrent</code></p><p>​</p><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis数据结构及内部编码-hash数据结构</title>
      <link href="/2019/09/19/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"/>
      <url>/2019/09/19/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<p>更新中……</p><h1 id="前戏skiplist："><a href="#前戏skiplist：" class="headerlink" title="前戏skiplist："></a>前戏skiplist：</h1><p>在讲redis的hash数据结构之前我们先了解下skiplist<br><a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">Wikipedia</a>给出的解释如下：<br>跳跃列表(skiplist)是一种数据结构。它允许快速查询一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是O(log n)，优于普通队列的O(n)。<br>通俗的讲就是：跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>skiplist的插入流程如下<br><img src="/images/2019/09/19/Skip_list_add_element-en.gif" alt="Skip_list_add_element-en.gif"></p><a id="more"></a><p>在这里我们就不继续深讨这个算法了。</p><h2 id="Redis中的skiplist"><a href="#Redis中的skiplist" class="headerlink" title="Redis中的skiplist"></a>Redis中的skiplist</h2><p>在redis中，</p><h3 id="skiplist的定义"><a href="#skiplist的定义" class="headerlink" title="skiplist的定义"></a>skiplist的定义</h3><p>如下（server.h）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意4.x版本的ZSKIPLIST_MAXLEVEL 还是32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 64 <span class="comment">/* Should be enough for 2^64 elements */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//指向上一个节点,用于zrevrange命令</span></span><br><span class="line">   <span class="comment">// backward变量是特意为zrevrange*系列命令准备的，目的是为了使跳跃表实现反向遍历，普通跳跃表的实现里是非必要的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">//前进指针，指向下一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//到达后一个节点的跨度(两个相邻节点span为1)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];<span class="comment">//该节点在各层的信息，柔性数组成员</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">//表头和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p><h2 id="在redis的源码中，作者为了满身redis的要求，对skiplist进行了修改："><a href="#在redis的源码中，作者为了满身redis的要求，对skiplist进行了修改：" class="headerlink" title="在redis的源码中，作者为了满身redis的要求，对skiplist进行了修改："></a>在redis的源码中，作者为了满身redis的要求，对skiplist进行了修改：</h2><ul><li>允许重复的 score 值：多个不同的 member 的 score 值可以相同，当score相同时根据member(代码里的ele)的字典序来排名。</li><li>进行对比操作时，不仅要检查 score 值，还要检查 member ：当 score 值可以重复时，单靠 score 值无法判断一个元素的身份，所以需要连 member 域都一并检查才行。</li><li>每个节点都带有一个高度为 1 层的后退指针，用于从表尾方向向表头方向迭代：当执行 ZREVRANGE 或 ZREVRANGEBYSCORE 这类以逆序处理有序集的命令时，就会用到这个属性。</li></ul><h2 id="zskiplist的相关接口-z-set-c"><a href="#zskiplist的相关接口-z-set-c" class="headerlink" title="zskiplist的相关接口(z_set.c)"></a>zskiplist的相关接口(z_set.c)</h2><h3 id="创建一个zskiplist"><a href="#创建一个zskiplist" class="headerlink" title="创建一个zskiplist"></a>创建一个zskiplist</h3><p>时间复杂度O(1)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    <span class="comment">//分配空间</span></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">//设置默认层数</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置跳跃表长度</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//64level的头结点,分数为0，没有obj的跳跃表头节点</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//跳跃表头节点初始化</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        <span class="comment">//头结点每个level的下一个节点都初始化为null，跨度为0</span></span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳跃表头节点的后退指针backward置为NULL</span></span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//表头指向跳跃表尾节点的指针置为NULL</span></span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a skiplist node with the specified number of levels.</span></span><br><span class="line"><span class="comment"> * The SDS string 'ele' is referenced by the node after the call. */</span></span><br><span class="line"><span class="comment">//为指定高度的节点分配空间并赋值，insert操作也要用到</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    /柔性数组成员</span><br><span class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;zskiplist</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="zskiplist插入一个节点"><a href="#zskiplist插入一个节点" class="headerlink" title="zskiplist插入一个节点"></a>zskiplist插入一个节点</h3><p>时间复杂度O(logn)<br>插入节点的流程如下：<br><img src="/images/2019/09/19/24f2c880-dad9-11e9-820b-5b2353445520.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Insert a new node in the skiplist. Assumes the element does not already</span></span><br><span class="line"><span class="comment"> * exist (up to the caller to enforce that). The skiplist takes ownership</span></span><br><span class="line"><span class="comment"> * of the passed SDS string 'ele'. */</span></span><br><span class="line"><span class="comment">//创建一个节点，分数为score，对象为ele，插入到zsl表头管理的跳跃表中，并返回新节点的地址</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">//获取跳跃表头结点地址，从头节点开始一层一层遍历</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        <span class="comment">//遍历头节点的每个level，从下标最大层减1一直到0</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//这个while循环是查找的过程，沿着x指针遍历跳跃表，满足以下条件则要继续在当层往前走</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录该层一共跨越了多少节点 加上 上一层遍历所跨越的节点数</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            <span class="comment">//指向下一个节点</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//while循环跳出时，用update[i]记录第i层所遍历到的最后一个节点，遍历到i=0时，就要在该节点后要插入节点</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, reinserting the same element should never happen since the</span></span><br><span class="line"><span class="comment">     * caller of zslInsert() should test in the hash table if the element is</span></span><br><span class="line"><span class="comment">     * already inside or not. */</span></span><br><span class="line">    <span class="comment">//获得一个随机的层数</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">//如果大于当前所有节点最大的层数时</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="comment">//将大于等于原来zsl-&gt;level层以上的rank[]设置为0</span></span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将大于等于原来zsl-&gt;level层以上update[i]指向头结点</span></span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            <span class="comment">//update[i]已经指向头结点，将第i层的跨度设置为length，length代表跳跃表的节点数量</span></span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新表中的最大成数值</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">//设置新节点的前进指针为查找时（while循环）每一层最后一个节点的的前进指针</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">//再把查找时每层的最后一个节点的前进指针设置为新创建的节点地址</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        <span class="comment">//更新插入节点的跨度值</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="comment">//如果插入节点的level小于原来的zsl-&gt;level才会执行</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="comment">//因为高度没有达到这些层，所以只需将查找时每层最后一个节点的值的跨度加1</span></span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置插入节点的后退指针，就是查找时最下层的最后一个节点，该节点的地址记录在update[0]中</span></span><br><span class="line">    <span class="comment">//如果插入在第二个节点，也就是头结点后的位置就将后退指针设置为NULL</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//x节点不是最尾部的节点</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        <span class="comment">//将x节点后面的节点的后退节点设置成为x地址</span></span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//更新表头的tail指针，指向最尾部的节点x</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    <span class="comment">//跳跃表节点计数器加1</span></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="comment">//返回一个随机的层数，不是level的索引是层数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//有1/4的概率加入到上一层中</span></span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="zskiplist删除一个节点"><a href="#zskiplist删除一个节点" class="headerlink" title="zskiplist删除一个节点"></a>zskiplist删除一个节点</h3><p>时间复杂度O(logn)<br>释放一个节点的内存 时间复杂度O(1)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFreeNode</span><span class="params">(zskiplistNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//member的引用计数-1，防止内存泄漏</span></span><br><span class="line">    sdsfree(node-&gt;ele);</span><br><span class="line">    zfree(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free an sds string. No operation is performed if 's' is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>释放整个skiplist的内存 时间复杂度O(n)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free a whole skiplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//任何一个节点一定有level[0]，所以迭代level[0]来删除所有节点&#123;</span></span></span><br><span class="line"><span class="function">    zskiplistNode *node </span>= zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line"></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslFreeNode(node);</span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从skiplist中删除并释放掉一个节点 时间复杂度O(logn)：<br>主要分为以下3个步骤：</p><ul><li>根据member(ele)和score找到节点的位置（代码里变量x即为该节点，update记录每层x的上一个节点）</li><li>调动zslDeleteNode把x节点从skiplist逻辑上删除</li><li>释放x节点内存。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete an element with matching score/element from the skiplist.</span></span><br><span class="line"><span class="comment"> * The function returns 1 if the node was found and deleted, otherwise</span></span><br><span class="line"><span class="comment"> * 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise</span></span><br><span class="line"><span class="comment"> * it is not freed (but just unlinked) and *node is set to the node pointer,</span></span><br><span class="line"><span class="comment"> * so that it is possible for the caller to reuse the node (including the</span></span><br><span class="line"><span class="comment"> * referenced SDS string at node-&gt;ele). */</span></span><br><span class="line"><span class="comment">//从skiplist逻辑上删除一个节点并释放该节点的内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            zslFreeNode(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *node = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></span><br><span class="line"><span class="comment">//从skiplist逻辑上删除一个节点（不释放内存，仅改变节点位置关系）</span></span><br><span class="line"><span class="comment">//x为要删除的节点</span></span><br><span class="line"><span class="comment">//update为每一层x的上一个节点(为了更新x上一个节点的forward和span属性)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否是tail节点</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除了最高层数的节点</span></span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis数据结构及内部编码-string数据结构</title>
      <link href="/2019/09/16/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-string%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"/>
      <url>/2019/09/16/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-string%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<p>在redis中，当我们想要知道一个key的类型的时候，我们可以使用type命令<br>eg<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> a <span class="string">"123"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> a</span><br><span class="line">string</span><br></pre></td></tr></table></figure></p><p>如果这个key不存在的话，会返回none<br>eg:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> abcd</span><br><span class="line">none</span><br></pre></td></tr></table></figure></p><p>type命令实际返回的就是当前键的数据结构类型，它们分别是：</p><ul><li>string（字符串）</li><li>hash（哈希）</li><li>list（列表）</li><li>set（集合）</li><li>zset（有序集合）<a id="more"></a>但这些只是Redis对外的数据结构。每种数据结构都有自己底层的内部实现，并且每个都有多种实现，这样方便redis在合适的场景选择适合当前的编码方式。<br>下图是redis每种数据结构对应的内部编码<br><img src="/images/2019/09/16/c192b310-d879-11e9-8076-0fae4f4f9b65.png" alt="image.png"></li></ul><p>redis数据结构内部编码<br>我们 可以通过 <code>object encoding</code>命令查询<br>eg:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello <span class="string">"sss"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hello</span><br><span class="line"><span class="string">"embstr"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hel <span class="string">"123"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hel</span><br><span class="line"><span class="string">"int"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bigstr <span class="string">"dddddddddddfffffffffffdddddddddddddddddddddddddddddddddddddddddddsssssss"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding bigstr</span><br><span class="line"><span class="string">"raw"</span></span><br></pre></td></tr></table></figure></p><p>从上面查询的结果我们可以看到，redis的string数据结构会根据输入的value不同使用不同的数据结构。<br>下面我们从源码（基于redis 5.0.5）来分析下<br>在redis中，的每个键值内部都是使用一个名字叫做 redisObject 这个 C语言结构体保存的，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><ul><li>type：表示键值的数据类型，包括 String、List、Set、ZSet、Hash</li><li><p>encoding：表示键值的内部编码方式，从 Redis源码看目前取值有如下几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The 'encoding' field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure></li><li><p>refcount：表示该键值被引用的数量，即一个键值可被多个键引用。</p></li></ul><p>String类型的内部编码<br>在了解string类型的内部编码之前，我们先看下SDS:<br>关于SDS的详情可以异步到 <a href="https://redis.io/topics/internals-sds" target="_blank" rel="noopener">https://redis.io/topics/internals-sds</a><br>SDS（Simple dynamic string 简单动态字符串）: 当你在阅读源码的时候，你可以很容易见到这个这个词。在代码里定义了5种SDS(源码在sds.h)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从上面的代码片段中，我们可以看出每个struct内的变量都差不多</p><ul><li>len：字符串的长度（实际使用的长度）</li><li>alloc：分配内存的大小</li><li>flags：标志位，低三位表示类型，其余五位未使用</li><li>buf：字符数组</li></ul><p>通过上面的一系列枯燥的铺垫，我们开始切入正题</p><h2 id="1-INT-编码方式"><a href="#1-INT-编码方式" class="headerlink" title="1. INT 编码方式"></a>1. INT 编码方式</h2><p>当字符串键值的内容可以用一个64位有符号整型表示的时候，redis会将键值转换为long类型来存储，其对应的编码类型为:OBJ_ENCODING_INT</p><p>对于<code>set hel &quot;123&quot;</code>命令，内存结构如下</p><p><img src="/images/2019/09/16/db30b020-d882-11e9-8076-0fae4f4f9b65.png" alt="image.png"></p><p>Redis 启动时会预先建立 10000 个分别存储 0~9999 的 redisObject 变量作为共享对象，这就意味着如果 set字符串的键值在 0~10000 之间的话，则可以 直接指向共享对象 而不需要再建立新对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if we can represent this string as a long integer.</span></span><br><span class="line"><span class="comment">   * Note that we are sure that a string larger than 20 chars is not</span></span><br><span class="line"><span class="comment">   * representable as a 32 nor 64 bit integer. */</span></span><br><span class="line">  len = sdslen(s);</span><br><span class="line">  <span class="comment">// 长度小于20 (64位有符号整型)</span></span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">      <span class="comment">/* This object is encodable as a long. Try to use a shared object.</span></span><br><span class="line"><span class="comment">       * Note that we avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">       * because every object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">       * algorithm to work well. */</span></span><br><span class="line">      <span class="comment">// 当value在[0,1000)的时候，使用字符串的共享策略</span></span><br><span class="line">      <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">          !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">          value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">          value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">      &#123;</span><br><span class="line">          decrRefCount(o);</span><br><span class="line">          incrRefCount(shared.integers[value]);</span><br><span class="line">          <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) sdsfree(o-&gt;ptr);</span><br><span class="line">          o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">          o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">          <span class="keyword">return</span> o;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-EMBSTR编码格式"><a href="#2-EMBSTR编码格式" class="headerlink" title="2. EMBSTR编码格式"></a>2. EMBSTR编码格式</h2><p>Redis 在保存长度小于 44 字节的字符串时会采用 OBJ_ENCODING_EMBSTR 编码方式,源码如下(<code>object.c</code>)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a string object with EMBSTR encoding if it is smaller than</span></span><br><span class="line"><span class="comment"> * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is</span></span><br><span class="line"><span class="comment"> * used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The current limit of 44 is chosen so that the biggest string object</span></span><br><span class="line"><span class="comment"> * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字符串长度小于等于44的时候使用embstr编码格式,大于44的时候使用raw编码格式</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* Create a <span class="built_in">string</span> object with encoding OBJ_ENCODING_EMBSTR, that is</span><br><span class="line"> * an object where the sds <span class="built_in">string</span> is actually an unmodifiable <span class="built_in">string</span></span><br><span class="line"> * allocated in the same chunk as the object itself. */</span><br><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(struct sdshdr8)+len+<span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr8</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">o</span>+1);</span></span><br><span class="line"></span><br><span class="line">    o-&gt;type = OBJ_STRING;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;alloc = len;</span><br><span class="line">    sh-&gt;flags = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (ptr == SDS_NOINIT)</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>指令 set hello “sss” 所设置的键值，其内存结构示意图如下:</p><p><img src="/images/2019/09/16/7c771620-d885-11e9-8076-0fae4f4f9b65.png" alt="image.png"></p><h2 id="3-RAW-编码格式"><a href="#3-RAW-编码格式" class="headerlink" title="3. RAW 编码格式"></a>3. RAW 编码格式</h2><p>通过上面的源码分析，当字符串键值的长度大于44的时候，redis会将键值的内部编码方式改为OBJ_ENCODING_RAW格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a string object with encoding OBJ_ENCODING_RAW, that is a plain</span></span><br><span class="line"><span class="comment"> * string object where o-&gt;ptr points to a proper sds string. */</span></span><br><span class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(OBJ_STRING, sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================== Creation and parsing of objects ==================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上面的 OBJ_ENCODING_EMBSTR 编码方式的不同之处在于 此时动态字符串 sds 的内存与其依赖的 redisObject 的 内存不再连续了</p><p><img src="/images/2019/09/16/72aa2000-d886-11e9-8076-0fae4f4f9b65.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务扩展性和高可用-性能</title>
      <link href="/2019/05/20/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%826.html"/>
      <url>/2019/05/20/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%826.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://dzone.com/refcardz/scalability?chapter=6" target="_blank" rel="noopener">https://dzone.com/refcardz/scalability?chapter=6</a> </p></blockquote><h2 id="系统性能"><a href="#系统性能" class="headerlink" title="系统性能"></a>系统性能</h2><p>性能是指在定义的时间段内特定工作负载下的系统吞吐量和延迟。性能测试验证有关系统吞吐量、可伸缩性、可靠性和资源使用的实施决策。性能工程师与开发和部署团队合作, 以确保系统的非功能性需求 (如 SlA) 作为系统开发生命周期的一部分来实现。系统性能包括硬件、软件和网络优化。</p><a id="more"></a><p><strong>提示</strong>: 性能测试工作必须与开发项目同时开始, 并一直持续到部署。如果可能的话, 应针对生产环境的镜像进行测试。<br>性能工程师的目标是及早发现瓶颈, 并与开发和部署团队协作消除瓶颈。</p><h3 id="系统性能测试"><a href="#系统性能测试" class="headerlink" title="系统性能测试"></a>系统性能测试</h3><p>性能规范与SLA和系统设计一起记录。性能故障排除包括以下类型的测试：</p><ul><li>耐久性:确定在持续的预期负载下的资源泄漏。</li><li>负载测试: 确定特定负载下的系统行为。</li><li>Spike testing（尖峰冲击测试？）:显示系统如何响应负载的急剧变化而运行。</li><li>压力测试： 标识应用程序在长时间内负载变化剧烈的情况下的断点。 </li></ul><h3 id="软件测试工具"><a href="#软件测试工具" class="headerlink" title="软件测试工具"></a>软件测试工具</h3><p>市场上有很多软件性能测试工具。其中一些最好的软件是作为开源软件发布的。Dzone提供了一份综合清单。<br>这些包括Java、原生、PHP、.NET和其他语言和平台。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务扩展性和高可用-冗余和容错</title>
      <link href="/2019/05/20/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%825.html"/>
      <url>/2019/05/20/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%825.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文出处:<a href="https://dzone.com/refcardz/scalability?chapter=5" target="_blank" rel="noopener">https://dzone.com/refcardz/scalability?chapter=5</a></p></blockquote><h2 id="冗余和容错"><a href="#冗余和容错" class="headerlink" title="冗余和容错"></a>冗余和容错</h2><p>冗余系统(Redundant system)设计取决于任何系统组件故障独立于其他组件故障的预期。</p><p>容错系统在组件或子系统发生故障时继续运行；它的吞吐量可能会降低，但总体系统可用性保持不变。硬件或软件中的故障可以通过组件冗余或安全回退（如果可以在软件中进行回退）来处理。在依赖系统不可用的情况下，软件中的容错通常作为一种回退方法来实现。容错要求源自于SLA。实现依赖于硬件和软件组件，以及它们交互的规则。</p><a id="more"></a><h3 id="容错对SLA的要求"><a href="#容错对SLA的要求" class="headerlink" title="容错对SLA的要求"></a>容错对SLA的要求</h3><ul><li>无单点故障：冗余组件确保连续运行，并允许在不中断服务的情况下进行维修。</li><li>故障隔离: 问题检测必须精确定位特定的故障组件。</li><li>故障传播遏制: 一个组件中的故障不能级联到其他组件。</li><li>恢复模式：将系统设置回已知状态。 </li></ul><p>冗余集群系统可以提供更高的可用性、更好的吞吐量和容错性。图10中的A/A集群为可伸缩的无状态应用程序提供不间断的服务。</p><p><img src="/images/2019/05/09/a53cd970-721c-11e9-b22a-7d284106ced1.png" alt="image.png"><br><strong>图 10: A/A 容错与恢复</strong></p><p>一些有状态的应用程序可能只能扩展；图11中的A/P集群为此类应用程序提供不间断服务和容灾恢复。A/P配置提供配置的透明度。A/P配置可以以更好的成本提供故障透明度。因为自动故障检测和重新配置是通过反馈控制系统实现的。打宝石反馈系统的成本更高，实施起来更为棘手。</p><p><img src="/images/2019/05/09/b502a150-721c-11e9-b22a-7d284106ced1.png" alt="image.png"></p><p><strong>图 11: A/P 容错与恢复</strong></p><p>企业系统通常通过将服务转移到被动系统并尽快将其练级，从而通过故障透明来实现应付故障的容错和恢复。机器人？（Robotics）和生命临界系统可以实现概率、线性模型、故障隐藏和优化控制系统</p><h3 id="多区域"><a href="#多区域" class="headerlink" title="多区域"></a>多区域</h3><p>荣誉系统通常跨越多个区域，以地理位置来实现隔离，提供故障转移功能，并尽可能靠近消费者交付内容。这些冗余通过系统级联到所有服务中。并且单个可扩展系统可以遍历整个负载均衡集群。</p><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>云计算描述了在第三方拥有和操作分布式计算资源的情况下，来运行的应用程序。<br>最终使用者（End-user）应用程序是最常见的例子。他们利用Saas和PaaS计算模型。</p><p><img src="/images/2019/05/09/d2ffc8e0-721c-11e9-b22a-7d284106ced1.png" alt="image.png"><br><strong>图 12: 云计算配置</strong></p><h3 id="云服务类型"><a href="#云服务类型" class="headerlink" title="云服务类型"></a>云服务类型</h3><ul><li>Web 服务: Salesforce com, USPS, Google Maps.</li><li>平台服务: Google App Engine, Amazon Web Services (EC2, S3, Cloud Front), Nirvanix, Akamai, MuleSource.  </li></ul><h3 id="故障检测方法"><a href="#故障检测方法" class="headerlink" title="故障检测方法"></a>故障检测方法</h3><p>故障检测方法必须提供足够的信息来隔离故障并执行自动或辅助故障转移操作。一些最常见的故障检测方法包括:</p><ul><li>内置诊断功能。</li><li>协议嗅探器。</li><li>健康检查</li><li>Watchdog 检查.  </li></ul><p>临界性被定义为两个或两个以上检测机制在固定时间段内报告的连续故障数。如果故障检测机制报告了每个故障 (干扰), 或者它在多个监视期间没有报告真正的故障, 则该机制是无用的。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务扩展性和高可用-集群</title>
      <link href="/2019/05/19/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%824.html"/>
      <url>/2019/05/19/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%824.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文出处:<a href="https://dzone.com/refcardz/scalability?chapter=4" target="_blank" rel="noopener">https://dzone.com/refcardz/scalability?chapter=4</a>  </p></blockquote><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>集群是一组计算机系统，它们协同工作以形成用户作为单个系统的形式。部署集群是为了提高服务可用性或提高计算或数据操作性能。就等效计算能力而言，集群比具有相同性能特征的单体系统更具成本效益。</p><p>集群中的系统通过高速局域网互连，如千兆以太网、光纤分布式数据接口（FDDI）、高速网络、计算网络或其他技术。<br><a id="more"></a><br><img src="/images/2019/05/09/da647190-721b-11e9-b22a-7d284106ced1.png" alt="image.png"><br><strong>图 7: 负载均衡集群</strong></p><p><strong>负载平衡集群（主动/主动）</strong>：在多个后端冗余节点之间分配负载。集群中的所有节点都为消费者提供全服务功能，并且同时处于活动状态。<br><strong>高可用性集群（主动/被动）</strong>：通过消除单点故障的冗余集群提供不间断服务，从而提高服务可用性。高可用性集群至少需要两个节点，一个“心跳”检测所有节点是否就绪，以及一个路由机制，如果主集群出现故障，它将自动切换流量或故障转移。</p><p><img src="/images/2019/05/09/2c33e500-721c-11e9-b22a-7d284106ced1.png" alt="image.png"></p><p><strong>图 8: 集群故障转移</strong></p><p><strong>网格</strong>:流程工作负载定义为不需要在流程之间共享数据的独立作业。存储或网络可以跨网格的所有节点共享，但中间结果与其他作业进度或网格中的其他节点没有关系，例如cloudera map reduce cluster（<a href="http://www.cloudera.com/" target="_blank" rel="noopener">http://www.cloudera.com</a>)。 </p><p><img src="/images/2019/05/09/56576690-721c-11e9-b22a-7d284106ced1.png" alt="image.png"></p><p><strong>图 9: 计算集群</strong></p><p><strong>计算集群</strong>:执行需要原始计算能力的进程，而不是执行事务性操作，如Web或数据库集群。节点是紧密耦合的、均匀的，并且在物理上非常接近。他们经常取代超级计算机。 </p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译  </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务扩展性和高可用-缓存</title>
      <link href="/2019/05/16/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%823.html"/>
      <url>/2019/05/16/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%823.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文出处:<a href="https://dzone.com/refcardz/scalability?chapter=3" target="_blank" rel="noopener">https://dzone.com/refcardz/scalability?chapter=3</a></p></blockquote><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p>有状态的负载均衡技术需要服务提供者之间共享数据。<br>缓存是一种在多个消费端或服务端之间共享数据的技术,计算或获取数据都是非常昂贵的.数据存储和检索在一个子系统中。该子系统提供对频繁访问数据副本的快速访问。</p><p>缓存是通过一个索引表实现的，其中有一个唯一键用于引用某些数据。消费者首先通过检查（命中）缓存，并从缓存中检索数据来访问数据。如果数据不存在（缓存没有命中），则会发生更昂贵的索引操作，消费者或者子系统会将数据插入缓存。<br><a id="more"></a></p><h3 id="写入策略"><a href="#写入策略" class="headerlink" title="写入策略"></a>写入策略</h3><p>如果存储设备在不更新缓存的情况下更改, 则缓存可能会变成过期数据。缓存的写入策略定义了如何刷新缓存数据。一些常见的写入策略包括:</p><ul><li>直写：对缓存的每次写入都遵循对存储设备的同步写入。 </li><li>写在后面：更新的条目在缓存表中标记为脏数据，并且只有在请求脏数据时才会更新。<br>+无写入分配： 只有读请求是在数据不会随时间变化但检索成本很高的假设下缓存的。 <h3 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h3></li><li><p>隐式缓存发生在很少或没有程序员参与实现缓存的情况下。程序使用本机API执行查询和更新，缓存层自动缓存请求，与应用程序无关。示例：Terracotta（<a href="https://www.terracotta.org/）" target="_blank" rel="noopener">https://www.terracotta.org/）</a></p></li><li><p>当程序员参与实现缓存API并可能实现缓存策略时，会发生显式缓存。程序必须将缓存API放入到流中才能使用它。示例：memcached（<a href="http://www.danga.com/memcached）、redis（https://redis.io）和oracle" target="_blank" rel="noopener">http://www.danga.com/memcached）、redis（https://redis.io）和oracle</a> coherence（<a href="http://coherence.oracle.com）。" target="_blank" rel="noopener">http://coherence.oracle.com）。</a></p></li></ul><p>一般情况下隐式缓存系统是特定于平台或语言的。例如Terracotta只能运行在Java和JVM-hosted 语言上，例如Groovy或者Kotlin。。显式缓存系统可以同时用于多种编程语言和跨多个平台。<br>Memcached和Redis与每个主要的编程语言一起工作，并且与Java、.NET和本地C++应用程序一致。</p><h3 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h3><p>Web缓存用于存储文档或部分文档（更小的数据），以减少Web应用程序的服务器负载、带宽使用和延迟。Web缓存可以存在于浏览器（用户缓存）或服务器上，这是本节的主题。Web缓存对客户端不可见，可以在以下任何类别中分类：</p><ul><li><p>Web加速器：它们代表源服务器运行。用于加快对大量资源（如媒体文件）的访问，并且通常与预定的接收者进行更接近的地理定位。内容分发网络（CDN）是Web加速缓存的一个例子；Akamai、Amazon S3、Nirvanix就是这种技术的例子。 </p></li><li><p>代理缓存：它们向一组可能都有权访问同一资源的客户机提供请求。它们可以用于内容过滤和减少带宽使用。Squid、Apache、Amazon Cloud Front、ISA Server就是这种技术的例子。 </p></li></ul><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>缓存技术可以跨多个系统实现, 这些系统为多个使用者和多个资源的请求提供服务。这些称为分布式缓存, 如图6中的设置所示。Akamai 是分布式 web 缓存的示例, memcached 是分布式应用程序缓存的一个示例。</p><p><img src="/images/2019/05/09/95ad3230-721b-11e9-b22a-7d284106ced1.png" alt="image.png"></p><p><strong><em>图 6: 分布式缓存</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务扩展性和高可用-负载均衡</title>
      <link href="/2019/05/15/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%822.html"/>
      <url>/2019/05/15/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%822.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文出处:<a href="https://dzone.com/refcardz/scalability?chapter=2" target="_blank" rel="noopener">https://dzone.com/refcardz/scalability?chapter=2</a></p></blockquote><h2 id="实现系统的可扩展"><a href="#实现系统的可扩展" class="headerlink" title="实现系统的可扩展"></a>实现系统的可扩展</h2><p>SLA决定系统是否必须扩展。它们还推动了增长时间表。股票交易系统必须在最低和最高可用性水平内实时扩展。相比之下，电子商务系统可能会在一年中“缓慢”的几个月扩大规模，而在零售假日期间扩大规模，以满足更大的需求。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载平衡是一种通过在两个或多个资源之间分配请求来<code>最小化响应时间</code>和<code>最大化吞吐量</code>的技术。负载均衡器可以在专用硬件设备或软件中实现。图3显示了负载平衡系统在资源使用者看来是如何通过已知地址作为单个资源公开的。负载均衡器负责根据调度规则将请求路由到可用系统。<br><a id="more"></a><br><img src="/images/2019/05/09/c0a9f230-721a-11e9-b22a-7d284106ced1.png" alt="image.png"></p><p><strong><em>图 3: 可用性占每年总正常运行时间的百分比</em></strong><br>调度规则是用于确定必须为请求提供服务的服务器的算法。Web应用程序和服务通常通过遵循循环调度规则来实现平衡，但也可以基于最少连接、IP-hash或许多其他选项来实现平衡。缓存池通过应用频率规则和过期算法进行平衡。对于任何数量的服务器，无状态请求以统一的概率到达的应用程序可以使用伪随机调度程序。一些内容在统计上更受欢迎的应用程序，如音乐商店，可能会使用非对称的负载均衡器将更多的流行请求转移到更高性能的系统，从而服务于功能较弱的系统或集群的其余请求。</p><h3 id="持久负载均衡器"><a href="#持久负载均衡器" class="headerlink" title="持久负载均衡器"></a>持久负载均衡器</h3><p>当使用者保证与池中的特定服务器保持会话时,有状态应用程序需要持久的或粘性的负载均衡。图4显示了一个由多个客户主导的持续会话的均衡。图5显示了集群如何通过使用数据库共享数据来维护会话。</p><p><img src="/images/2019/05/09/e6e67590-721a-11e9-b22a-7d284106ced1.png" alt="image.png"><br><strong><em>图 4: 粘性负载平衡器</em></strong></p><h3 id="负载均衡器的常见功能"><a href="#负载均衡器的常见功能" class="headerlink" title="负载均衡器的常见功能"></a>负载均衡器的常见功能</h3><p>非对称负载分布-分配一些服务器来处理比其他服务器更大的负载</p><ul><li>内容筛选：入站或出站.</li><li>分布式拒绝服务（ddos）攻击保护</li><li>防火墙.</li><li>有效负载切换：根据URI、端口、与或(and/or)协议向不同的服务器发送请求。</li><li>优先级激活：将备用服务器添加到池中.</li><li>速率整形：对不同的流量给予不同优先级的能力.</li><li>脚本：通过实现编程规则或操作来减少人与人之间的交互。</li><li>本地终结TLS/SSL会话: 硬件辅助加密释放Web服务器资源</li><li>TCP缓冲和卸载：限制对池中服务器的请求</li><li>gzip压缩：降低传输带宽利用率。<br><img src="/images/2019/05/09/186c3960-721b-11e9-b22a-7d284106ced1.png" alt="image.png"><br><strong><em>图 5: 数据库 Sessions</em></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译  </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务扩展性和高可用-可扩展性、高可用性和性能</title>
      <link href="/2019/05/14/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%821.html"/>
      <url>/2019/05/14/%E7%BF%BB%E8%AF%91/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-%E7%AB%A0%E8%8A%821.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文出处:<a href="https://dzone.com/refcardz/scalability?chapter=1" target="_blank" rel="noopener">https://dzone.com/refcardz/scalability?chapter=1</a></p></blockquote><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="可扩展性、高可用性和性能"><a href="#可扩展性、高可用性和性能" class="headerlink" title="可扩展性、高可用性和性能"></a>可扩展性、高可用性和性能</h2><p>术语<code>可扩展性</code>、<code>高可用性</code>、<code>性能</code>和<code>关键任务</code>对于不同的组织或组织内的不同部门来说可能意味着不同的事情。它们经常互换，造成混乱，导致管理不善的期望、实现延迟或不切实际的指标。<br>这里的快速参考为您提供了定义这些术语的工具，以便您的团队能够实现具有良好理解的性能目标的关键任务系统。</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>它是一个系统或应用程序的属性，可以处理更多的工作，或者很容易地进行扩展，以响应对网络、处理数据、数据库访问或日益增长的文件系统资源需求。<br><a id="more"></a></p><h3 id="水平扩展性"><a href="#水平扩展性" class="headerlink" title="水平扩展性"></a>水平扩展性</h3><p>当系统进行扩展时，通过添加与现有节点功能相同的新节点，在所有节点之间重新分配负载，可以横向扩展或向外扩展。SOA系统和Web服务器通过向负载平衡网络中添加更多的服务器来扩展，以便传入的请求可以分布在所有服务器中。<code>集群</code>是描述扩展处理系统的常用术语。<br><img src="/images/2019/05/09/4c0362f0-7219-11e9-b22a-7d284106ced1.png" alt="image.png"><br><strong><em>图 1: 集群</em></strong></p><h2 id="垂直扩展性"><a href="#垂直扩展性" class="headerlink" title="垂直扩展性"></a>垂直扩展性</h2><p>当系统通过向节点添加处理、主内存、存储设备或网络接口来扩展以满足每个系统的更多请求时，系统会垂直或向上扩展。虚拟主机通过增加处理器数量或主内存数量来扩大规模，以便在同一硬件中承载更多虚拟服务器<br><img src="/images/2019/05/09/5d2f98a0-7219-11e9-b22a-7d284106ced1.png" alt="image.png"><br><strong><em>图 2:虚拟化</em></strong></p><h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p>可用性描述一个系统在一段时间内提供有用资源的能力。高可用性保证了一个时间窗口内的功能连续性的绝对程度，该时间窗口表示为正常运行时间和停机时间之间的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = 100 – (100*D/U), D ::= unplanned downtime, U ::= uptime; D, U expressed in minutes</span><br></pre></td></tr></table></figure></p><p>正常运行时间和可用性并不是同一个概念。一个系统可能会运行一个完整的测量周期，但可能由于网络中断或相关支持系统的停机而不可用。<code>停机和不可用是同义词</code>。</p><h3 id="测量可用性"><a href="#测量可用性" class="headerlink" title="测量可用性"></a>测量可用性</h3><p>供应商将可用性定义为给定的“9”个数，如表1所示，其中还描述了与365天一年或525600分钟数相关的估计停机时间的分钟或秒数，使U成为其营销目的的常数。</p><table><thead><tr><th>可用性 %</th><th>停机时间/分钟</th><th>停机时间/年</th><th>供应商术语</th></tr></thead><tbody><tr><td>90</td><td>52,560.00</td><td>36.5 天</td><td>一个9</td></tr><tr><td>99</td><td>5,256.00</td><td>4 天</td><td>两个9</td></tr><tr><td>99.9</td><td>525.60</td><td>8.8 小时</td><td>三个9</td></tr><tr><td>99.99</td><td>52.56</td><td>53 分钟</td><td>四个9</td></tr><tr><td>99.999</td><td>5.26</td><td>5.3 分钟</td><td>五个9</td></tr><tr><td>99.9999</td><td>0.53</td><td>32 秒</td><td>六个9</td></tr></tbody></table><p>表格1 1: 可用性占每年总正常运行时间的百分比</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>高可用性取决于为系统需求定义的预期正常运行时间；所以不要被供应商的数据误导。也就是说,拥有高可用性系统及其可测量的正常运行时间的意义是服务级别协议的直接功能。<br>当考虑到计划的停机时间（如每月8小时的维护时间）时，可用性会增加。每增加9个可用性的成本都会成倍增长。<br>可用性是将系统向上或向外扩展并实现系统、网络和存储冗余的功能。</p><h2 id="服务等级协议-SLA"><a href="#服务等级协议-SLA" class="headerlink" title="服务等级协议 (SLA)"></a>服务等级协议 (SLA)</h2><p>服务水平协议是一种协议条款，概述了交付和使用系统所涉及的双方的关系，例如：</p><ul><li>系统类型（虚拟或专用服务器、共享主机 )</li><li>可用性级别<ul><li>分钟</li><li>目标?</li></ul></li><li>运行时间<ul><li>网络</li><li>电源</li><li>维护窗口</li></ul></li><li>可维护性</li><li>性能和指标</li><li>费用  </li></ul><p>SLA可以约束两个内部组织（如IT和电子商务部门）之间的义务，或者组织与外包服务提供商之间的义务。SLA建立用于评估系统性能的指标，并提供可用性和可扩展性目标的定义。除非正在制定或已经存在一个SLA，否则谈论任何这些话题都没有意义。</p><h2 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h2><p>伸缩性是根据需求动态添加和删除系统中资源的能力，是水平或垂直扩展的专门实现。</p><p>当需求在繁忙时期增加时，更多的节点可以自动添加到集群中，以在需求减弱时进行扩展和删除，类似于实体零售商的季节性招聘。此外，可以重新分配系统资源，以更好地支持动态扩展的系统。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在Java中调整垃圾回收（翻译）</title>
      <link href="/2019/05/05/java/%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E8%B0%83%E6%95%B4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89.html"/>
      <url>/2019/05/05/java/%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E8%B0%83%E6%95%B4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址<a href="https://dzone.com/articles/how-to-tune-garbage-collection-in-java" target="_blank" rel="noopener">how-to-tune-garbage-collection-in-java</a><br>由于时间仓促，翻译中会出现很多错误，欢迎校正。<br>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1a81sifihhvfg" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=1a81sifihhvfg</a></p></blockquote><p>  垃圾收集是JVM在不再需要内存时代表应用程序回收内存的机制。从高层来看，它包括查找不再使用的对象，释放与这些对象相关联的内存，偶尔压缩堆以防止内存碎片化。</p><p>  垃圾收集器使用一个或多个线程执行它的工作。但是为了完成跟踪对象引用和在内存中移动对象的工作，需要确保应用程序线程当前没有使用这些对象，举个例子，如果应用程序线程正在使用对象，则对象的内存位置会由于GC而发生更改，这是更坏和不可预测的事情。这就是垃圾收集器在执行某些任务时必须暂停所有应用程序线程的原因。这种暂停有时候被称作 Stop-The-Wolrd(STW)暂停，最小化它们是GC调整的首要关注点，因为它们对Java应用程序的性能会产生巨大影响。</p><h2 id="堆的大小"><a href="#堆的大小" class="headerlink" title="堆的大小"></a>堆的大小</h2><p>垃圾收集优化的第一步是调整堆的大小。这是因为如果堆太小的话，会出现太多的GC来回收内存，这会降低应用程序的总吞吐量。如果堆太大，那么会有更少的GC，但是这些GC需要花费很长时间，响应时间指标会受到影响。并行收集器特别容易受到此问题的影响，因此如果需要大堆和低暂停时间，则应尝试使用G1GC收集器。</p><blockquote><p>备注： 自Java 9以来，Concurrent Mark Sweep（CMS）收集器已被弃用, Shenandoah Garbage Collector垃圾收集器在撰写本文时仍被认为是“实验性的”。因此，如果您运行的是联机交互式应用程序，那么G1GC应该是您的默认选择，如果您运行的是脱机批处理应用程序，那么并行收集器应该是您的第一选择。  </p></blockquote><a id="more"></a><p>堆的大小由两个值控制：用<code>ms</code>参数指定的初始值和用<code>mx</code>参数指定的最大值<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g -Xmx8g</span><br></pre></td></tr></table></figure></p><p>拥有堆的初始和最大大小允许JVM是根据工作负载自动调整堆大小。如果JVM遇到内存压力，并且发现它执行了太多的GC，它将不断增加堆，直到内存压力降低，或者直到堆达到其最大大小。如果内存压力很低，JVM还可以通过缩小堆大小来决定减少暂停时间。这个过程称为<code>自适应大小调整</code>，它不仅调整堆的总体大小，而且调整年轻代和老年代的大小和比率。</p><p>如果您花了一些时间来微调应用程序的GC行为和大小，您可以选择关闭自适应大小调整。这可以节省JVM，即计算堆大小所需的一小段时间。您可以通过将参数<code>useAdaptiveSizePolicy</code>设置为false来完成此操作。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure></p><p>另外，将初始堆大小设置为与最大堆大小相同的值，或将初始新生代大小设置为与最大新生代大小相同的值，可以有效地关闭部分自适应大小调整行为。</p><p>强烈建议设置最大堆大小的准则是：最大堆大小不应超过计算机上的物理内存量。如果有多个JVM在运行，那么最大堆大小之和不应该超过机器的物理内存。</p><p>设置最大堆大小的一个更一般的建议是，应该设置该大小，以便在完全GC之后堆占满30%。要计算这个值，您可以在GC日志中查找发生完整GC的条目，并观察GC完成时使用了多少内存。或者，您可以运行应用程序，直到它达到稳定状态，然后使用<code>jconsole</code>或<code>jcmd</code>强制执行完整的GC。</p><h2 id="GC性能调优"><a href="#GC性能调优" class="headerlink" title="GC性能调优"></a>GC性能调优</h2><p>如果启用了自适应大小调整，则可以使用<code>MaxGCPauseMillis</code>参数来调整GC行为。此标志为最大GC暂停时间设置目标。当与并行收集器一起使用时，JVM将调整年轻一代和老年一代的大小，以尝试实现目标。然后，它将调整堆的大小，以便在GC中花费的时间不超过某个值，默认情况下，该值为1%。</p><p>G1GC的目标之一是它将需要最小的调优。因此，在G1GC中，一个调优参数<code>maxgcpausemillis</code>执行以下所有优化，以尝试实现指定的暂停时间目标：</p><ul><li>调整堆的大小,</li><li>尽快开始后台处理,</li><li>调整要提升到老年代的对象的寿命阈值，</li><li>调整在混合GC循环期间处理的老年代数。<br>在G1GC中，参数的默认值是200ms，虽然您可能会尝试将其设置为非常小的值，如20 ms，但请注意，为了实现此目的，垃圾收集器将把新生代缩小到非常小的大小，并收集较少的老年代，这最终会导致出现垃圾太多的情况。老年代和系统必须执行完整的GC，这是不可取的。</li></ul><h2 id="修复并发模式故障"><a href="#修复并发模式故障" class="headerlink" title="修复并发模式故障"></a>修复并发模式故障</h2><p>G1GC是一个并发收集器。这意味着垃圾收集进程的某些阶段可以在应用程序线程仍在运行时并发运行。由于正在运行的应用程序可以继续产生垃圾，因此我们可能会遇到这样的情况：当垃圾收集器仍处于垃圾收集过程的中间时，应用程序将耗尽老年代内存。换句话说，正在运行的应用程序产生垃圾的速度比可以清除垃圾的速度要快。这种情况被称为<code>并发模式故障</code>，提升故障或疏散故障，具体取决于故障发生的时间。如果您在GC日志中看到很多这些错误，那么解决方案是要么增加堆的大小，更早地启动G1后台处理，要么通过使用更多的后台线程来加速GC处理。</p><p>要更频繁地执行g1后台活动，可以降低触发G1周期的阈值。这是通过减少<code>InitiatingEapOccupancyPercent</code>参数值来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent=45</span><br></pre></td></tr></table></figure></p><p>默认情况下，这个参数设置为45。这意味着当堆填充45%时，将触发GC循环。减小这个值意味着GC将更早更频繁地被触发。但应注意的是，该值不能设置为太低的数字，这将导致GCS发生的频率太高。</p><p>要增加后台线程的数量，请使用concgthreads参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx:concgthreads=4个</span><br></pre></td></tr></table></figure></p><p>这个参数的默认值设置为<code>ParallelGCThreads</code>的值加上2，再除以4。只要机器上有足够的CPU可用，就可以增加该值，而不会造成任何性能损失。</p><p>如果调优堆大小和调优收集器对您不起作用，那么您可以尝试另一个收集器。如果您仍然没有得到好的结果，那么您需要考虑调整应用程序代码本身。</p><p>愉快的调优吧！</p><p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1a81sifihhvfg" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=1a81sifihhvfg</a></p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>es集群使用xpack（基于elastic 6.5.4）</title>
      <link href="/2019/03/23/%E8%BF%90%E7%BB%B4/es%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8xpack%EF%BC%88%E5%9F%BA%E4%BA%8Eelastic-6-5-4%EF%BC%89.html"/>
      <url>/2019/03/23/%E8%BF%90%E7%BB%B4/es%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8xpack%EF%BC%88%E5%9F%BA%E4%BA%8Eelastic-6-5-4%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>集群搭建过程略</p></blockquote><h2 id="1-启用trial-license"><a href="#1-启用trial-license" class="headerlink" title="1. 启用trial license"></a>1. 启用trial license</h2><blockquote><p>如果已经有正式license可以忽略这个步骤  </p></blockquote><p>执行命令激活xpack<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">"Content-Type:application/json"</span> -XPOST  http://xxx:9200/_xpack/license/start_trial?acknowledge=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="1-2-es开启xpack"><a href="#1-2-es开启xpack" class="headerlink" title="1.2. es开启xpack"></a>1.2. es开启xpack</h2><a id="more"></a><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">xpack.security.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>设置密码，在master设置，node节点可以同步该用户名/密码</p></blockquote><p>到此为止完成xpack集群,目前无SSL。</p><h1 id="2-使用SSL"><a href="#2-使用SSL" class="headerlink" title="2. 使用SSL"></a>2. 使用SSL</h1><h2 id="2-1-master节点生成证书"><a href="#2-1-master节点生成证书" class="headerlink" title="2.1 master节点生成证书"></a>2.1 master节点生成证书</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-certutil ca</span><br></pre></td></tr></table></figure><p>保存<code>elastic-stack-ca.p12</code>路径并输入密码（123456）<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12</span><br></pre></td></tr></table></figure></p><p>保存<code>elastic-certificates.p12</code>路径并输入密码（123456）<br>将上面生成的两个文件拷贝到elastic的config目录下<br>比如我设置的是在config/certs下面</p><h2 id="2-2-证书拷贝至所有elasticsearch节点"><a href="#2-2-证书拷贝至所有elasticsearch节点" class="headerlink" title="2.2 证书拷贝至所有elasticsearch节点"></a>2.2 证书拷贝至所有elasticsearch节点</h2><ul><li>所有elasticsearch节点启用SSL<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r config/certs/ elk@node2:/opt/elasticsearch-6.5.4/config/</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3-elasticsearch-yml中增加配置"><a href="#2-3-elasticsearch-yml中增加配置" class="headerlink" title="2.3 elasticsearch.yml中增加配置"></a>2.3 elasticsearch.yml中增加配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">xpack.security.transport.ssl.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">xpack.security.transport.ssl.verification_mode:</span> <span class="string">certificate</span></span><br><span class="line"><span class="string">xpack.security.transport.ssl.keystore.path:</span> <span class="string">certs/elastic-certificates.p12</span></span><br><span class="line"><span class="string">xpack.security.transport.ssl.truststore.path:</span> <span class="string">certs/elastic-certificates.p12</span></span><br><span class="line"><span class="string">```</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.4 所有elasticsearch节点将密码添加至elasticsearch-keystore</span></span><br><span class="line"><span class="string">```sh</span></span><br><span class="line"></span><br><span class="line"><span class="string">]$</span> <span class="string">bin/elasticsearch-keystore</span> <span class="string">add</span> <span class="string">xpack.security.transport.ssl.keystore.secure_password</span></span><br><span class="line"><span class="string">]$</span> <span class="string">bin/elasticsearch-keystore</span> <span class="string">add</span> <span class="string">xpack.security.transport.ssl.truststore.secure_password</span></span><br></pre></td></tr></table></figure><p>查看集群状态(也可以通过kibana或者其他工具查看)<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:9200/_cluster/health</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019/03/23/83450670-4d42-11e9-935c-498aaea502b1.png" alt="image.png"></p><p>参考地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/configuring-tls.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.2/configuring-tls.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elk </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式链路追踪-Dapper论文简述</title>
      <link href="/2019/03/11/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA-Dapper%E8%AE%BA%E6%96%87.html"/>
      <url>/2019/03/11/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA-Dapper%E8%AE%BA%E6%96%87.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在现在的微服务系统中，客户端的一次操作往往需要经过多个模块、多个中间件、多台机器的相互协作才能完成。在这一系列的请求中，可能是串行也可能是并行，那么如何确定客户端的一次操作背后调用了哪些应用、哪些模块，经过了哪些节点，每个模块的调用先后顺序是怎样的，每个模块的性能问题如何？随着业务系统模型的日趋复杂化，分布式系统中急需一套链路追踪（Trace）系统来解决这些痛点。<br><a id="more"></a><br>分布式服务跟踪是整个分布式系统中跟踪一个用户请求的过程，包括数据采集、数据传输、数据存储、数据分析和数据可视化，捕获此类跟踪让我们构建用户交互背后的整个调用链的视图，这是调试和监控微服务的关键工具。</p><h1 id="Dapper简述"><a href="#Dapper简述" class="headerlink" title="Dapper简述"></a>Dapper简述</h1><p>说起分布式链路追踪，我们就不得不提到 Dapper，然后就不得不提下面这个图：<br><img src="/images/2019/03/11/21711900-43c1-11e9-a8bd-cb8e5e5e5942.png" alt="image.png"><br>图 1 中 A~E 分别表示五个服务，</p><ol><li>用户发起一次 X 请求到前端系统 A，  </li><li>然后 A 分别发送 RPC 请求到中间层 B 和 C，  </li><li>B 处理请求后返回，  </li><li>C 还要发起两个 RPC 请求到后端系统 D 和 E。<br>以上完整调用回路中，一次请求需要经过多个系统处理完成，并且追踪系统像是内嵌在 RPC 调用链上的树形结构，然而，我们的核心数据模型不只局限于特定的 RPC 框架，我们还能跟踪其他行为，例如外界的 HTTP 请求，和外部对 Kafka 服务器的调用等。从形式上看，分布式追踪模型使用的 Trace 树形结构来记录请求之间的关系（父子关系、先后顺序等）。</li></ol><p>从众多的分布式系统应用中得出的经验，对于分布式追踪系统需要满足至少两点要求：涵盖面的广度和持续的监控。</p><ol><li>涵盖广度的重要性不言而喻，因为在使用追踪系统的进行监控时，如果有一小部分没被监控到，那么人们对这个系统是不是值得信任都会产生巨大的质疑。</li><li>监控应该是 7x24 小时的，毕竟，系统异常或是那些重要的系统行为有可能出现过一次，就很难甚至不太可能重现。那么，根据这两个明确的需求，可以推出如下几个具体的设计目标：</li></ol><blockquote><p>低性能损耗 (Low overhead)：分布式在线系统对于性能、资源要求都很严格，Trace 组件必须对服务影响足够小。对于一些高度优化过的服务，即使一点点性能损耗也会很容易察觉到，而且有可能迫使在线服务的部署团队不得不将分布式追踪系统关停。</p></blockquote><blockquote><p>应用级的透明 (Application-level transparency)：应用层开发者不需要对 Trace 组件关心，Trace 嵌入到基础通用库中，提供高稳定性，而如果 Trace 需要应用开发者配合，那可能会引入额外的 bug 导致 Trace 系统更加脆弱。面对当下互联网公司快速迭代的开发环境来说，这一点尤其重要。</p></blockquote><blockquote><p>扩展性 (Scalability)：Google 的服务在线集群数量可想而知，一次检索就可能跨越上百台甚至成千台机器，因此这个 Trace Infrastructure 的扩展性也很重要。</p></blockquote><h1 id="Trace-和-Span"><a href="#Trace-和-Span" class="headerlink" title="Trace 和 Span"></a>Trace 和 Span</h1><p>Google Dapper 中关于 Trace 的介绍中主要有以下三个主要元素构成：</p><ol><li>Span：基本工作单元，例如，在一个新建的 Span 中发送一个 RPC 等同于发送一个回应请求给 RPC，Span 通过一个 64 位 ID 唯一标识，Trace 以另一个 64 位 ID 表示。Span 还有其他数据信息，比如摘要、时间戳事件、关键值注释 (Tags)、Span 的 ID、以及进度 ID (通常是 IP 地址)。Span 在不断地启动和停止，同时记录了时间信息，当你创建了一个 Span，你必须在未来的某个时刻停止它。</li><li>Trace 树：一系列 Span 组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个 Trace 树。</li><li>Annotation（标注）：用来及时记录一个事件的存在，一些核心 Annotation 用来定义一个请求的开始和结束。<br>分布式追踪系统要做的就是记录每次发送和接受动作的标识符和时间戳，将一次请求涉及到的所有服务串联起来，只有这样才能清楚记录每次请求的完整调用链。在分布式追踪系统中使用 Trace 表示对一次请求完整调用链的跟踪，将两个服务例如上面图 1 中的服务 A 和服务 B 的请求/响应过程叫做一次 Span。 我们可以看出每一次跟踪 Trace 都是一个树型结构，Span 可以体现出服务之间的具体依赖关系。</li></ol><p>对于每个 Trace 树，Trace 都要定义一个全局唯一的 Trace ID，在这个跟踪中的所有 Span 都将获取到这个 Trace ID。 每个 Span 都有一个 Parent Span ID 和它自己的 Span ID。上面图 1 中 A 服务的 Parent Span ID 为空，Span ID 为 1；然后 B 服务的 Parent Span ID 为 1，Span ID 为 2；C 服务的 Parent Span ID 也为 1，Span ID 为 3，依次类推。<br>详细的说明请参考下面的几篇文章，这几篇文章描述的都很详细<br>参考资料:</p><ul><li><a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36356.pdf" target="_blank" rel="noopener">Dapper论文</a></li><li><a href="https://www.ibm.com/developerworks/cn/web/wa-distributed-systems-request-tracing/index.html" target="_blank" rel="noopener">IBM</a></li><li><a href="https://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener">Dapper论文翻译版</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 链路追踪 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>dubbo源码解析2-项目结构</title>
      <link href="/2019/02/15/dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.html"/>
      <url>/2019/02/15/dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别说明，基于2.7.0  </p></blockquote><p>下面的内容主要来自官网，可以移步<a href="http://dubbo.apache.org/zh-cn/docs/dev/design.html" target="_blank" rel="noopener">官网</a></p><h1 id="1-框架设计"><a href="#1-框架设计" class="headerlink" title="1. 框架设计"></a>1. 框架设计</h1><a id="more"></a><p><img src="/images/2019/02/15/d4cbdfa0-30dc-11e9-ade1-a511bd99bf1c.png" alt="image.png"><br>图例说明：</p><ul><li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li><li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li><li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li><li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li></ul><h1 id="2-模块分包"><a href="#2-模块分包" class="headerlink" title="2.模块分包"></a>2.模块分包</h1><p><img src="/images/2019/02/15/92a6e3e0-30dc-11e9-ade1-a511bd99bf1c.png" alt="image.png"><br><img src="/images/2019/02/15/21878a20-30dc-11e9-ade1-a511bd99bf1c.png" alt="image.png"><br>模块说明：</p><h2 id="2-1-dubbo-common"><a href="#2-1-dubbo-common" class="headerlink" title="2.1 dubbo-common"></a>2.1 dubbo-common</h2><p>公共逻辑模块：包括 Util 类和通用模型。<br>项目代码结构如下<br><img src="/images/2019/02/15/365c11e0-30dd-11e9-ade1-a511bd99bf1c.png" alt="image.png">  </p><h2 id="2-2-dubbo-remoting"><a href="#2-2-dubbo-remoting" class="headerlink" title="2.2 dubbo-remoting"></a>2.2 dubbo-remoting</h2><p>远程通讯模块：相当于 Dubbo 协议的实现，如果 RPC 用 RMI协议则不需要使用此包。<br><img src="/images/2019/02/15/c02f9630-30ec-11e9-849a-8da18d248662.png" alt="image.png"></p><ul><li>dubbo-remoting-zookeeper<br>封装了Zookeeper Client ，和 Zookeeper Server 通信</li><li>dubbo-remoting-api<br>定义Dubbo Client和 Dubbo Server的接口规则</li><li>dubbo-remoting-grizzly<br>基于 <a href="https://javaee.github.io/grizzly/" target="_blank" rel="noopener">Grizzly</a> 实现。</li><li>dubbo-remoting-http<br>基于 <a href="https://www.eclipse.org/jetty/" target="_blank" rel="noopener">Jetty</a> 或 <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat</a> 实现。</li><li>dubbo-remoting-mina<br>基于 <a href="https://mina.apache.org/" target="_blank" rel="noopener">Mina</a> 实现。</li><li>dubbo-remoting-netty<br>基于 <a href="https://netty.io/" target="_blank" rel="noopener">Netty 3</a> 实现。</li><li>dubbo-remoting-netty4<br>基于 <a href="https://netty.io/" target="_blank" rel="noopener">Netty 4</a> 实现。</li><li>dubbo-remoting-p2p<br>P2P 服务器。注册中心 <code>dubbo-registry-multicast</code> 项目的使用该项目。</li></ul><h2 id="2-3-dubbo-rpc"><a href="#2-3-dubbo-rpc" class="headerlink" title="2.3 dubbo-rpc"></a>2.3 dubbo-rpc</h2><p>远程调用模块：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。<br>官方性能报告地址（基于2.0版本，不是最新）：<a href="http://dubbo.apache.org/zh-cn/docs/user/perf-test.html" target="_blank" rel="noopener">dubbo性能测试报告</a><br><img src="/images/2019/02/15/8d78d700-30ed-11e9-849a-8da18d248662.png" alt="image.png"></p><ul><li>dubbo-rpc-api<br>抽象各种协议以及动态代理，实现了一对一的调用。</li><li>其他模块，实现 dubbo-rpc-api ，提供对应的协议实现<br>协议参考手册</li></ul><h2 id="2-4-dubbo-cluster"><a href="#2-4-dubbo-cluster" class="headerlink" title="2.4 dubbo-cluster"></a>2.4 dubbo-cluster</h2><p>集群模块：将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</p><h2 id="2-5-dubbo-registry"><a href="#2-5-dubbo-registry" class="headerlink" title="2.5 dubbo-registry"></a>2.5 dubbo-registry</h2><p>注册中心模块：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</p><h2 id="2-6-dubbo-monitor"><a href="#2-6-dubbo-monitor" class="headerlink" title="2.6 dubbo-monitor"></a>2.6 dubbo-monitor</h2><p>监控模块：统计服务调用次数，调用时间的，调用链跟踪的服务。</p><h2 id="2-7-dubbo-config"><a href="#2-7-dubbo-config" class="headerlink" title="2.7 dubbo-config"></a>2.7 dubbo-config</h2><p>配置模块：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。<br>dubbo也提供了四种配置方式，</p><ul><li>XML配置</li><li>属性配置</li><li>API配置</li><li>注解配置<br>项目代码结构如下<br><img src="/images/2019/02/15/aa17a810-30e2-11e9-ade1-a511bd99bf1c.png" alt="image.png"></li></ul><p>dubbo-config-api：实现了API配置和属性配置的功能。<br>dubbo-config-spring：实现了XML配置和注解配置的功能</p><h2 id="2-8-dubbo-container"><a href="#2-8-dubbo-container" class="headerlink" title="2.8 dubbo-container"></a>2.8 dubbo-container</h2><p>容器模块：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</p>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dubbo源码解析1-什么是dubbo</title>
      <link href="/2019/02/13/dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901-%E4%BB%80%E4%B9%88%E6%98%AFdubbo.html"/>
      <url>/2019/02/13/dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901-%E4%BB%80%E4%B9%88%E6%98%AFdubbo.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是-dubbo？"><a href="#1-什么是-dubbo？" class="headerlink" title="1. 什么是 dubbo？"></a>1. 什么是 dubbo？</h1><p><a href="http://dubbo.apache.org/zh-cn/index.html" target="_blank" rel="noopener">官方</a>给出的定义是：Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。<br>dubbo产生的背景，详见 <a href="http://dubbo.apache.org/zh-cn/docs/user/preface/background.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/preface/background.html</a></p><h1 id="2-什么是-RPC？"><a href="#2-什么是-RPC？" class="headerlink" title="2. 什么是 RPC？"></a>2. 什么是 RPC？</h1><p>RPC（Remote Procedure Call） 详见<a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">Wikipedia</a> 、<a href="https://www.ibm.com/developerworks/cn/aix/library/au-rpc_programming/index.html" target="_blank" rel="noopener">IBM</a>。这里不再累述。</p><h1 id="3-dubbo的发展史"><a href="#3-dubbo的发展史" class="headerlink" title="3. dubbo的发展史"></a>3. dubbo的发展史</h1><a id="more"></a><p>说起dubbo，就不得不提 SOA（Service Oriented Ambiguity），可以看下Martin Fowler在2005年的这篇<a href="https://www.martinfowler.com/bliki/ServiceOrientedAmbiguity.html" target="_blank" rel="noopener">文章</a><br>Martin Fowler认为：SOA意味服务接口，意味流程整合，意味资源再利用，意味着管制，在下面SOA组件图中，服务和服务消费者(客户端)之间存在多个约束，当一个服务显式暴露后，客户端能够通过绑定定位到该服务，相当于两者签订了合同，规定了合同内容和如何实施，具体合同的描述是通过消息方式进行：<br><img src="/images/2019/02/14/b2d2d290-303d-11e9-9ca1-4912d7f30a5e.png" alt="image.png"><br>回到正题</p><ul><li>2008年，阿里巴巴开始内部使用 Dubbo。</li><li>2009年初，发布 1.0 版本。</li><li>2010 年初，发布 2.0 版本。</li><li>2011 年 10 月，阿里巴巴宣布开源，版本为 2.0.7。</li><li>2012 年 3 月，发布 2.1.0 版本。这一年dubbo宣称已经每天为2000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。2012年10月23日Dubbo2.5.3发布后，在Dubbo开源将满一周年之际，阿里基本停止了对Dubbo的主要升级。</li><li>2013 年 3 月，发布 2.4.10 版本。</li><li>2014 年 10 月，发布 2.3.11 版本，之后版本停滞。<br>2013年和2014年更新过2次对Dubbo2.4的维护版本，然后停止了所有维护工作。Dubbo对Spring的支持也停留在了Spring 2.5.6版本上。</li><li>2014 年 10 月，当当网 Fork 了 Dubbo 版本，命名为 Dubbox-2.8.0，并支持 HTTP REST 协议。支持了新版本的Spring，并对外开源了Dubbox</li><li>2017 年 9 月，阿里巴巴重启维护，重点升级所依赖 JDK 及组件版本，发布 2.5.4/5 版本。距离上一个版本2.5.3发布已经接近快5年时间了。在随后的几个月中，阿里Dubbo开发团队以差不多每月一版本的速度开始快速升级迭代，修补了Dubbo老版本多年来存在的诸多bug，并对Spring等组件的支持进行了全面升级。</li><li>2017 年 10 月，发布 2.5.6 版本。</li><li>2017 年 11 月，发布 2.5.7 版本，后期集成 Spring Boot。</li><li>2018年1月8日，Dubbo 2.6.0版本发布，新版本将之前当当网开源的Dubbo分支Dubbox进行了合并，实现了Dubbo版本的统一整合。  </li></ul><p>github地址：<a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">incubator-dubbo</a></p><h1 id="4-dubbo的架构"><a href="#4-dubbo的架构" class="headerlink" title="4. dubbo的架构"></a>4. dubbo的架构</h1><p>详见<a href="http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html</a><br><img src="/images/2019/02/13/f3e97e90-2f6c-11e9-acfe-2541123bc20a.png" alt="image.png"></p><p>节点角色说明：  </p><table><thead><tr><th>节点名称</th><th>说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方。</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方。</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心。</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心。</td></tr></tbody></table><p>调用流程<br>0.服务容器负责启动，加载，运行服务提供者。<br>1.服务提供者在启动时，向注册中心注册自己提供的服务。<br>2.服务消费者在启动时，向注册中心订阅自己所需的服务。<br>3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p><h1 id="5-生态系统"><a href="#5-生态系统" class="headerlink" title="5. 生态系统"></a>5. 生态系统</h1><ul><li>脚手架<br>快速生成基于 Spring Boot 的 Dubbo 项目:<br><a href="http://start.dubbo.io/" target="_blank" rel="noopener">Dubbo Initializr</a></li><li>多语言<br><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">java</a><br><a href="https://github.com/dubbo/dubbo2.js" target="_blank" rel="noopener">Node.js</a><br><a href="https://github.com/dubbo/dubbo-client-py" target="_blank" rel="noopener">Python</a><br><a href="https://github.com/dubbo/dubbo-php-framework" target="_blank" rel="noopener">PHP</a></li><li>API<br>Dubbo支持通过多种API方式启动:<br><a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html" target="_blank" rel="noopener">Spring XML</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/annotation.html" target="_blank" rel="noopener">Spring Annotation</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/properties.html" target="_blank" rel="noopener">Plain Java</a><br><a href="https://github.com/apache/incubator-dubbo-spring-boot-project" target="_blank" rel="noopener">Spring Boot</a></li><li><p>Registry<br>对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；<br>对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。<br>而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。<br>通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。<br>Dubbo支持以下注册中心:<br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/zookeeper.html" target="_blank" rel="noopener">Zookeeper</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/redis.html" target="_blank" rel="noopener">Redis</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/simple.html" target="_blank" rel="noopener">Simple</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/multicast.html" target="_blank" rel="noopener">Multicast</a><br><a href="https://github.com/dubbo/dubbo-registry-etcd" target="_blank" rel="noopener">Etcd3</a> </p></li><li><p>Cluster<br>Dubbo支持以下容错机制:<br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">Fail over</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">Fail safe</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">Fail fast</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">Fail back</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">Forking</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">Broadcast</a> </p></li><li><p>Load balance<br>Dubbo支持以下负载均衡策略:<br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html" target="_blank" rel="noopener">Random</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html" target="_blank" rel="noopener">Least Active</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html" target="_blank" rel="noopener">Round Robin</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html" target="_blank" rel="noopener">Consistent hash</a></p></li><li><p>Protocol<br>Dubbo支持以下协议:<br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html" target="_blank" rel="noopener">Dubbo</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rmi.html" target="_blank" rel="noopener">RMI</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/hessian.html" target="_blank" rel="noopener">Hessian</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/http.html" target="_blank" rel="noopener">HTTP</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/webservice.html" target="_blank" rel="noopener">WebService</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/thrift.html" target="_blank" rel="noopener">Thrift</a><br><a href="https://github.com/dubbo/dubbo-rpc-native-thrift" target="_blank" rel="noopener">Native Thrift</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/memcached.html" target="_blank" rel="noopener">Memcached</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/redis.html" target="_blank" rel="noopener">Redis</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rest.html" target="_blank" rel="noopener">Rest</a><br><a href="https://github.com/apache/incubator-dubbo-rpc-jsonrpc" target="_blank" rel="noopener">JsonRPC</a><br><a href="https://github.com/dubbo/incubator-dubbo-rpc-xmlrpc" target="_blank" rel="noopener">XmlRPC</a><br><a href="https://github.com/dubbo/incubator-dubbo-rpc-jms" target="_blank" rel="noopener">JmsRpc</a>  </p></li><li><p>Transport<br>Dubbo支持以下网络传输扩展:<br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Netty3</a><br><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/netty4.html" target="_blank" rel="noopener">Netty4</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Grizzly</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Jetty</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Mina</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">P2P</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Zookeeper</a>  </p></li><li><p>Serialization<br>Dubbo支持以下序列化机制:<br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Hessian2</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Java</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">JSON</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Fst</a><br><a href="http://dubbo.apache.org/zh-cn/community/index.html" target="_blank" rel="noopener">Kryo</a><br><a href="https://github.com/dubbo/dubbo-serialization-native-hessian" target="_blank" rel="noopener">Native Hessian</a><br><a href="https://github.com/dubbo/dubbo-serialization-avro" target="_blank" rel="noopener">Avro</a></p></li></ul><h1 id="6-Dubbo和Spring-Cloud对比"><a href="#6-Dubbo和Spring-Cloud对比" class="headerlink" title="6. Dubbo和Spring Cloud对比"></a>6. Dubbo和Spring Cloud对比</h1><p>spring Cloud架构</p><p>Spring Cloud总体架构如下图<br><img src="/images/2019/02/14/65488610-3041-11e9-9ca1-4912d7f30a5e.png" alt="image.png">  </p><table><thead><tr><th>节点名称</th><th>说明</th></tr></thead><tbody><tr><td>Service Provider</td><td>暴露服务的提供方。</td></tr><tr><td>Service Consumer</td><td>调用远程服务的服务消费方。</td></tr><tr><td>EureKa Server</td><td>服务注册中心和服务发现中心。</td></tr></tbody></table><p>spring Cloud组件图<br><img src="/images/2019/02/14/332617a0-3042-11e9-9ca1-4912d7f30a5e.png" alt="image.png">  </p><table><thead><tr><th>名称</th><th>Dubbo</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>服务注册中心</td><td>Zookeeper/Redis</td><td>Eureka</td></tr><tr><td>服务调用方式</td><td>RPC</td><td>REST API</td></tr><tr><td>断路器</td><td>不完善</td><td>Hystrix</td></tr><tr><td>分布式配置</td><td>(Nacos)</td><td>Spring Cloud Config(Nacos)</td></tr><tr><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth</td></tr><tr><td>消息总线</td><td>无</td><td>Spring Cloud Bus</td></tr><tr><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr></tbody></table><p>…..</p><p>大致可以理解为什么说Dubbo只是类似Netflix的一个子集了吧。<br>需要申明一点，Dubbo对于上表中总结为“无”的组件不代表不能实现，而只是Dubbo框架自身不提供，需要另外整合以实现对应的功能</p>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq如何工作以及rabbitmq核心概念(翻译)</title>
      <link href="/2019/01/07/rabbitmq%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%8F%8Arabbitmq%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E7%BF%BB%E8%AF%91.html"/>
      <url>/2019/01/07/rabbitmq%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%8F%8Arabbitmq%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E7%BF%BB%E8%AF%91.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文出处: <a href="https://dzone.com/articles/how-rabbitmq-works-and-rabbitmq-core-concepts-1" target="_blank" rel="noopener">https://dzone.com/articles/how-rabbitmq-works-and-rabbitmq-core-concepts-1</a>  </p></blockquote><p>在本文中，我们将学习什么是<a href="http://www.javaguides.net/p/rabbitmq-java-tutorial-with-examples.html" target="_blank" rel="noopener">RabbitMQ</a>，它是如何工作的，以及<a href="http://www.javaguides.net/p/rabbitmq-java-tutorial-with-examples.html" target="_blank" rel="noopener">RabbitMQ</a>的核心概念。<br><a id="more"></a><br>RabbitMQ是一个开源的消息代理软件。它接受来自生产者的消息并将其传递给消费者。它就像一个中间人，可以用来减少Web应用服务器的负载和投递时间。</p><h2 id="RabbitMQ是如何工作的"><a href="#RabbitMQ是如何工作的" class="headerlink" title="RabbitMQ是如何工作的"></a>RabbitMQ是如何工作的</h2><p>我们简单的看下RabbitMQ是如何工作的。<br>我们首先熟悉rabbitmq的几个重要概念:  </p><ul><li>生产者(Producer)：发送消息的应用。</li><li>消费者(Consumer)：接收消息的应用。</li><li>队列(Queue)：存储消息的缓冲区。</li><li>消息(Message)：通过RabbitMQ从生产者发送给消费者的信息。</li><li>连接(Connection)：连接是应用程序和RabbitMQ代理之间的TCP连接。</li><li>通道(Channel)：通道是连接内部的虚拟连接。当您发布或使用队列中的消息时，都是通过通道完成的。</li><li>交换机(Exchange)：接收来自生产者的消息，并根据交换类型定义的规则将它们推送到队列中。要接收消息，需要将队列绑定到至少一个交换。</li><li>绑定(Binding)：绑定是队列和交换之间的链接。</li><li>路由密钥(Routing key)：路由密钥是Exchange用来决定如何将消息路由到队列的密钥。路由密钥类似于邮件的地址。</li></ul><p><strong>Producers</strong>向代理发送/发布消息-&gt;<strong>Consumers</strong>从代理接收消息。<strong>RabbitMQ</strong>充当生产者和消费者之间的通信中间件，即使它们在不同的机器上运行。<br>当生产者向队列中发送消息时，它不会直接发送，而是使用交换机发送。下面的设计演示了三个主要组件是如何相互连接的。<br>交换代理负责将消息路由到不同队列。以便消息可以从生产者接收到交换，然后再次转发到队列。这就是所谓的“发布”方法。  </p><p><img src="/image/rabbitmq/rabbitmq1.png"></p><p>将从队列中提取和使用消息；这称为“使用”。</p><h2 id="发送消息到多个队列"><a href="#发送消息到多个队列" class="headerlink" title="发送消息到多个队列"></a>发送消息到多个队列</h2><p>通过拥有更复杂的应用程序，我们将拥有多个队列。因此消息将在多个队列中发送它。<br><img src="/image/rabbitmq/rabbitm-multiple-queues.png"><br>将消息发送到多个队列交换通过绑定和路由键连接到队列。绑定是为将队列连接到交换而设置的“链接”。路由密钥是一个消息属性。在决定如何将消息路由到队列时（取决于交换类型），交换可能会查看此键。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>消息不是直接通过队列直接发送，相反，生产者通过交换机发送消息。交换机负责将消息路由到不同的队列。交换机接受来自生产者应用程序的消息，并在绑定和路由键的帮助下将它们路由到消息队列。绑定连接着队列和交换机。<br><img src="/image/rabbitmq/exchanges-bidings-routing-keys.png">  </p><h2 id="RabbitMQ中的消息流"><a href="#RabbitMQ中的消息流" class="headerlink" title="RabbitMQ中的消息流"></a>RabbitMQ中的消息流</h2><ul><li>生产者发布一个消息到交换机。当创建交换机时，必须指定其类型。稍后将详细解释不同类型的交换。</li><li>交换机接收消息后立马负责消息的路由。根据交换类型，交换会考虑不同的消息属性，例如路由密钥。</li><li>必须创建从交换机到队列的绑定。在本例中，我们看到两个绑定到来自交换机的两个不同队列。交换机根据消息属性将消息路由到队列中。</li><li>消息一直在队列中，直到被消费者处理</li><li>消费者处理消息。</li></ul><h2 id="交换机的类型"><a href="#交换机的类型" class="headerlink" title="交换机的类型"></a>交换机的类型</h2><p><img src="/image/rabbitmq/exchanges-topic-fanout-direct.png"></p><ol><li>直接类型(Direct)：直接交换机根据消息路由密钥将消息传递到队列。</li><li>多播类型(fanout): 多播交换机将消息路由到绑定到它的所有队列。</li><li>主题类型(Topic): 主题交换在路由密钥和绑定中指定的路由模式之间进行通配符匹配。</li><li>头类型(Headers): 头交换机使用消息头属性进行路由。</li></ol><h1 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h1><p>这里有一些重要的概念需要在我们深入研究rabbitmq之前进行描述。</p><ul><li>生产者(Producer): 发送消息的应用。</li><li>消费者(Consumer)：接收消息的应用。</li><li>队列(Queue): 存储消息的缓冲区。</li><li>消息(Message)：通过RabbitMQ从生产者发送给消费者的信息。</li><li>连接(Connection)：连接是应用程序和RabbitMQ代理之间的TCP连接。</li><li>通道(Channel)：通道是连接内部的虚拟连接。当您发布或使用队列中的消息时，都是通过通道完成的。</li><li>交换机(Exchange)：接收来自生产者的消息，并根据交换类型定义的规则将它们推送到队列中。要接收消息，需要将队列绑定到至少一个交换。</li><li>绑定(Binding)：绑定是队列和交换之间的链接。</li><li>路由密钥(Routing key)：路由密钥是Exchange用来决定如何将消息路由到队列的密钥。路由密钥类似于邮件的地址。</li><li>AMQP: AMQP(Advanced Message Queuing Protocol)是RabbitmQ消息之间的协议。</li><li>用户(Users): 可以使用给定的用户名和密码连接到RabbitmQ。可以为每个用户分配权限，例如在实例中读取、写入和配置权限。</li></ul><p>一旦我们熟悉RabbitMQ的核心概念和了解RabbitMQ如何工作，现在让我们用下面的文章来亲身体验rabbitmq：</p><blockquote><p><a href="http://www.javaguides.net/2018/12/rabbitmq-java-helloworld-example.html" target="_blank" rel="noopener">RabbitMQ Java HelloWorld Example</a>  - 在这篇文章中，我们将会学到在java的Hello world 示例中如何使用RabbitMQ。</p></blockquote><blockquote><p><a href="http://www.javaguides.net/2018/12/rabbitmq-tutorial-with-publishsubscribe-example.html" target="_blank" rel="noopener">RabbitMQ Tutorial with Publish/Subscribe Example</a> - 在本教程中，我们将查看rabbitmq的概述，然后我们将逐步开发一个发布/订阅示例。</p></blockquote><p>查看完整的RabbitMQ教程，这里<a href="http://www.javaguides.net/p/rabbitmq-java-tutorial-with-examples.html" target="_blank" rel="noopener">here</a>有具体示例。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p><a href="https://www.rabbitmq.com" target="_blank" rel="noopener">https://www.rabbitmq.com</a></p></li><li><p><a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/tutorial-one-java.html</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 日志格式化</title>
      <link href="/2019/01/01/java-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E5%8C%96.html"/>
      <url>/2019/01/01/java-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-日志的重要性"><a href="#1-日志的重要性" class="headerlink" title="1.日志的重要性"></a>1.日志的重要性</h1><p>不管我们使用何种语言开发,一旦程序发生异常，日志是一个很重要的数据。但是并不是意味着打印的日志越多越好，我们需要的是有用的日志。<br>曾经参与一个很重要的项目优化，他们的日志没有进行规范，开发、运维也没有把这个事情放在心上。等到压测的时候TPS和响应时间一直上不去。通过jstack分析发现，大部分的log数据在阻塞！<br>今天我们不讨论具体的日志规范，我从日志中心的角度来聊下LOG的规范<br><a id="more"></a></p><h1 id="2-日志采集分析-ELK"><a href="#2-日志采集分析-ELK" class="headerlink" title="2.日志采集分析 -ELK"></a>2.日志采集分析 -ELK</h1><p>目前主流的ELK系统应该都是通过agent端(filebeat/flume)采集具体<code>.log</code>文件，对于日志没有多大处理的话，我们可能把整条日志采集过来后，通过logstash后把message存储到elasticsearch中。</p><blockquote><ol><li>当我们需要从每条日志中提取日志时间、日志级别等等信息的时候，我们需要在logstash配置相应的 <code>grok</code>语法解析其中的message信息。</li><li>当我们的日志中有异常信息，我们需要提取异常信息的时候，你会发现用<code>grok</code>来清洗message很困难！其实也有解决的方法，需要你去慢慢写正则匹配</li></ol></blockquote><p>不错，logstash强大的grok及mutate可以满足需求，但是当日志量很大的时候，logstash的grok和mutate会消耗大量的资源。那我们有没有更有的方案呢？<br>下面我们用java日志来举例吧<br>在想要得到答案之前，我们需要知道存储到es的最终数据是<code>JSON</code>，logstash清洗数据最终的结果是转换成JSON。一般的agent采集端仅仅只是做日志的采集,即使kafka做缓冲，kafka也不做处理。因此我们需要从日志的根源来解决这个问题。</p><h1 id="3-为什么使用logstash处理Java的异常信息不好做呢？"><a href="#3-为什么使用logstash处理Java的异常信息不好做呢？" class="headerlink" title="3.为什么使用logstash处理Java的异常信息不好做呢？"></a>3.为什么使用logstash处理Java的异常信息不好做呢？</h1><p>这就涉及到日志框架输出的异常信息通常是多行的，这就意味着我们需要在filebeat(flume)或者logstash来处理多行的问题。当我们在日志的配置文件没有很好的区分日志的message和stack时，日志是糅杂一块的。提前其中的信息很难很难</p><h1 id="4-日志json化"><a href="#4-日志json化" class="headerlink" title="4. 日志json化"></a>4. 日志json化</h1><p>既然原生的日志数据不好处理，那么我们需要对日志框架做些美容手术。<br>在日志中，我们一般都会打印，时间/日志级别/线程/日志内容/当前文件名/loggerName/异常信息等等。<br>其中 日志内容和异常信息可能会出现多行。这个需要处理下，下面我们使用fastjson来处理这两个字段，见代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgConverter</span> <span class="keyword">extends</span> <span class="title">ClassicConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.serialize(event.getFormattedMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTraceConverter</span> <span class="keyword">extends</span> <span class="title">ThrowableProxyConverter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        IThrowableProxy throwableProxy = event.getThrowableProxy();</span><br><span class="line">        <span class="comment">// 如果没有异信息</span></span><br><span class="line">        <span class="keyword">if</span> (throwableProxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//返回字符串 ： "\"\""</span></span><br><span class="line">            <span class="keyword">return</span> JsonUtils.serialize(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String ex = <span class="keyword">super</span>.convert(event);</span><br><span class="line">        <span class="keyword">return</span> JsonUtils.serialize(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中JsonUtils可以选择合适的json框架来处理</p><p>之后在logback.xml中配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"exdiy"</span> <span class="attr">converterClass</span>=<span class="string">"xxx.logback.converter.StackTraceConverter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"msgdiy"</span> <span class="attr">converterClass</span>=<span class="string">"xxx.logback.converter.MsgConverter"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>修改layout -&gt; Pattern<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;Pattern&gt;&#123;"date":"%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;","level":"%level","tid":"%tid","className":"%logger","fileLine":"%file:%line","msg":%message, "stack_trace":%ex &#125;%n&lt;/Pattern&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>&#123;"date":"%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;","level":"%level","className":"%logger","fileName":"%file","thread":"%thread","msg":%msgdiy, "stack_trace":%exdiy&#125;%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"date"</span>:<span class="string">"2019-01-02 16:16:33.817"</span>,</span><br><span class="line">    <span class="attr">"level"</span>:<span class="string">"INFO"</span>,</span><br><span class="line">    <span class="attr">"className"</span>:<span class="string">"org.springframework.web.servlet.DispatcherServlet"</span>,<span class="attr">"fileName"</span>:<span class="string">"FrameworkServlet.java"</span>,<span class="attr">"thread"</span>:<span class="string">"http-nio-8762-exec-1"</span>,<span class="attr">"msg"</span>:<span class="string">"FrameworkServlet 'dispatcherServlet': initialization completed in 38 ms"</span>, <span class="attr">"stack_trace"</span>:<span class="string">""</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logstash将json字符串转换成json即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">json &#123;</span><br><span class="line">       source =&gt; &quot;message&quot;</span><br><span class="line">       #target =&gt; &quot;doc&quot;</span><br><span class="line">       remove_field =&gt; [&quot;message&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    date &#123;</span><br><span class="line">        match =&gt; [&quot;date&quot;,&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;]</span><br><span class="line">        target =&gt; &quot;@timestamp&quot;</span><br><span class="line">        locale =&gt; &quot;cn&quot;</span><br><span class="line">        timezone =&gt; &quot;Asia/Shanghai&quot;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>最终效果</p><image src="/image/loback-elk.jpg"></image>]]></content>
      
      
      
        <tags>
            
            <tag> elk </tag>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis相关监控参数</title>
      <link href="/2018/12/19/Redis%E7%9B%B8%E5%85%B3%E7%9B%91%E6%8E%A7%E5%8F%82%E6%95%B0.html"/>
      <url>/2018/12/19/Redis%E7%9B%B8%E5%85%B3%E7%9B%91%E6%8E%A7%E5%8F%82%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-慢查询"><a href="#1-慢查询" class="headerlink" title="1 慢查询"></a>1 慢查询</h2><p>默认情况下命令若是执行时间超过10ms就会被记录到日志，slowlog只会记录其命令执行的时间，不包含io往返操作，也不记录单由网络延迟引起的响应慢。如果想修改慢命令的标准可以使用下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 超过5毫秒为慢命令</span><br><span class="line">config set slowlog-log-slower-than 5000</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>获取最慢的n条数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog get &#123;n&#125;</span><br></pre></td></tr></table></figure></p><p>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; slowlog get 2</span><br><span class="line">1) 1) (integer) 7923</span><br><span class="line">   2) (integer) 1544423728</span><br><span class="line">   3) (integer) 27501</span><br><span class="line">   4) 1) &quot;KEYS&quot;</span><br><span class="line">      2) &quot;*&quot;</span><br></pre></td></tr></table></figure></p><p>参数含义:</p><ul><li>1=日志的唯一标识符</li><li>2=被记录命令的执行时间点，以 UNIX 时间戳格式表示</li><li>3=查询执行时间，以微秒为单位。例子中命令使用27毫秒。</li><li>4= 执行的命令，以数组的形式排列。完整命令是config get *。</li></ul><h2 id="2-大对象"><a href="#2-大对象" class="headerlink" title="2 大对象"></a>2 大对象</h2><p>使用scanning方式，对redis整个keyspace进行统计（数据量大时采样），寻找每种数据类型key的最大size(key)和平均size。(5种数据类型(String、hash、list、set、zset)的最大key).<br> 该程序使用 SCAN 命令，因此它可以在不影响客户端操作的情况下在繁忙的服务器上执行，不过也可以使用-i选项来限制所请求的每100个键的扫描过程的秒数。 例如，-i 0.1会减慢程序的执行速度，但也会大幅减轻服务器上的负载<br>执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h &#123;ip&#125; -p &#123;port&#125; --bigkeys</span><br></pre></td></tr></table></figure></p><p>建议：</p><blockquote><p>把大对象拆分为多个小对象，防止一次命令操作过多数据  </p></blockquote><p>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">~]# redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line">#Scanning the entire keyspace to find biggest keys as well as</span><br><span class="line">#average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span><br><span class="line">#per 100 SCAN commands (not usually needed).</span><br><span class="line">[00.00%] Biggest string found so far &apos;db:zz&apos; with 23 bytes</span><br><span class="line">[00.00%] Biggest string found so far &apos;prefix_1519436646796_2018_5_320401_001_9&apos; with 73 bytes</span><br><span class="line">[00.00%] Biggest string found so far &apos;prefix_1511407515841_2018_5_320586_101_-1&apos; with 74 bytes</span><br><span class="line">[00.00%] Biggest string found so far &apos;XX152844756614862018&apos; with 1219 bytes</span><br><span class="line">[00.03%] Biggest string found so far &apos;xxxx.m.164c2285-f8ed-4ed9-ad5e-c8633846ac95.21001004&apos; with 24662 bytes</span><br><span class="line">[00.25%] Biggest string found so far &apos;cpt.xml.model.key:280&apos; with 32914 bytes</span><br><span class="line">[00.71%] Biggest string found so far &apos;xxxx.m.164c2285-f8ed-4ed9-ad5e-c8633846ac95.48&apos; with 94341 bytes</span><br><span class="line">[01.84%] Biggest set    found so far &apos;spring:session:expirations:1545198360000&apos; with 2 members</span><br><span class="line">[05.58%] Biggest hash   found so far &apos;spring:session:sessions:53490998-30c2-4850-8f73-646fe82cd7ee&apos; with 4 fields</span><br><span class="line">[06.29%] Biggest string found so far &apos;xxxx.m.164c2285-f8ed-4ed9-ad5e-c8633846ac95.35001001&apos; with 120437 bytes</span><br><span class="line">[07.74%] Biggest hash   found so far &apos;spring:session:sessions:c28d62e7-27c5-439b-aaf7-7e3d7915db62&apos; with 10 fields</span><br><span class="line">[08.14%] Biggest string found so far &apos;xxxx.m.d526ca6d-f9a3-48f4-8117-3474778d1fbd.221&apos; with 420048 bytes</span><br><span class="line">[08.70%] Biggest string found so far &apos;xxxx.m.164c2285-f8ed-4ed9-ad5e-c8633846ac95.221&apos; with 420086 bytes</span><br><span class="line">[53.84%] Biggest set    found so far &apos;spring:session:expirations:1545198540000&apos; with 4 members</span><br><span class="line">[81.98%] Biggest hash   found so far &apos;spring:session:sessions:f3459c14-fb8d-44cc-beab-20a68a2699f0&apos; with 11 fields</span><br><span class="line">[82.04%] Biggest string found so far &apos;qwer&apos; with 443204 bytes</span><br><span class="line">-------- summary -------</span><br><span class="line">Sampled 33464 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 1284216 (avg len 38.38)</span><br><span class="line">Biggest string found &apos;qwer&apos; has 443204 bytes</span><br><span class="line">Biggest    set found &apos;spring:session:expirations:1545198540000&apos; has 4 members</span><br><span class="line">Biggest   hash found &apos;spring:session:sessions:f3459c14-fb8d-44cc-beab-20a68a2699f0&apos; has 11 fields</span><br><span class="line">33439 strings with 30379572 bytes (99.93% of keys, avg size 908.51)</span><br><span class="line">0 lists with 0 items (00.00% of keys, avg size 0.00)</span><br><span class="line">9 sets with 14 members (00.03% of keys, avg size 1.56)</span><br><span class="line">16 hashs with 107 fields (00.05% of keys, avg size 6.69)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00)</span><br></pre></td></tr></table></figure></p><h2 id="3-查询Redis并发量-连续统计模式"><a href="#3-查询Redis并发量-连续统计模式" class="headerlink" title="3 查询Redis并发量,连续统计模式"></a>3 查询Redis并发量,连续统计模式</h2><p>滚动显示服务器信息（keys、mem、clients、blocked、requests、connections）,默认情况下，每秒都会打印一条新的数据行，其中包含有用信息和旧数据点之间的差异 可以加-i 选项的作用就是修改输出新数据行的频率。 默认值是一秒.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h &#123;ip&#125; -p &#123;port&#125; --stat -i &lt;interval&gt;</span><br></pre></td></tr></table></figure></p><p>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~]# redis-cli --stat</span><br><span class="line">------- data ------ --------------------- load -------------------- - child -</span><br><span class="line">keys       mem      clients blocked requests            connections          </span><br><span class="line">33463      39.28M   128     0       1597991946 (+0)     21894492    </span><br><span class="line">33463      39.37M   127     0       1597991987 (+41)    21894500    </span><br><span class="line">33463      39.29M   127     0       1597992021 (+34)    21894500    </span><br><span class="line">33463      39.26M   127     0       1597992060 (+39)    21894500    </span><br><span class="line">33463      39.37M   127     0       1597992098 (+38)    21894500</span><br></pre></td></tr></table></figure></p><ul><li><p>客户端相关参数  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info Clients</span><br><span class="line">#Clients</span><br><span class="line">connected_clients:126</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 4 连接的客户端数量(connected_clients)</span><br><span class="line">```sh</span><br><span class="line">redis-cli -h &#123;ip&#125; -p &#123;port&#125; info Clients | grep connected_clients</span><br></pre></td></tr></table></figure></li></ul><p>这个值跟使用redis的服务的连接池配置关系比较大，Redis默认允许客户端连接的最大数量是10000。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxclients </span><br><span class="line">1) &quot;maxclients&quot;</span><br><span class="line">2) &quot;10000&quot;</span><br></pre></td></tr></table></figure></p><p>若是看到连接数超过5000以上，那可能会影响Redis的性能。倘若一些或大部分客户端发送大量的命令过来，这个数字会低的多。根据连接数负载的情况，这个数字应该设置为预期连接数峰值的110%到150之间，若是连接数超出这个数字后，Redis会拒绝并立刻关闭新来的连接。通过设置最大连接数来限制非预期数量的连接数增长，是非常重要的。<br>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~]# redis-cli info Clients | grep connected_clients</span><br><span class="line">connected_clients:129</span><br></pre></td></tr></table></figure></p><h2 id="5-拒绝连接数"><a href="#5-拒绝连接数" class="headerlink" title="5 拒绝连接数"></a>5 拒绝连接数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli info stats | grep rejected_connections</span><br></pre></td></tr></table></figure><p>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~]# redis-cli info stats | grep rejected_connections</span><br><span class="line">rejected_connections:0</span><br></pre></td></tr></table></figure></p><h2 id="6-阻塞客户端数量"><a href="#6-阻塞客户端数量" class="headerlink" title="6 阻塞客户端数量"></a>6 阻塞客户端数量</h2><p>blocked_clients，一般是执行了list数据类型的BLPOP或者BRPOP命令引起的,这个值最好应该为0<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h &#123;ip&#125; -p &#123;port&#125; info Clients | grep blocked_clients</span><br></pre></td></tr></table></figure></p><p>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~]# redis-cli info Clients | grep blocked_clients</span><br><span class="line">blocked_clients:0</span><br></pre></td></tr></table></figure></p><h2 id="7-内存碎片率"><a href="#7-内存碎片率" class="headerlink" title="7 内存碎片率"></a>7 内存碎片率</h2><p><img src="/image/jedis/redis-ratio.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~]# redis-cli -h &#123;ip&#125; -p &#123;port&#125; info | grep mem_fragmentation_ratio</span><br><span class="line">mem_fragmentation_ratio:1.58</span><br></pre></td></tr></table></figure></p><p>info信息中的mem_fragmentation_ratio给出了内存碎片率的数据指标，它是由操系统分配的内存除以Redis分配的内存得出：<br>used_memory和used_memory_rss数字都包含的内存分配有：</p><ul><li>用户定义的数据：内存被用来存储key-value值。</li><li>内部开销： 存储内部Redis信息用来表示不同的数据类型。  </li></ul><p>used_memory_rss的rss是Resident Set Size的缩写，表示该进程所占物理内存的大小，是操作系统分配给Redis实例的内存大小。除了用户定义的数据和内部开销以外，used_memory_rss指标还包含了内存碎片的开销，内存碎片是由操作系统低效的分配/回收物理内存导致的。 </p><p>内存碎片率稍大于1是合理的，这个值表示内存碎片率比较低，也说明redis没有发生内存交换。但如果内存碎片率超过1.5，那就说明Redis消耗了实际需要物理内存的150%，其中50%是内存碎片率。若是内存碎片率低于1的话，说明Redis内存分配超出了物理内存，操作系统正在进行内存交换。</p><h2 id="8-监视在Redis中执行的命令"><a href="#8-监视在Redis中执行的命令" class="headerlink" title="8 监视在Redis中执行的命令"></a>8 监视在Redis中执行的命令</h2><p>使用MONITOR模式后，将自动输入监控模式。它将打印Redis实例收到的所有命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h &#123;ip&#125; -p &#123;port&#125; monitor</span><br></pre></td></tr></table></figure></p><p>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~]# redis-cli monitor</span><br><span class="line">OK</span><br><span class="line">1545199828.803965 [0 172.23.0.238:60576] &quot;PING&quot;</span><br><span class="line">1545199828.804126 [0 172.23.0.238:60576] &quot;SETNX&quot; &quot;scanKey&quot; &quot;xxxxxx&quot;</span><br><span class="line">1545199828.804392 [0 172.23.0.238:60576] &quot;PING&quot;</span><br><span class="line">1545199828.804572 [0 172.23.0.238:60576] &quot;PEXPIRE&quot; &quot;scanKey&quot; &quot;10000&quot;</span><br></pre></td></tr></table></figure></p><p>参考地址:<br><a href="https://redis.io/topics/rediscli" target="_blank" rel="noopener">https://redis.io/topics/rediscli</a><br><a href="https://www.cnblogs.com/mushroom/p/4738170.html" target="_blank" rel="noopener">https://www.cnblogs.com/mushroom/p/4738170.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java堆栈信息不见了</title>
      <link href="/2018/12/12/java%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF%E4%B8%8D%E8%A7%81%E4%BA%86.html"/>
      <url>/2018/12/12/java%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF%E4%B8%8D%E8%A7%81%E4%BA%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>最近同事通过ELK查找异常日志发现,exception的栈不见了，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">异常信息:java.lang.NullPointerException</span><br><span class="line">异常信息:java.lang.NullPointerException</span><br><span class="line">异常信息:java.lang.NullPointerException</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>本地试了很多次一直都能打印出异常信息，那么前面那段只有简单的java.lang.NullPointerException，没有详细异常栈信息的原因是什么呢？于是他问怎么出现这个现象的，我跟他说这种情况是 JVM对一些特定的异常类型做了Fast Throw优化导致的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">    ...</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></p><h1 id="2-什么是Fast-Throw"><a href="#2-什么是Fast-Throw" class="headerlink" title="2. 什么是Fast Throw"></a>2. 什么是Fast Throw</h1><p>JVM中有个参数：OmitStackTraceInFastThrow，就是省略异常栈信息将异常快速抛出。</p><h2 id="2-1-JVM是如何做到快速抛出的呢？"><a href="#2-1-JVM是如何做到快速抛出的呢？" class="headerlink" title="2.1 JVM是如何做到快速抛出的呢？"></a>2.1 JVM是如何做到快速抛出的呢？</h2><p>JVM对一些特定的异常类型做了Fast Throw优化，如果检测到在代码里某个位置连续多次抛出同一类型异常的话，C2会决定用Fast Throw方式来抛出异常，而异常Trace即详细的异常栈信息会被清空。这种异常抛出速度非常快，因为不需要在堆里分配内存，也不需要构造完整的异常栈信息。相关的源码的JVM源码的graphKit.cpp文件中<br>源码地址<br><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/tip/src/share/vm/opto/graphKit.cpp(从514行开始)" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/tip/src/share/vm/opto/graphKit.cpp(从514行开始)</a></p><h2 id="2-2-Fast-Throw源码解析"><a href="#2-2-Fast-Throw源码解析" class="headerlink" title="2.2 Fast Throw源码解析"></a>2.2 Fast Throw源码解析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//------------------------------builtin_throw----------------------------------</span></span><br><span class="line"><span class="keyword">void</span> GraphKit::builtin_throw(Deoptimization::DeoptReason reason, Node* arg) &#123;</span><br><span class="line">  <span class="keyword">bool</span> must_throw = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">// If this particular condition has not yet happened at this</span></span><br><span class="line">  <span class="comment">// bytecode, then use the uncommon trap mechanism, and allow for</span></span><br><span class="line">  <span class="comment">// a future recompilation if several traps occur here.</span></span><br><span class="line">  <span class="comment">// If the throw is hot, try to use a more complicated inline mechanism</span></span><br><span class="line">  <span class="comment">// which keeps execution inside the compiled code.</span></span><br><span class="line">  <span class="keyword">bool</span> treat_throw_as_hot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ProfileTraps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (too_many_traps(reason)) &#123;</span><br><span class="line">      treat_throw_as_hot = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (If there is no MDO at all, assume it is early in</span></span><br><span class="line">    <span class="comment">// execution, and that any deopts are part of the</span></span><br><span class="line">    <span class="comment">// startup transient, and don't need to be remembered.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Also, if there is a local exception handler, treat all throws</span></span><br><span class="line">    <span class="comment">// as hot if there has been at least one in this method.</span></span><br><span class="line">    <span class="keyword">if</span> (C-&gt;trap_count(reason) != <span class="number">0</span></span><br><span class="line">        &amp;&amp; method()-&gt;method_data()-&gt;trap_count(reason) != <span class="number">0</span></span><br><span class="line">        &amp;&amp; has_ex_handler()) &#123;</span><br><span class="line">        treat_throw_as_hot = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this throw happens frequently, an uncommon trap might cause</span></span><br><span class="line">  <span class="comment">// a performance pothole.  If there is a local exception handler,</span></span><br><span class="line">  <span class="comment">// and if this particular bytecode appears to be deoptimizing often,</span></span><br><span class="line">  <span class="comment">// let us handle the throw inline, with a preconstructed instance.</span></span><br><span class="line">  <span class="comment">// Note:   If the deopt count has blown up, the uncommon trap</span></span><br><span class="line">  <span class="comment">// runtime is going to flush this nmethod, not matter what.</span></span><br><span class="line">  <span class="comment">// 满足两个条件：1.检测到频繁抛出异常，2. OmitStackTraceInFastThrow为true，或StackTraceInThrowable为false</span></span><br><span class="line">  <span class="keyword">if</span> (treat_throw_as_hot</span><br><span class="line">      &amp;&amp; (!StackTraceInThrowable || OmitStackTraceInFastThrow)) &#123;</span><br><span class="line">    <span class="comment">// If the throw is local, we use a pre-existing instance and</span></span><br><span class="line">    <span class="comment">// punt on the backtrace.  This would lead to a missing backtrace</span></span><br><span class="line">    <span class="comment">// (a repeat of 4292742) if the backtrace object is ever asked</span></span><br><span class="line">    <span class="comment">// for its backtrace.</span></span><br><span class="line">    <span class="comment">// Fixing this remaining case of 4292742 requires some flavor of</span></span><br><span class="line">    <span class="comment">// escape analysis.  Leave that for the future.</span></span><br><span class="line">    ciInstance* ex_obj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (reason) &#123;</span><br><span class="line">    <span class="keyword">case</span> Deoptimization::Reason_null_check:</span><br><span class="line">      ex_obj = env()-&gt;NullPointerException_instance();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Deoptimization::Reason_div0_check:</span><br><span class="line">      ex_obj = env()-&gt;ArithmeticException_instance();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Deoptimization::Reason_range_check:</span><br><span class="line">      ex_obj = env()-&gt;ArrayIndexOutOfBoundsException_instance();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Deoptimization::Reason_class_check:</span><br><span class="line">      <span class="keyword">if</span> (java_bc() == Bytecodes::_aastore) &#123;</span><br><span class="line">        ex_obj = env()-&gt;ArrayStoreException_instance();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ex_obj = env()-&gt;ClassCastException_instance();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看到默认对下面的Exception都做了Fast Throw。</p><ul><li>NullPointerException</li><li>ArithmeticException</li><li>ArrayIndexOutOfBoundsException</li><li>ArrayStoreException</li><li>ClassCastException<blockquote><p>OmitStackTraceInFastThrow和StackTraceInThrowable都默认为true，所以条件(!StackTraceInThrowable || OmitStackTraceInFastThrow)为true，即JVM默认开启了Fast Throw优化。</p></blockquote></li></ul><p>如果想关闭Fast Throw的优化，在启动参数加上配置<br>-XX:-OmitStackTraceInFastThrow，<br>StackTraceInThrowable保持默认配置即可。</p><h1 id="3-验证结果"><a href="#3-验证结果" class="headerlink" title="3.验证结果"></a>3.验证结果</h1><p>写一个简单的代码验证<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaNPE</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"getSimpleName is:"</span>+<span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" execute count："</span> + (++count));</span><br><span class="line">            String str = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFastThrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        JavaNPE javaNPE = <span class="keyword">new</span> JavaNPE();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            executorService.execute(javaNPE);</span><br><span class="line">            <span class="comment">//防止打出的日志太快</span></span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在没有加入<code>-XX:-OmitStackTraceInFastThrow</code>测试结果(NPE连续抛出5000+次就会丢失异常栈):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">getSimpleName is:JavaNPE execute count：6666</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">at com.jason.demo.demo.JavaNPE.run(JavaNPE.java:18)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">getSimpleName is:JavaNPE execute count：6667</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">at com.jason.demo.demo.JavaNPE.run(JavaNPE.java:18)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.NullPointerExceptiongetSimpleName is:JavaNPE execute count：6668</span><br><span class="line"></span><br><span class="line">at com.jason.demo.demo.JavaNPE.run(JavaNPE.java:18)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">getSimpleName is:JavaNPE execute count：6669</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">getSimpleName is:JavaNPE execute count：6670</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">getSimpleName is:JavaNPE execute count：6671</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">getSimpleName is:JavaNPE execute count：6672</span><br><span class="line">java.lang.NullPointerException</span><br></pre></td></tr></table></figure></p><p>加入<code>-XX:-OmitStackTraceInFastThrow</code>测试结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getSimpleName is:JavaNPE execute count：11325</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">at com.jason.demo.demo.JavaNPE.run(JavaNPE.java:18)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">getSimpleName is:JavaNPE execute count：11326</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">at com.jason.demo.demo.JavaNPE.run(JavaNPE.java:18)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">getSimpleName is:JavaNPE execute count：11327</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="https://www.oracle.com/technetwork/java/javase/relnotes-139183.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/relnotes-139183.html</a><br><a href="https://stackoverflow.com/questions/2411487/nullpointerexception-in-java-with-no-stacktrace" target="_blank" rel="noopener">https://stackoverflow.com/questions/2411487/nullpointerexception-in-java-with-no-stacktrace</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JedisPool常见问题</title>
      <link href="/2018/12/09/JedisPool%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
      <url>/2018/12/09/JedisPool%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<ul><li><ol><li>无法从连接池获取到Jedis连接<h2 id="1-1-异常堆栈"><a href="#1-1-异常堆栈" class="headerlink" title="1.1. 异常堆栈"></a>1.1. 异常堆栈</h2>(1) 连接池参数blockWhenExhausted = true(默认)</li></ol></li></ul><p>如果连接池没有可用Jedis连接，会等待maxWaitMillis(毫秒)，依然没有获取到可用Jedis连接，会抛出如下异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool</span><br><span class="line">    …</span><br><span class="line">Caused by: java.util.NoSuchElementException: Timeout waiting for idle object</span><br><span class="line">    at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:449)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>(2) 连接池参数blockWhenExhausted = false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool</span><br><span class="line">    …</span><br><span class="line">Caused by: java.util.NoSuchElementException: Pool exhausted</span><br><span class="line">    at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:464)</span><br></pre></td></tr></table></figure></p><p>jedisPool与Redis交互示例</p><p><image src="/image/jedis/jedispool-use.png"><br>上述异常是客户端没有从连接池(最大maxTotal个)拿到可用Jedis连接造成的，具体可能有如下原因：</image></p><p>(1) 连接泄露 (较为常见)</p><p>JedisPool默认的maxTotal=8，下面的代码从JedisPool中借了8次Jedis，但是没有归还，当第9次(jedisPool.getResource().ping())</p><p>(2) 业务并发量大，maxTotal确实设置小了。<br>举个例子：</p><p>一次命令时间（borrow|return resource + Jedis执行命令(含网络) ）的平均耗时约为1ms，一个连接的QPS大约是1000<br>业务期望的QPS是50000<br>那么理论上需要的资源池大小是50000 / 1000 = 50个，实际maxTotal可以根据理论值进行微调。</p><p>(3) Jedis连接还的太慢</p><p>例如Redis发生了阻塞(例如慢查询等原因)，所有连接在超时时间范围内等待，并发量较大时，会造成连接池资源不足。</p><p>(4) 其他问题</p><p>例如丢包、DNS、客户端TCP参数配置，具体可以参考：Jedis介绍及常见问题分析</p><p>合理的JedisPool资源池参数设置能为业务使用Redis保驾护航，本文将对JedisPool的使用、资源池的参数进行详细说明，最后给出“最合理”配置。<br>参数说明</p><h2 id="1-2-资源设置和使用"><a href="#1-2-资源设置和使用" class="headerlink" title="1.2. 资源设置和使用"></a>1.2. 资源设置和使用</h2><table><thead><tr><th>序号</th><th style="text-align:center">参数名</th><th style="text-align:right">含义</th><th style="text-align:right">默认值</th><th style="text-align:right">使用建议</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">maxTotal</td><td style="text-align:right">资源池中最大连接数</td><td style="text-align:right">8</td><td style="text-align:right">设置建议见下节</td></tr><tr><td>2</td><td style="text-align:center">maxIdle</td><td style="text-align:right">资源池允许最大空闲的连接数</td><td style="text-align:right">8</td><td style="text-align:right">设置建议见下节</td></tr><tr><td>3</td><td style="text-align:center">minIdle</td><td style="text-align:right">资源池确保最少空闲的连接数</td><td style="text-align:right">0</td><td style="text-align:right">设置建议见下节</td></tr><tr><td>4</td><td style="text-align:center">blockWhenExhausted</td><td style="text-align:right">当资源池用尽后，调用者是否要等待。只有当为true时，下面的maxWaitMillis才会生效</td><td style="text-align:right">true</td><td style="text-align:right">建议使用默认值</td></tr><tr><td>5</td><td style="text-align:center">maxWaitMillis</td><td style="text-align:right">当资源池连接用尽后，调用者的最大等待时间(单位为毫秒)</td><td style="text-align:right">-1：表示永不超时</td><td style="text-align:right">不建议使用默认值</td></tr><tr><td>6</td><td style="text-align:center">testOnBorrow</td><td style="text-align:right">向资源池借用连接时是否做连接有效性检测(ping)，无效连接会被移除</td><td style="text-align:right">false</td><td style="text-align:right">业务量很大时候建议设置为false(多一次ping的开销)。</td></tr><tr><td>7</td><td style="text-align:center">testOnReturn</td><td style="text-align:right">向资源池归还连接时是否做连接有效性检测(ping)，无效连接会被移除</td><td style="text-align:right">false</td><td style="text-align:right">业务量很大时候建议设置为false(多一次ping的开销)。</td></tr><tr><td>8</td><td style="text-align:center">jmxEnabled</td><td style="text-align:right">是否开启jmx监控，可用于监控</td><td style="text-align:right">true</td><td style="text-align:right">建议开启，但应用本身也要开启</td></tr></tbody></table><h2 id="1-3-空闲资源监测"><a href="#1-3-空闲资源监测" class="headerlink" title="1.3. 空闲资源监测"></a>1.3. 空闲资源监测</h2><p>空闲Jedis对象检测，下面四个参数组合来完成，testWhileIdle是该功能的开关。</p><table><thead><tr><th>序号</th><th style="text-align:center">参数名</th><th style="text-align:right">含义</th><th style="text-align:right">默认值</th><th style="text-align:right">使用建议</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">testWhileIdle</td><td style="text-align:right">是否开启空闲资源监测</td><td style="text-align:right">false</td><td style="text-align:right">true</td></tr><tr><td>2</td><td style="text-align:center">timeBetweenEvictionRunsMillis</td><td style="text-align:right">空闲资源的检测周期(单位为毫秒)</td><td style="text-align:right">-1：不检测</td><td style="text-align:right">建议设置，周期自行选择，也可以默认也可以使用下面JedisPoolConfig中的配置</td></tr><tr><td>3</td><td style="text-align:center">minEvictableIdleTimeMillis</td><td style="text-align:right">资源池中资源最小空闲时间(单位为毫秒)，达到此值后空闲资源将被移除</td><td style="text-align:right">1000 60 30 = 30分钟</td><td style="text-align:right">可根据自身业务决定，大部分默认值即可，也可以考虑使用下面JeidsPoolConfig中的配置</td></tr><tr><td>4</td><td style="text-align:center">numTestsPerEvictionRun</td><td style="text-align:right">做空闲资源检测时，每次的采样数</td><td style="text-align:right">3</td><td style="text-align:right">可根据自身应用连接数进行微调,如果设置为-1，就是对所有连接做空闲监测</td></tr></tbody></table><p>所有默认值可以从org.apache.commons.pool2.impl.BaseObjectPoolConfig中看到。</p><h1 id="1-4-资源池大小-maxTotal-、空闲-maxIdle-minIdle-设置建议"><a href="#1-4-资源池大小-maxTotal-、空闲-maxIdle-minIdle-设置建议" class="headerlink" title="1.4. 资源池大小(maxTotal)、空闲(maxIdle minIdle)设置建议"></a>1.4. 资源池大小(maxTotal)、空闲(maxIdle minIdle)设置建议</h1><ul><li>1.maxTotal：最大连接数</li></ul><p>业务希望Redis并发量<br>客户端执行命令时间<br>Redis资源：例如 nodes(例如应用个数) * maxTotal 是不能超过redis的最大连接数。<br>资源开销：例如虽然希望控制空闲连接，但是不希望因为连接池的频繁释放创建连接造成不必靠开销。<br>以一个例子说明，假设:</p><p>一次命令时间（borrow|return resource + Jedis执行命令(含网络) ）的平均耗时约为1ms，一个连接的QPS大约是1000<br>业务期望的QPS是50000<br>那么理论上需要的资源池大小是50000 / 1000 = 50个。但事实上这是个理论值，还要考虑到要比理论值预留一些资源，通常来讲maxTotal可以比理论值大一些。</p><p>但这个值不是越大越好，一方面连接太多占用客户端和服务端资源，另一方面对于Redis这种高QPS的服务器，一个大命令的阻塞即使设置再大资源池仍然会无济于事。</p><ul><li><ol start="2"><li>maxIdle minIdle<br>maxIdle实际上才是业务需要的最大连接数，maxTotal是为了给出余量，所以maxIdle不要设置过小，否则会有new Jedis(新连接)开销，而minIdle是为了控制空闲资源监测。</li></ol></li></ul><p>连接池的最佳性能是maxTotal = maxIdle ,这样就避免连接池伸缩带来的性能干扰。但是如果并发量不大或者maxTotal设置过高，会导致不必要的连接资源浪费。<br>可以根据实际总OPS和调用redis客户端的规模整体评估每个节点所使用的连接池。</p><p>3.监控<br>实际上最靠谱的值是通过监控来得到“最佳值”的，可以考虑通过一些手段(例如jmx)实现监控，找到合理值。</p><p>部分内容来自</p><blockquote><ol><li><a href="https://yq.aliyun.com/articles/236383?spm=a2c4e.11153940.blogcont236384.31.42211516ycb8hK" target="_blank" rel="noopener">https://yq.aliyun.com/articles/236383?spm=a2c4e.11153940.blogcont236384.31.42211516ycb8hK</a></li></ol></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Jedis源码解读-JedisPool</title>
      <link href="/2018/12/09/Jedis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-JedisPool.html"/>
      <url>/2018/12/09/Jedis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-JedisPool.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是对象池"><a href="#1-什么是对象池" class="headerlink" title="1. 什么是对象池"></a>1. 什么是对象池</h1><p>对于一个对象，其生命周期大致可以分为 <code>创建 -&gt; 使用 -&gt; 销毁</code>三大阶段，这个对象的时间是 T1(创建)+T2(使用)+T3(销毁)，<br>对于创建N个对象都需要这个步骤的话，肯定很耗时并且消耗性能的。<br><a id="more"></a><br><strong> 官方对于对象池的解释是：</strong></p><blockquote><p>　将用过的对象保存起来,等下次需要这种对象的时候再拿出来重复使用,从而在一定程度上减少频繁创建对象所造成的开销,用于充当保存对象的”容器”对象,被称为”对象池”。</p></blockquote><h1 id="2-JedisPool的创建"><a href="#2-JedisPool的创建" class="headerlink" title="2. JedisPool的创建"></a>2. JedisPool的创建</h1><p>Jedis的连接池是基于apache.common.pool2,因此jedisPool的实现都是基于Pool2。<br>关于pool2的源码文档可以参考<br><a href="http://commons.apache.org/proper/commons-pool/" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-pool/</a></p><p><image src="/image/jedis/jedisPool.png"><br>JedisPool是Pool抽象类的子类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolAbstract</span> <span class="keyword">extends</span> <span class="title">Pool</span>&lt;<span class="title">Jedis</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></image></p><p>其中JedisPool构造函数最终都是调用了Pool#initPool的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> redis.clients.jedis.util;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> GenericObjectPool&lt;T&gt; internalPool;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">final</span> GenericObjectPoolConfig poolConfig, PooledObjectFactory&lt;T&gt; factory)</span> </span>&#123;</span><br><span class="line">    initPool(poolConfig, factory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.internalPool.isClosed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(<span class="keyword">final</span> GenericObjectPoolConfig poolConfig, PooledObjectFactory&lt;T&gt; factory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.internalPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        closeInternalPool();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # 实例化pool2中的GenericeObjectPool</span><br><span class="line">    <span class="keyword">this</span>.internalPool = <span class="keyword">new</span> GenericObjectPool&lt;T&gt;(factory, poolConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  # 从JedisPool获取Jedis和释放Jedis实例， </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      # 阅读源码位置 org.apache.commons.pool2.impl#borrowObject</span><br><span class="line">      <span class="keyword">return</span> internalPool.borrowObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException nse) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == nse.getCause()) &#123; <span class="comment">// The exception was caused by an exhausted pool</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JedisExhaustedPoolException(</span><br><span class="line">            <span class="string">"Could not get a resource since the pool is exhausted"</span>, nse);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Otherwise, the exception was caused by the implemented activateObject() or ValidateObject()</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JedisException(<span class="string">"Could not get a resource from the pool"</span>, nse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JedisConnectionException(<span class="string">"Could not get a resource from the pool"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnResourceObject</span><span class="params">(<span class="keyword">final</span> T resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      internalPool.returnObject(resource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JedisException(<span class="string">"Could not return the resource to the pool"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>initPool方法中有两个参数：一个GenericObjectPoolConfig配置项封装类，一个是 PooledObjectFactory工厂类获取到连接池后从连接池中获取jedis连接对象。<br>根据配置信息实例化pool2中的GenericeObjectPool这个对象池的管理者。</p><p>当调用 getResource 获取Jedis时， 实际上是Pool内部的internalPool调用borrowObject()拿到一个实例 ，而internalPool 这个 GenericObjectPool 又调用了 JedisFactory 的 makeObject() 来完成实例的生成 (在Pool中资源不够的时候)</p><h1 id="Jedis是如何实例化的"><a href="#Jedis是如何实例化的" class="headerlink" title="Jedis是如何实例化的"></a>Jedis是如何实例化的</h1><p>我们先看下JedisFactory的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JedisFactory</span> <span class="keyword">implements</span> <span class="title">PooledObjectFactory</span>&lt;<span class="title">Jedis</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PooledObject&lt;Jedis&gt; <span class="title">makeObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HostAndPort hostAndPort = <span class="keyword">this</span>.hostAndPort.get();</span><br><span class="line">    <span class="keyword">final</span> Jedis jedis = <span class="keyword">new</span> Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout,</span><br><span class="line">        soTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      jedis.connect();</span><br><span class="line">      <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (database != <span class="number">0</span>) &#123;</span><br><span class="line">        jedis.select(database);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (clientName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jedis.clientSetname(clientName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisException je) &#123;</span><br><span class="line">      jedis.close();</span><br><span class="line">      <span class="keyword">throw</span> je;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultPooledObject&lt;Jedis&gt;(jedis);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JedisFactory实现了pool2的PooledObjectFactory接口,池中对象创建和销毁的接口，交由业务方（就是文中的JedisFactory来实现）。<br>在JedisFactory#makeObject()方法中创建了Jedis对象。<br>Jedis继承自BinaryJedis，其有一个Client属性，Client是Connection的子类，Connection中有socket这个属性，也就是真正跟redis服务端创建连接的类，并且这个socket是个长连接。</p><p><image src="/image/jedis/jedis.png"><br><code>redis.clients.jedis.Connection#connect</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> Socket();</span><br><span class="line">        <span class="comment">// -&gt;@wjw_add</span></span><br><span class="line">        socket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        #建立长连接</span><br><span class="line">        socket.setKeepAlive(<span class="keyword">true</span>); <span class="comment">// Will monitor the TCP connection is</span></span><br><span class="line">        <span class="comment">// valid</span></span><br><span class="line">        socket.setTcpNoDelay(<span class="keyword">true</span>); <span class="comment">// Socket buffer Whetherclosed, to</span></span><br><span class="line">        <span class="comment">// ensure timely delivery of data</span></span><br><span class="line">        socket.setSoLinger(<span class="keyword">true</span>, <span class="number">0</span>); <span class="comment">// Control calls close () method,</span></span><br><span class="line">        <span class="comment">// the underlying socket is closed</span></span><br><span class="line">        <span class="comment">// immediately</span></span><br><span class="line">        <span class="comment">// &lt;-@wjw_add</span></span><br><span class="line"></span><br><span class="line">        socket.connect(<span class="keyword">new</span> InetSocketAddress(host, port), connectionTimeout);</span><br><span class="line">        socket.setSoTimeout(soTimeout);</span><br><span class="line">        ......</span><br><span class="line">        outputStream = <span class="keyword">new</span> RedisOutputStream(socket.getOutputStream());</span><br><span class="line">        inputStream = <span class="keyword">new</span> RedisInputStream(socket.getInputStream());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        broken = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JedisConnectionException(<span class="string">"Failed connecting to host "</span> </span><br><span class="line">            + host + <span class="string">":"</span> + port, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></image></p><p>  从上面的源码可以看到，Jedis和网络连接是一一绑定的，假如redis对象被GC了，那么它的client和socket连接一并销毁。</p><h1 id="客户端归还对象池"><a href="#客户端归还对象池" class="headerlink" title="客户端归还对象池"></a>客户端归还对象池</h1><p>  归还池的处理规则是由common-pool2来实现的，就是把jedis对象放到空闲队列中，如果队列满了，就将其直接销毁，销毁是在JedisFactory实现的<br>  <code>redis.clients.jedis.JedisFactory#destroyObject</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyObject</span><span class="params">(PooledObject&lt;Jedis&gt; pooledJedis)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> BinaryJedis jedis = pooledJedis.getObject();</span><br><span class="line">  <span class="keyword">if</span> (jedis.isConnected()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis.quit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      jedis.disconnect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  当主动关闭socket连接，在common-pool2中的GenericObjectPool也会把他从空闲池和总池中移除。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>kibana(6.2.4)集成sentinl报警</title>
      <link href="/2018/12/07/%E8%BF%90%E7%BB%B4/kibana-6-2-4-%E9%9B%86%E6%88%90sentinl%E6%8A%A5%E8%AD%A6.html"/>
      <url>/2018/12/07/%E8%BF%90%E7%BB%B4/kibana-6-2-4-%E9%9B%86%E6%88%90sentinl%E6%8A%A5%E8%AD%A6.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kibana_path/bin/kibana-plugin install https://github.com/sirensolutions/sentinl/releases/download/tag-6.2.4/sentinl-v6.2.4.zip</span><br></pre></td></tr></table></figure><p>安装完成之后，重启kibana。在kibana页面可以看到相关的菜单<br><img src="/image/elk/sentinl-dashborad.png"></p><h1 id="2-配置sentinl"><a href="#2-配置sentinl" class="headerlink" title="2. 配置sentinl"></a>2. 配置sentinl</h1><h2 id="2-1-配置邮箱"><a href="#2-1-配置邮箱" class="headerlink" title="2.1 配置邮箱"></a>2.1 配置邮箱</h2><p>在<code>kibana.yml</code>中配置邮箱参数：<br><a id="more"></a><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinl:</span></span><br><span class="line"><span class="attr">  settings:</span></span><br><span class="line"><span class="attr">    email:</span></span><br><span class="line"><span class="attr">      active:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      user:</span> <span class="string">xxx@xxx.com</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">      host:</span> <span class="string">smtp服务器</span></span><br><span class="line"><span class="attr">      ssl:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">      timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></p><p>配置完成之后重启服务</p><h2 id="2-2-配置页面数据"><a href="#2-2-配置页面数据" class="headerlink" title="2.2 配置页面数据"></a>2.2 配置页面数据</h2><p><img src="/image/elk/sentinl-new.png"><br>选择wizard或者advanced(最终都要转换成advanced，wizard更容易理解)  </p><p><img src="/image/elk/sentinl-watcher.png"><br>参考watcher数据如下:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"actions"</span>: &#123;</span><br><span class="line">    <span class="attr">"email_html_alarm_76b83c8f-0f4a-4db5-8a15-185933e17ca2"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"测试日志异常"</span>,</span><br><span class="line">      <span class="attr">"throttle_period"</span>: <span class="string">"2m"</span>,</span><br><span class="line">      <span class="attr">"email_html"</span>: &#123;</span><br><span class="line">        <span class="attr">"stateless"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"subject"</span>: <span class="string">"日志异常邮件测试"</span>,</span><br><span class="line">        <span class="attr">"priority"</span>: <span class="string">"medium"</span>,</span><br><span class="line">        <span class="attr">"html"</span>: <span class="string">"&lt;p&gt;Hi &#123;&#123;watcher.username&#125;&#125;&lt;/p&gt;\n&lt;p&gt;There are &#123;&#123;payload.hits.total&#125;&#125; results found by the watcher &lt;i&gt;&#123;&#123;watcher.title&#125;&#125;&lt;/i&gt;.&lt;/p&gt;\n\n&lt;div style=\"color:grey;\"&gt;\n  &lt;hr /&gt;\n  &lt;p&gt;This watcher sends alerts based on the following criteria:&lt;/p&gt;\n  &lt;ul&gt;&lt;li&gt;&#123;&#123;watcher.wizard.chart_query_params.queryType&#125;&#125; of &#123;&#123;watcher.wizard.chart_query_params.over.type&#125;&#125; over the last &#123;&#123;watcher.wizard.chart_query_params.last.n&#125;&#125; &#123;&#123;watcher.wizard.chart_query_params.last.unit&#125;&#125; &#123;&#123;watcher.wizard.chart_query_params.threshold.direction&#125;&#125; &#123;&#123;watcher.wizard.chart_query_params.threshold.n&#125;&#125; in index &#123;&#123;watcher.wizard.chart_query_params.index&#125;&#125;&lt;/li&gt;&lt;/ul&gt;\n&lt;/div&gt;\n\n&lt;div&gt;\n异常信息如下:\n&#123;&#123;#payload.hits.hits&#125;&#125; &#123;&#123;_source.message&#125;&#125; \n \n \n&#123;&#123;/payload.hits.hits&#125;&#125; \n&lt;/div&gt;"</span>,</span><br><span class="line">        <span class="attr">"to"</span>: <span class="string">"xxx@sina.cn"</span>,</span><br><span class="line">        <span class="attr">"from"</span>: <span class="string">"ddd@qq.com"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Webhook_f3303006-a643-42f6-a2ff-8d4066d18c3a"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"webhook告警"</span>,</span><br><span class="line">      <span class="attr">"throttle_period"</span>: <span class="string">"2m"</span>,</span><br><span class="line">      <span class="attr">"webhook"</span>: &#123;</span><br><span class="line">        <span class="attr">"priority"</span>: <span class="string">"medium"</span>,</span><br><span class="line">        <span class="attr">"stateless"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"POST"</span>,</span><br><span class="line">        <span class="attr">"host"</span>: <span class="string">"oapi.dingtalk.com"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="string">"443"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/robot/send?access_token=xxxx"</span>,</span><br><span class="line">        <span class="attr">"body"</span>: <span class="string">"&#123;\r\n    \"msgtype\": \"markdown\",\r\n    \"at\": &#123;\r\n        \"isAtAll\": \"True\"\r\n    &#125;,\r\n    \"markdown\": &#123;\r\n        \"title\": \"异常消息\",\r\n        \"text\": \" 异常日志: \\n &#123;&#123;#payload.hits.hits&#125;&#125; &#123;&#123;_source.message&#125;&#125; \r\n \r\n&#123;&#123;/payload.hits.hits&#125;&#125;\"\r\n    &#125;\r\n&#125;"</span>,</span><br><span class="line">        <span class="attr">"params"</span>: &#123;</span><br><span class="line">          <span class="attr">"watcher"</span>: <span class="string">"&#123;&#123;watcher.title&#125;&#125;"</span>,</span><br><span class="line">          <span class="attr">"payload_count"</span>: <span class="string">"&#123;&#123;payload.hits.total&#125;&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"headers"</span>: &#123;</span><br><span class="line">          <span class="attr">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"message"</span>: <span class="string">"生产环境异常"</span>,</span><br><span class="line">        <span class="attr">"use_https"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"input"</span>: &#123;</span><br><span class="line">    <span class="attr">"search"</span>: &#123;</span><br><span class="line">      <span class="attr">"request"</span>: &#123;</span><br><span class="line">        <span class="attr">"index"</span>: [</span><br><span class="line">          <span class="string">"xxx*"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"body"</span>: &#123;</span><br><span class="line">          <span class="attr">"query"</span>: &#123;</span><br><span class="line">            <span class="attr">"bool"</span>: &#123;</span><br><span class="line">              <span class="attr">"must"</span>: &#123;</span><br><span class="line">                <span class="attr">"match"</span>: &#123;</span><br><span class="line">                  <span class="attr">"message"</span>: <span class="string">"ERROR"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"range"</span>: &#123;</span><br><span class="line">                  <span class="attr">"@timestamp"</span>: &#123;</span><br><span class="line">                    <span class="attr">"gte"</span>: <span class="string">"now-15m/m"</span>,</span><br><span class="line">                    <span class="attr">"lte"</span>: <span class="string">"now/m"</span>,</span><br><span class="line">                    <span class="attr">"format"</span>: <span class="string">"epoch_millis"</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"dateAgg"</span>: &#123;</span><br><span class="line">              <span class="attr">"date_histogram"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"@timestamp"</span>,</span><br><span class="line">                <span class="attr">"time_zone"</span>: <span class="string">"Asia/Shanghai"</span>,</span><br><span class="line">                <span class="attr">"interval"</span>: <span class="string">"1m"</span>,</span><br><span class="line">                <span class="attr">"min_doc_count"</span>: <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"condition"</span>: &#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">      <span class="attr">"script"</span>: <span class="string">"payload.hits.total &gt;= 1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"trigger"</span>: &#123;</span><br><span class="line">    <span class="attr">"schedule"</span>: &#123;</span><br><span class="line">      <span class="attr">"later"</span>: <span class="string">"every 1 minutes"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"disable"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"report"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"测试告警"</span>,</span><br><span class="line">  <span class="attr">"wizard"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"save_payload"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"spy"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"impersonate"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如图选中开启日志报警<br><img src="/image/elk/sentinl-test.png"><br>也可以点击测试<br><img src="/image/elk/sentinl-test2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Logstash配置文件简述</title>
      <link href="/2018/12/07/%E8%BF%90%E7%BB%B4/Logstash%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E8%BF%B0.html"/>
      <url>/2018/12/07/%E8%BF%90%E7%BB%B4/Logstash%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E8%BF%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-logstash-conf文件结构及语法"><a href="#1-logstash-conf文件结构及语法" class="headerlink" title="1. logstash conf文件结构及语法"></a>1. logstash conf文件结构及语法</h1><h2 id="1-1-conf文件结构"><a href="#1-1-conf文件结构" class="headerlink" title="1.1 conf文件结构"></a>1.1 conf文件结构</h2><p>官方说明请参考<br><a href="https://www.elastic.co/guide/en/logstash/5.4/configuration-file-structure.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/5.4/configuration-file-structure.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-配置文件语法"><a href="#1-2-配置文件语法" class="headerlink" title="1.2 配置文件语法"></a>1.2 配置文件语法</h2><h3 id="1-2-1-基本语法"><a href="#1-2-1-基本语法" class="headerlink" title="1.2.1 基本语法"></a>1.2.1 基本语法</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数据类型</span><br><span class="line">boolen： 布尔 a =&gt; true</span><br><span class="line">Bytes： 字节 a =&gt; “10MiB”</span><br><span class="line">Strings：字符串 a =&gt; “hello world”</span><br><span class="line">Number： 数值 a =&gt; 1024</span><br><span class="line">Array： 数组 match =&gt; [“datatime”,“UNIX”,“ISO8601”]</span><br><span class="line">Hash： 哈希 options =&gt; &#123; key1 =&gt; “value1”,key2 =&gt; “value2” &#125;</span><br><span class="line">编码解码： codec: codec =&gt; “json”</span><br><span class="line">密码型： my_passwd =&gt; “password”</span><br><span class="line">路径： my_path =&gt; “/tmp/logstash”</span><br><span class="line">注释： #</span><br></pre></td></tr></table></figure><h3 id="1-2-2-条件判断"><a href="#1-2-2-条件判断" class="headerlink" title="1.2.2 条件判断"></a>1.2.2 条件判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">==,!= ,&lt; ,&gt; ,&lt;= ,&gt;=</span><br><span class="line">=~</span><br><span class="line">in,not in</span><br><span class="line">and ,or , nand, xor</span><br><span class="line">(), !()</span><br><span class="line">if expression &#123;</span><br><span class="line">&#125; else if expression &#123;</span><br><span class="line">…</span><br><span class="line">&#125; else &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-字段引用"><a href="#1-2-3-字段引用" class="headerlink" title="1.2.3 字段引用"></a>1.2.3 字段引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%&#123;[response][status]&#125;</span><br><span class="line">%&#123;[@metadata][kafka][topic]&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-各部分配置详解"><a href="#2-各部分配置详解" class="headerlink" title="2. 各部分配置详解"></a>2. 各部分配置详解</h1><h2 id="2-1-input"><a href="#2-1-input" class="headerlink" title="2.1 input"></a>2.1 input</h2><p>官方input插件列表<br><a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/input-plugins.html</a><br>具体配置参考官方说明，这部分比较简单，我们就用kafka插件举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  # https://www.elastic.co/guide/en/logstash/6.2/plugins-inputs-kafka.html</span><br><span class="line">  kafka &#123;</span><br><span class="line">     #kafka Server</span><br><span class="line">     bootstrap_servers =&gt; &quot;xxx:9092&quot;</span><br><span class="line">    #topic id</span><br><span class="line">    topics =&gt; [&quot;xxx_tomcat&quot;,&quot;xx2&quot;]</span><br><span class="line">    # 这里group_id (默认为logstash)需要解释一下，在Kafka中，相同group的Consumer可以同时消费一个topic，不同group的Consumer工作则互不干扰。</span><br><span class="line">    # 补充: 在同一个topic中的同一个partition同时只能由一个Consumer消费，当同一个topic同时需要有多个Consumer消费时，则可以创建更多的partition。</span><br><span class="line">    group_id =&gt; &quot;xxx&quot;</span><br><span class="line">    # 当input里面有多个kafka输入源时，client_id =&gt; &quot;es*&quot;必须添加且需要不同，</span><br><span class="line">    # 否则会报错javax.management.InstanceAlreadyExistsException: kafka.consumer:type=app-info,id=logstash-0。</span><br><span class="line">    client_id =&gt; &quot;xxx&quot;</span><br><span class="line">    #https://blog.csdn.net/nyyjs/article/details/72771905</span><br><span class="line">    consumer_threads =&gt; 2</span><br><span class="line">    decorate_events =&gt; true</span><br><span class="line">    codec =&gt; json &#123;</span><br><span class="line">            charset =&gt; &quot;UTF-8&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    auto_offset_reset =&gt; &quot;latest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-filter"><a href="#2-2-filter" class="headerlink" title="2.2 filter"></a>2.2 filter</h2><p>官方filter插件列表<br><a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/filter-plugins.html</a><br>这部分是logstash最复杂的一个地方，也是logstash解析日志最核心的地方<br>一般我们常用的插件有  </p><ul><li>date 日期相关</li><li>geoip 解析地理位置相关</li><li>mutate 对指定字段的增删改</li><li>grok 将message中的数据解析成es中存储的字段  </li></ul><p>其中grok和mutate是用的最多的地方，这块大家可以多看下官方的文档。<br>下面用一个filebeat -&gt; kafka的数据来演示用法<br>其中grok的官方正则参考地址如下：<br><a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns" target="_blank" rel="noopener">https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">      #xxx_tomcat是topic名字</span><br><span class="line"> if &quot;xxx_tomcat&quot; ==  [@metadata][kafka][topic] &#123;</span><br><span class="line">      grok&#123;</span><br><span class="line">      #指定自定义正则文件地址，如果使用官方的正则，不需要配置这个</span><br><span class="line">          patterns_dir =&gt; &quot;/data/elk/logstash-6.2.4/patterns&quot;</span><br><span class="line">          match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;TOMCAT_xxx&#125;&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      date &#123;</span><br><span class="line">          match =&gt; [&quot;logDate&quot;, &quot;yyyy-MM-dd;HH:mm:ss.SSS&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">      mutate &#123;</span><br><span class="line">        remove_field =&gt; [&quot;logDate&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> #修改field</span><br><span class="line">     mutate &#123;</span><br><span class="line">        rename =&gt; &#123;&quot;[beat][name]&quot;=&gt;&quot;serverName&quot;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    # 删除无用字段 这些字段kafka和filebeat</span><br><span class="line">    # 不能移除 type字段，否则会导致不能自动生成索引</span><br><span class="line">    mutate &#123;</span><br><span class="line">    remove_field =&gt; [&quot;_score&quot;,&quot;_id&quot;, &quot;@version&quot; , &quot;_type&quot; , &quot;offset&quot; ,  </span><br><span class="line">                      &quot;version&quot;,&quot;id&quot; , &quot;score&quot;, &quot;tags&quot;, &quot;source&quot;,&quot;sort&quot;,</span><br><span class="line">                      &quot;prospector&quot;,&quot;[beat][version]&quot;,&quot;[beat][hostname]&quot;,&quot;_score&quot;,&quot;fields&quot; ]</span><br><span class="line">    # remove_field =&gt; &quot;type&quot;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-output"><a href="#2-2-output" class="headerlink" title="2.2 output"></a>2.2 output</h2><p>官方filter插件列表<br><a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/output-plugins.html</a><br>这块也是比较简单的，按照插件的解释就可以配置成功，下面我们以ES为例来看下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line">  if &quot;xxx_tomcat&quot; ==  [@metadata][kafka][topic]  &#123;</span><br><span class="line">      elasticsearch&#123;</span><br><span class="line">        hosts =&gt; [&quot;xxx:9200&quot;]</span><br><span class="line">        index =&gt; &quot;%&#123;[@metadata][kafka][topic]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">#如果配置了elasticsearch认证的话需要配置下面的user和password，否则不需要。</span><br><span class="line">        user =&gt; &quot;xxx&quot;</span><br><span class="line">        password =&gt; &quot;xxxx&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  #输出日志到控制台，会输出具体的es数据内容，调试完成后建议去掉。</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-启动加载配置文件"><a href="#3-启动加载配置文件" class="headerlink" title="3. 启动加载配置文件"></a>3. 启动加载配置文件</h1><p>启动的时候可以指定文件或者文件目录下的所有 <code>.conf</code>文件。</p><h1 id="3-1-加载具体配置文件："><a href="#3-1-加载具体配置文件：" class="headerlink" title="3.1 加载具体配置文件："></a>3.1 加载具体配置文件：</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f config/<span class="built_in">test</span>-kafka.conf</span><br></pre></td></tr></table></figure><h1 id="3-2-加载配置文件目录："><a href="#3-2-加载配置文件目录：" class="headerlink" title="3.2 加载配置文件目录："></a>3.2 加载配置文件目录：</h1><p>假设配置文件都在 config/config.d<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f config/config.d</span><br></pre></td></tr></table></figure></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>logstash配置文件的难点就是grok这块，建议在使用的时候多看下官方相关的文档。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal的使用及原理分析</title>
      <link href="/2018/12/05/ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"/>
      <url>/2018/12/05/ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是ThreadLocal？"><a href="#1-什么是ThreadLocal？" class="headerlink" title="1. 什么是ThreadLocal？"></a>1. 什么是ThreadLocal？</h1><p>ThreadLocal称作线程本地存储。简单来说，就是ThreadLocal为共享变量在每个线程中都创建一个副本，每个线程可以访问自己内部的副本变量。这样做的好处是可以保证共享变量在<code>多线程环境下访问的线程安全性</code>。</p><h1 id="2-ThreadLocal的使用"><a href="#2-ThreadLocal的使用" class="headerlink" title="2. ThreadLocal的使用"></a>2. ThreadLocal的使用</h1><p>引题：<br>在没有使用ThreadLocal的时候，定义了一个静态的成员变量num，然后通过构造5个线程对这个num做递增<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread[] threads=<span class="keyword">new</span> Thread[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        threads[i]=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           num+=<span class="number">5</span>;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+num);</span><br><span class="line">        &#125;,<span class="string">"Thread-"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread thread:threads)&#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行这个方法之后，你会发现每次的运行结果都是不一样的。</p><p>使用了ThreadLocal以后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; local=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//通过initialValue方法设置默认值</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Thread[] threads=<span class="keyword">new</span> Thread[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">          threads[i]=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              <span class="keyword">int</span> num=local.get().intValue();</span><br><span class="line">              num+=<span class="number">5</span>;</span><br><span class="line">             System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+num);</span><br><span class="line">          &#125;,<span class="string">"Thread-"</span>+i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Thread thread:threads)&#123;</span><br><span class="line">          thread.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>从结果可以看到，每个线程的值都是5，意味着各个线程之间都是独立的变量副本，彼此不相互影响.</p><blockquote><p>ThreadLocal会给定一个初始值，也就是initialValue()方法，而每个线程都会从ThreadLocal中获得这个初始化的值的副本，这样可以使得每个线程都拥有一个副本拷贝。  </p></blockquote><p>从ThreadLocal的方法定义来看，就几个方法</p><ul><li>get: 获取ThreadLocal中当前线程对应的线程局部变量</li><li>set：设置当前线程的线程局部变量的值</li><li>remove：将当前线程局部变量的值删除  </li><li>initialValue 返回当前线程局部变量的初始值<br><img src="/image/java/threadLocal.png"><blockquote><p>源码基于JDK 1.8   </p></blockquote></li></ul><p>get方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当前执行的线程</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获得当前线程的ThreadLocalMap实例</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="comment">// 如果map不为空，说明当前线程已经有了一个ThreadLocalMap实例</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    # 获取Entry</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment">    * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       T value = initialValue();</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果map不为null,把初始化value设置进去</span></span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">//如果map为null,则new一个map,并把初始化value设置进去</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>set方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t); </span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 直接将当前value设置到ThreadLocalMap中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 说明当前线程是第一次使用线程本地变量，构造map</span></span><br><span class="line">            createMap(t, value); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>从上面方法中，我们可以注意到有一个叫做ThreadLocalMap 的对象，它是做什么的呢？</p><p>ThreadLocalMap是一个静态内部类，内部定义了一个Entry对象用来真正存储数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            <span class="comment">//构造一个Entry数组，并设置初始大小</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">//计算Entry数据下标</span></span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将`firstValue`存入到指定的table下标中</span></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;<span class="comment">//设置节点长度为1</span></span><br><span class="line">            setThreshold(INITIAL_CAPACITY); <span class="comment">//设置扩容的阈值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过以上的代码我们又发现了新的大陆：</p><ul><li>Entry继承了WeakReference,这个表示什么意思?</li><li>在构造ThreadLocalMap的时候new ThreadLocalMap(this, firstValue);<br>key其实是this，this表示当前对象的引用，在当前的案例中，this指的是ThreadLocal<integer> local。那么多个线程对应同一个ThreadLocal实例，怎么对每一个ThreadLocal对象做区分呢？</integer></li></ul><p>weakReference表示弱引用，在Java中有四种引用类型，强引用、弱引用、软引用、虚引用。<br>使用弱引用的对象，不会阻止它所指向的对象被垃圾回收器回收。<br>对于下面的示例代码我们分析下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DemoA a=<span class="keyword">new</span> DemoA();</span><br><span class="line">DemoB b=<span class="keyword">new</span> DemoB(a);</span><br><span class="line">a=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>看似很正常的一段代码，但是将a对象的引用设置为null，当一个对象不再被其他对象引用的时候，是会被GC回收的，但是对于这个场景来说，即时是a=null，也不可能被回收，因为DemoB依赖DemoA，这个时候是可能造成内存泄漏的</p><p>接着看下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">DemoA a=<span class="keyword">new</span> DemoA();</span><br><span class="line">DemoB b=<span class="keyword">new</span> DemoB(a);</span><br><span class="line">a=<span class="keyword">null</span>;</span><br><span class="line">b=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">DemoA a=<span class="keyword">new</span> DemoA();</span><br><span class="line">WeakReference b=<span class="keyword">new</span> WeakReference(a);</span><br><span class="line">a=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>对于方法2来说，DemoA只是被弱引用依赖，假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后把这个弱可达对象标记为可终结(finalizable)的，这样它随后就会被回收。</p><blockquote><p>试想一下如果这里没有使用弱引用，意味着ThreadLocal的生命周期和线程是强绑定，只要线程没有销毁，那么ThreadLocal一直无法回收。而使用弱引用以后，当ThreadLocal被回收时，由于Entry的key是弱引用，不会影响ThreadLocal的回收防止内存泄漏，同时，在后续的源码分析中会看到，ThreadLocalMap本身的垃圾清理会用到这一个好处，方便对无效的Entry进行回收</p></blockquote><p>ThreadLocalMap以this作为key<br>在构造ThreadLocalMap时，使用this作为key来存储，那么对于同一个ThreadLocal对象，如果同一个Thread中存储了多个值，是如何来区分存储的呢？<br>答案就在firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)<br>我们看下相关的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment"> * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment"> * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">     table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">     <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">     table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">     size = <span class="number">1</span>;</span><br><span class="line">     setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键点就在threadLocalHashCode，它相当于一个ThreadLocal的ID，实现的逻辑如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里用到了一个非常完美的散列算法，可以简单理解为，对于同一个ThreadLocal下的多个线程来说，当任意线程调用set方法存入一个数据到Entry中的时候，其实会根据threadLocalHashCode生成一个唯一的id标识对应这个数据，存储在Entry数据下标中。</p><ul><li>threadLocalHashCode是通过nextHashCode.getAndAdd(HASH_INCREMENT)来实现的  </li></ul><p>i*HASH_INCREMENT+HASH_INCREMENT,每次新增一个元素(ThreadLocal)到Entry[],都会自增0x61c88647,目的为了让哈希码能均匀的分布在2的N次方的数组里</p><ul><li>Entry[i]= hashCode &amp; (length-1)  </li></ul><h1 id="0x61c88647"><a href="#0x61c88647" class="headerlink" title="0x61c88647"></a>0x61c88647</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        magicHash(<span class="number">16</span>); <span class="comment">//初始大小16</span></span><br><span class="line">        magicHash(<span class="number">32</span>); <span class="comment">//扩容一倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">magicHash</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            hashCode = i*HASH_INCREMENT+HASH_INCREMENT;</span><br><span class="line">            System.out.print((hashCode &amp; (size-<span class="number">1</span>))+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>观察运行的结果找规律</p><p>魔数0x61c88647的选取和斐波那契散列有关，0x61c88647对应的十进制为1640531527。而斐波那契散列的乘数可以用(long) ((1L &lt;&lt; 31) <em> (Math.sqrt(5) - 1)); 如果把这个值给转为带符号的int，则会得到-1640531527。也就是说<br>(long) ((1L &lt;&lt; 31) </em> (Math.sqrt(5) - 1));得到的结果就是1640531527，也就是魔数0x61c88647</p><blockquote><p>总结，我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀。 </p></blockquote><h2 id="ThreadLocalMap-set-key-value"><a href="#ThreadLocalMap-set-key-value" class="headerlink" title="ThreadLocalMap.set(key,value)"></a>ThreadLocalMap.set(key,value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="comment">// 根据哈希码和数组长度求元素放置的位置，即数组下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">             <span class="comment">//从i开始往后一直遍历到数组最后一个Entry(线性探索)</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                 <span class="comment">//如果key相等，覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//如果key为null,用新key、value覆盖，同时清理历史key=null的陈旧数据</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">             <span class="comment">//如果超过阀值，就需要扩容了</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>为了更直观的体现set方法的实现，通过一个图形表示如下<br><img src="/image/java/threadlocal2.png"></p><h1 id="ThreadLocal的内存泄漏"><a href="#ThreadLocal的内存泄漏" class="headerlink" title="ThreadLocal的内存泄漏"></a>ThreadLocal的内存泄漏</h1><p>ThreadLocalMap中Entry的key使用的是ThreadLocal的弱引用，如果一个ThreadLocal没有外部强引用，当系统执行GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现一个key为null的Entry，而这个key=null的Entry是无法访问的，当这个线程一直没有结束的话，那么就会存在一条强引用链</p><p>Thread Ref - &gt; Thread -&gt; ThreadLocalMap - &gt; Entry -&gt; value 永远无法回收而造成内存泄漏<br><img src="/image/java/threadlocal3.png"></p><blockquote><p>其实我们从源码分析可以看到，ThreadLocalMap是做了防护措施的</p><ul><li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e</li><li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询  </li></ul></blockquote><p>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。<br>但是这个设计一来与一个前提条件，就是调用get或者set方法，但是不是所有场景都会满足这个场景的，所以为了避免这类的问题，我们可以在合适的位置手动调用ThreadLocal的remove函数删除不需要的ThreadLocal，防止出现内存泄漏</p><p>所以建议的使用方法是</p><ul><li>将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露</li><li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> threadlocal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅入Java ClassLoader</title>
      <link href="/2018/12/05/java/%E6%B5%85%E5%85%A5Java-ClassLoader.html"/>
      <url>/2018/12/05/java/%E6%B5%85%E5%85%A5Java-ClassLoader.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-ClassLoader是做什么的？"><a href="#1-ClassLoader是做什么的？" class="headerlink" title="1. ClassLoader是做什么的？"></a>1. ClassLoader是做什么的？</h1><p>ClassLoader是用来加载Class 文件的。它负责将 Class 的字节码形式转换成内存形式的 Class 对象。字节码可以来自于磁盘文件 <em>.class，也可以是 jar 包里的 </em>.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组 []byte，它有特定的复杂的内部格式。<br><img src="/image/jvm/byteArr2Class.png"></p><h1 id="2-ClassLoader的特点"><a href="#2-ClassLoader的特点" class="headerlink" title="2.ClassLoader的特点"></a>2.ClassLoader的特点</h1><a id="more"></a><h2 id="2-1-延迟加载"><a href="#2-1-延迟加载" class="headerlink" title="2.1 延迟加载"></a>2.1 延迟加载</h2><p>JVM 运行的时候不是一次性把所有的类全部加载进来，它是按需加载（延迟加载）。程序在运行的时候会遇到一些新的类，在这个时候程序就会调用Classloader来加载这些类。加载完成将Class对象存放在Classloader中，下次再遇到这些类的时候就不需要重新加载进来了。</p><h2 id="2-2-各司其职"><a href="#2-2-各司其职" class="headerlink" title="2.2 各司其职"></a>2.2 各司其职</h2><p>JVM 中内置三个重要的 ClassLoader:</p><ul><li>BootstrapClassLoader</li><li>ExtensionClassLoader</li><li>AppClassLoader。  </li></ul><p>JVM 运行实例中会存在多个 ClassLoader，不同的 ClassLoader 会从不同的地方加载字节码文件。它可以从不同的文件目录加载，也可以从不同的 jar 文件中加载，也可以从网络上不同的静态文件服务器来下载字节码再加载。   </p><h2 id="2-2-1-BootstrapClassLoader"><a href="#2-2-1-BootstrapClassLoader" class="headerlink" title="2.2.1 BootstrapClassLoader"></a>2.2.1 BootstrapClassLoader</h2><p>负责加载 JVM 运行时核心类，这些类位于 $JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.xxx.* 都在里面，比如 java.util.、java.io.、java.nio.、java.lang. 等等。这个 ClassLoader 比较特殊，它是由 C 代码实现的，我们将它称之为「根加载器」。</p><h2 id="2-2-2-ExtensionClassLoader"><a href="#2-2-2-ExtensionClassLoader" class="headerlink" title="2.2.2 ExtensionClassLoader"></a>2.2.2 ExtensionClassLoader</h2><p>负责加载 JVM 扩展类，比如 swing 系列、内置的 js 引擎、xml 解析器 等等，这些库名通常以 javax 开头，它们的 jar 包位于 $JAVA_HOME/lib/ext/*.jar 中，有很多 jar 包。</p><h2 id="2-2-3-AppClassLoader"><a href="#2-2-3-AppClassLoader" class="headerlink" title="2.2.3 AppClassLoader"></a>2.2.3 AppClassLoader</h2><p>才是直接面向用户的加载器，它会加载 Classpath 环境变量里定义的路径中的 jar 包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。</p><ul><li>ClassLoader.getSystemClassLoader()<br>AppClassLoader 可以由 ClassLoader 类提供的静态方法 getSystemClassLoader() 得到，它就是我们所说的<code>系统类加载器</code>，我们用户平时编写的类代码通常都是由它加载的。当我们的 main 方法执行的时候，这第一个用户类的加载器就是 AppClassLoader。</li></ul><h2 id="2-2-4-URLClassLoader"><a href="#2-2-4-URLClassLoader" class="headerlink" title="2.2.4 URLClassLoader"></a>2.2.4 URLClassLoader</h2><p>jdk 内置了一个 URLClassLoader，对于网络上静态文件服务器提供的 jar 包和 .class文件，用户只需要传递规范的网络路径给构造器，就可以使用  URLClassLoader 来加载远程类库了。URLClassLoader 不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader 和 AppClassLoader 都是 URLClassLoader 的子类，它们都是从本地文件系统里加载类库。<br><img src="/image/jvm/URLClassLoader.png">  </p><ul><li>几种Classloader的配置参数  </li></ul><table><thead><tr><th>Class Loader类型</th><th>参数选项</th><th>说明</th></tr></thead><tbody><tr><td></td><td>-Xbootclasspath:</td><td>设置引导类加载器的搜索路径</td></tr><tr><td>BootstrapClassLoader</td><td>-Xbootclasspath/a:</td><td>把路径添加到已存在的搜索路径的后面</td></tr><tr><td></td><td>-Xbootclasspath/p:</td><td>把路径添加到已存在的搜索路径的前面</td></tr><tr><td>ExtClassLoader</td><td>-Djava.ext.dirs</td><td>设置ExtClassLoader的搜索路径</td></tr><tr><td>AppClassLoader</td><td>-Djava.class.path= 或-classpath</td><td>设置AppClassLoader的搜索路径</td></tr></tbody></table><h1 id="2-3-传递性"><a href="#2-3-传递性" class="headerlink" title="2.3 传递性"></a>2.3 传递性</h1><p>程序在运行过程中，遇到了一个未知的类，它会选择哪个 ClassLoader 来加载它呢？<br>虚拟机的策略是使用调用者 Class 对象的 ClassLoader 来加载当前未知的类。<br>何为调用者 Class 对象？<br>就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者 Class 对象。前面我们提到每个 Class 对象里面都有一个 classLoader 属性记录了当前的类是由谁来加载的。<br>因为 ClassLoader 的传递性，所有延迟加载的类都会由初始调用 main 方法的这个 ClassLoader 全全负责，它就是 AppClassLoader。</p><h1 id="2-4-双亲委派"><a href="#2-4-双亲委派" class="headerlink" title="2.4 双亲委派"></a>2.4 双亲委派</h1><p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有所需的类)时,子加载器才会自己尝试加载.Java类随着它的类加载器一起具备了一种带有优先级的层次关系。<br>前面我们提到 AppClassLoader 只负责加载 Classpath 下面的类库，如果遇到没有加载的系统类库怎么办，AppClassLoader 必须将系统类库的加载工作交给 BootstrapClassLoader 和 ExtensionClassLoader 来做，这就是我们常说的「双亲委派」。<br><img src="/image/jvm/shuangqin.png"></p><ul><li>双亲委托模型的实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass ( String name , <span class="keyword">boolean</span> resolve ) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//检查指定类是否被当前类加载器加载过</span></span><br><span class="line">        Class clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span>( clazz == <span class="keyword">null</span> )&#123;<span class="comment">//如果没被加载过，委派给父加载器加载</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( parent != <span class="keyword">null</span> )</span><br><span class="line">                    clazz = parent.loadClass(name,resolve);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                   clazz = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;<span class="keyword">catch</span> ( ClassNotFoundException e )&#123;</span><br><span class="line">                <span class="comment">//如果父加载器无法加载</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( clazz == <span class="keyword">null</span> )&#123;<span class="comment">//父类不能加载，由当前的类加载器加载</span></span><br><span class="line">                clazz = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( resolve )&#123;<span class="comment">//如果要求立即链接，那么加载完类直接链接</span></span><br><span class="line">            resolveClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将加载过这个类对象直接返回</span></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-5-Class-forName"><a href="#2-5-Class-forName" class="headerlink" title="2.5 Class.forName"></a>2.5 Class.forName</h1><p>forName 方法同样也是使用调用者 Class 对象的 ClassLoader 来加载目标类。不过 forName 还提供了多参数版本，可以指定使用哪个 ClassLoader 来加载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize, ClassLoader cl)</span><br></pre></td></tr></table></figure></p><p>通过这种形式的 forName 方法可以突破内置加载器的限制，通过使用自定类加载器允许我们自由加载其它任意来源的类库。根据 ClassLoader 的传递性，目标类库传递引用到的其它类库也将会使用自定义加载器加载。</p><h1 id="2-6-自定义加载器"><a href="#2-6-自定义加载器" class="headerlink" title="2.6 自定义加载器"></a>2.6 自定义加载器</h1><p>ClassLoader 里面有三个重要的方法 loadClass()、findClass() 和 defineClass()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将byte字节流解析成JVM能够识别的Class对象，有了这个方法一位着我们</span></span><br><span class="line"><span class="comment">//不仅可以通过Class文件获得Class对象，其他的字节流都可以</span></span><br><span class="line">Class&lt;?&gt; defineClass ( <span class="keyword">byte</span>[] , <span class="keyword">int</span> , <span class="keyword">int</span> )</span><br><span class="line"><span class="comment">//实现类的加载规则，从而取得要加载类的字节码</span></span><br><span class="line">Class&lt;?&gt; findClass(String)</span><br><span class="line"><span class="comment">//如果不想重新定义加载类额规则，也没有复杂的处理逻辑</span></span><br><span class="line"><span class="comment">//只是想能够一个加载一个自己指定的类，可以直接使用load</span></span><br><span class="line">Class&lt;?&gt; loadClass(String)</span><br><span class="line"><span class="comment">//链接参数类，链接参照上面，不再赘述</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt;)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>loadClass()<br>该方法是加载目标类的入口，它首先会查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类。ClassLoader 的 findClass() 方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载入口，定义了双亲委派规则</span></span><br><span class="line">  <span class="function">Class <span class="title">loadClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否已经加载了</span></span><br><span class="line">    Class t = <span class="keyword">this</span>.findFromLoaded(name);</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 交给双亲</span></span><br><span class="line">      t = <span class="keyword">this</span>.parent.loadClass(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 双亲都不行，只能靠自己了</span></span><br><span class="line">      t = <span class="keyword">this</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 交给子类自己去实现</span></span><br><span class="line">  <span class="function">Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> ClassNotFoundException();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 组装Class对象</span></span><br><span class="line">  <span class="function">Class <span class="title">defineClass</span><span class="params">(<span class="keyword">byte</span>[] code, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildClassFromCode(code, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找字节码</span></span><br><span class="line">    <span class="keyword">byte</span>[] code = findCodeFromSomewhere(name);</span><br><span class="line">    <span class="comment">// 组装Class对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(code, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-6-Class-forName-vs-ClassLoader-loadClass"><a href="#2-6-Class-forName-vs-ClassLoader-loadClass" class="headerlink" title="2.6 Class.forName vs ClassLoader.loadClass"></a>2.6 Class.forName vs ClassLoader.loadClass</h1><p>这两个方法都可以用来加载目标类，它们之间有一个小小的区别，那就是 Class.forName() 方法可以获取原生类型的 Class，而 ClassLoader.loadClass() 则会报错。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> classloader </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CMS学习笔记</title>
      <link href="/2018/12/04/java/CMS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/2018/12/04/java/CMS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-什么是cms及cms的适用场景"><a href="#一-什么是cms及cms的适用场景" class="headerlink" title="一. 什么是cms及cms的适用场景"></a>一. 什么是cms及cms的适用场景</h1><ol><li>CMS ：Mostly-Concurrent收集器，也称并发标记清除收集器（Concurrent Mark-Sweep GC，CMS收集器），它管理新生代的方式与Parallel收集器和Serial收集器相同，而在老年代则是尽可能得并发执行，每个垃圾收集器周期只有2次短停顿。</li><li>CMS的目的： 为了消除Throught收集器和Serial收集器在Full GC周期中的<code>长时间停顿</code>。</li><li>CMS的使用场景：应用需要更快速的响应，不想长时间的停顿，前提条件是你的CPU资源比较丰富的条件下，适合使用CMS收集器。对于实时响应的任务，比如web server类似。<a id="more"></a><h1 id="二-CMS的过程"><a href="#二-CMS的过程" class="headerlink" title="二. CMS的过程"></a>二. CMS的过程</h1></li></ol><ul><li>初始标记(STW initial mark) </li><li>并发标记(Concurrent marking) </li><li>并发预清理(Concurrent precleaning) </li><li>重新标记(STW remark) </li><li>并发清理(Concurrent sweeping) </li><li>并发重置(Concurrent reset)  </li></ul><ol><li><p>初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。<br><img src="/image/cms/stw.png"></p></li><li><p>并发标记：由上一个阶段标记过的对象，开始tracing过程，标记所有可达的对象，这个阶段垃圾回收线程和应用线程同时运行，如上图中的黄色的点。在并发标记过程中，应用线程还在跑，因此会导致有些对象会从新生代晋升到老年代、有些老年代的对象引用会被改变、有些对象会直接分配到老年代，这些受到影响的老年代对象所在的card会被标记为dirty，用于重新标记阶段扫描。这个阶段过程中，老年代对象的card被标记为dirty的可能原因，就是下图中绿色的线：<br><img src="/image/cms/Concurrent-marking.png"></p></li><li><p>并发预清理：预清理，也是用于标记老年代存活的对象，目的是为了让重新标记阶段的STW尽可能短。这个阶段的目标是在并发标记阶段被应用线程影响到的老年代对象，包括：（1）老年代中card为dirty的对象；<br>（2）幸存区(from和to)中引用的老年代对象。<br>因此，这个阶段也需要扫描新生代+老年代。</p></li></ol><p>可中断的预清理：这个阶段的目标跟“预清理”阶段相同，也是为了减轻重新标记阶段的工作量。可中断预清理的价值：在进入重新标记阶段之前尽量等到一个Minor GC，尽量缩短重新标记阶段的停顿时间。另外可中断预清理会在Eden达到50%的时候开始，这时候离下一次minor gc还有半程的时间，这个还有另一个意义，即避免短时间内连着的两个停顿.<br>清理步骤后，如果满足下面两个条件，就不会开启可中断的预清理，直接进入重新标记阶段：</p><p>如果不满足上面两个条件，则进入可中断的预清理，可中断预清理可能会执行多次，那么退出这个阶段的出口有两个（源码参见下图）：<br><img src="/image/cms/cms-code.webp"></p><ul><li>设置了CMSMaxAbortablePrecleanLoops，并且执行的次数超过了这个值，这个参数的默认值是0；</li><li><p>CMSMaxAbortablePrecleanTime，执行可中断预清理的时间超过了这个值，这个参数的默认值是5000毫秒。</p></li><li><p>有可能可中断预清理过程中一直没等到Minor gc，这时候进入重新标记阶段的话，新生代还有很多活着的对象，就回导致STW变长，因此CMS还提供了CMSScavengeBeforeRemark参数，可以在进入重新标记之前强制进行依次Minor gc。</p></li><li>Eden的使用空间大于“CMSScheduleRemarkEdenSizeThreshold”，这个参数的默认值是2M； </li><li>Eden的使用率大于等于“CMSScheduleRemarkEdenPenetration”，这个参数的默认值是50%。</li></ul><p>5.（STW）重新标记：重新扫描堆中的对象，进行可达性分析,标记活着的对象。这个阶段扫描的目标是：新生代的对象 + Gc Roots + 前面被标记为dirty的card对应的老年代对象。如果预清理的工作没做好，这一步扫描新生代的时候就会花很多时间，导致这个阶段的停顿时间过长。这个过程是多线程的。</p><ol start="6"><li><p>并发清除：用户线程被重新激活，同时将那些未被标记为存活的对象标记为不可达；</p></li><li><p>并发重置：CMS内部重置回收器状态，准备进入下一个并发回收周期。</p></li></ol><h1 id="三-3-CMS缺点"><a href="#三-3-CMS缺点" class="headerlink" title="三. 3.CMS缺点"></a>三. 3.CMS缺点</h1><ul><li><p>CMS回收器采用的基础算法是Mark-Sweep。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片。 CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空 间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。  </p></li><li><p>需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！  </p></li><li><p>CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已 避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用68%的时候，CMS就开始行动了。 – XX:CMSInitiatingOccupancyFraction =n 来设置这个阀值。</p></li></ul><p>总得来说，CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式事务初识</title>
      <link href="/2018/11/28/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%88%9D%E8%AF%86.html"/>
      <url>/2018/11/28/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%88%9D%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据库事务认知"><a href="#1-数据库事务认知" class="headerlink" title="1. 数据库事务认知"></a>1. 数据库事务认知</h1><p>在开发中，我们常接触的及时数据库事务。但是一般人都知道数据库事务的几个特新ACID:</p><ul><li>原子性(Atomicity)</li><li>一致性( Consistency </li><li>隔离性或独立性(Isolation)</li><li>持久性(Durabilily)  </li></ul><p>但是再往下,比如问到隔离性指的是什么的时候可能就不知道了，或者是知道隔离性是什么但是再问到数据库实现隔离的都有哪些级别，或者是每个级别他们有什么区别的时候可能就不知道了。<br><a id="more"></a></p><h2 id="2-分布式事务"><a href="#2-分布式事务" class="headerlink" title="2. 分布式事务"></a>2. 分布式事务</h2><p>在数据库正常运行情况下的事务我们很好理解。但是当数据库在执行事务的时候突然宕机了，比如断电、关机等等，这个时候怎么能保证事务呢? 网上有很多相关的资料，大家可以了解下。<br>什么是分布式事务<br>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。<br>参考 <a href="https://mp.weixin.qq.com/s/W7XeNKIwB-JxnyStq0xD6g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/W7XeNKIwB-JxnyStq0xD6g</a></p><blockquote><p><strong>分布式系统的核心就是处理各种异常情况。</strong> </p></blockquote><p>这也是分布式系统复杂的地方，因为分布式的网络环境很复杂，这种“断电”故障要比单机多很多，所以我们在做分布式系统的时候，最先考虑的就是这种情况。这些异常可能有 </p><ul><li>机器异常</li><li>网络异常</li><li>消息丢失、乱序 </li><li>数据错误 </li><li>不可靠的TCP </li><li>存储数据丢失</li><li>其他异常等等…</li></ul><h3 id="2-1-分布式理论"><a href="#2-1-分布式理论" class="headerlink" title="2.1 分布式理论"></a>2.1 分布式理论</h3><p>在分布式环境下，不可能做到满足事务的ACID特性。那么我们该怎么办呢？<br>现在常用的分布式事务方案是基于CAP定理的，何为CAP?</p><p>CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：</p><ul><li>一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)</li><li>可用性(Availability) ： 每个操作都必须以可预期的响应结束</li><li>分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成<br>通俗的讲，在分布式环境下，最多只能满足CAP定理中的两个。但是任何策略都要依赖数据分区，一次最终我们要在一致性和可用性之间做出选择。</li></ul><p>对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。<br>对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点评cat埋点</title>
      <link href="/2018/10/23/%E8%BF%90%E7%BB%B4/%E7%82%B9%E8%AF%84cat%E5%9F%8B%E7%82%B9.html"/>
      <url>/2018/10/23/%E8%BF%90%E7%BB%B4/%E7%82%B9%E8%AF%84cat%E5%9F%8B%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-tracing-演进时间线"><a href="#1-tracing-演进时间线" class="headerlink" title="1. tracing 演进时间线"></a>1. tracing 演进时间线</h1><p><img src="/image/tracing/tracingTime.jpg"><br><a id="more"></a></p><p>从上图可以看出<code>CAT（Central Application Tracking）</code>出现的还是比较早的。CAT整个产品研发是从2011年底开始的，当时正是大众点评从.NET迁移到Java的核心起步阶段。当初大众点评已经有核心的基础中间件、RPC组件Pigeon、统一配置组件Lion。整体Java迁移已经在服务化的路上。随着服务化的深入，整体Java在线上部署规模逐渐变多，同时，暴露的问题也越来越多。<br>CAT从开发至今，一直秉承着简单的架构就是最好的架构原则，主要分为三个模块：  </p><ul><li>cat-client（官方表示后期会废弃该模块） 提供给业务以及中间层埋点的底层SDK。</li><li>cat-consumer 用于实时分析从客户端提供的数据。</li><li>cat-home 作为用户给用户提供展示的控制端。<br>详细信息参考:<br><a href="https://zhuanlan.zhihu.com/p/23351994" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23351994</a><br><a href="https://github.com/dianping/cat/blob/master/cat-doc/posts/ch5-design/server.md" target="_blank" rel="noopener">https://github.com/dianping/cat/blob/master/cat-doc/posts/ch5-design/server.md</a>  </li></ul><p>本文不在累述cat的搭建过程，目前官方github的说明文档（3.0版本）已经修复之前若干错误问题。本文只是简单聊下我在集成cat遇到的坑</p><h1 id="2-集成cat遇到的坑："><a href="#2-集成cat遇到的坑：" class="headerlink" title="2.集成cat遇到的坑："></a>2.集成cat遇到的坑：</h1><ul><li><ol><li><p>全局<code>client.xml</code>目录和log目录默认不可更换<br>这个问题可以说很严重也可以说可以忽略不计（如果服务器对每个目录都有权限限制，就是一个严重的问题）<br>经过研究源码发现，其实要想修改这两个也是可以的只是相对麻烦</p><ul><li><p>(1) 修改client.xml配置路径为可配置相关代码（基于3.0版本代码，之前版本更麻烦）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Value</span>(<span class="string">"$&#123;cat.client.path&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String CAT_CLIENT_PATH = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化cat相关配置默认是 /data/appdatas/cat</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadConfigFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String catClientXml = CAT_CLIENT_PATH;</span><br><span class="line">    System.setProperty(<span class="string">"catXmlPath"</span>,catClientXml);</span><br><span class="line">    File file = <span class="keyword">new</span> File(catClientXml);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file = <span class="keyword">new</span> File(Cat.getCatHome() + <span class="string">"client.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Cat.initialize(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(2) 修改打印日志目录<br>主要是修改 plexus相关的配置<br>plexus相关的说明可以参考 <a href="https://github.com/dianping/cat/blob/v3.0.0/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84cat%E5%89%96%E6%9E%90.docx" target="_blank" rel="noopener">https://github.com/dianping/cat/blob/v3.0.0/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84cat%E5%89%96%E6%9E%90.docx</a><br>在项目资源路径下新建<code>META-INF/plexus</code>文件夹,之后创建<code>plexus.xml</code>，其他方法不能修改日志路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plexus</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">components</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">role</span>&gt;</span>org.codehaus.plexus.logging.LoggerManager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">implementation</span>&gt;</span>org.unidal.lookup.logger.TimedConsoleLoggerManager<span class="tag">&lt;/<span class="name">implementation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dateFormat</span>&gt;</span>MM-dd HH:mm:ss.SSS<span class="tag">&lt;/<span class="name">dateFormat</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">showClass</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">logFilePattern</span>&gt;</span>cat_&#123;0,date,yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">logFilePattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">baseDirRef</span>&gt;</span>CAT_HOME<span class="tag">&lt;/<span class="name">baseDirRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultBaseDir</span>&gt;</span>日志的绝对路径<span class="tag">&lt;/<span class="name">defaultBaseDir</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">components</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plexus</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><ol start="2"><li>资源少并且杂乱<br>目前官方3.0版本相关的文档已经可以正常使用了！！！！之前的惨不忍睹！！！<br>官方文档没有过多的说明埋点的细节，也没有一个统一的入口，只是大致说了 Transaction的用法，官方给的几个集成组件又太少，只能满足一些传统技术的接入，比如springCloud并没有相关的介绍<br>到网上搜索相关的资源几乎都是一样的。</li></ol></li><li><ol start="3"><li>展示消息树不够直观<br>展示链路消息的时候，默认情况下要么只能展示详细数据要么只能展示跟踪路径，没有把两者结合，如果基于官方开发相关页面又浪费时间</li></ol></li><li><ol start="4"><li>不能在日志中展示追踪信息<br>由于cat是基于消息树，没有traceId这个概念，如果想要在日志中能看到对应的数据。我们做链路追踪不仅仅只是关心链路情况。当链路中有异常情况，我们需要根据traceId很快的找到对应的问题。</li></ol></li></ul><p>未完待续…..</p>]]></content>
      
      
      
        <tags>
            
            <tag> cat </tag>
            
            <tag> 分布式链路跟踪 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>elk6.x 安装x-pack</title>
      <link href="/2018/08/22/%E8%BF%90%E7%BB%B4/elk%E5%AE%89%E8%A3%85x-pack.html"/>
      <url>/2018/08/22/%E8%BF%90%E7%BB%B4/elk%E5%AE%89%E8%A3%85x-pack.html</url>
      
        <content type="html"><![CDATA[<p>注意：安装x-pack的时候一定要停止对应的服务，不然可能出现各种异常报错</p><h2 id="elasticsearch安装x-pack"><a href="#elasticsearch安装x-pack" class="headerlink" title="elasticsearch安装x-pack"></a>elasticsearch安装x-pack</h2><p>切换到es的bin目录<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./elasticsearch-plugin install x-pack</span><br></pre></td></tr></table></figure></p><p>稍等片刻可以安装完毕(很快)，如果不能下载插件的话可以本地安装</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./logstash-plugin install xx/x-pack-version.zip</span><br></pre></td></tr></table></figure><p>启动elasticsearch之后，到bin目录执行下面命令初始化密码:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/x-pack/setup-passwords interactive  //ps:自定义是密码</span><br><span class="line">./bin/x-pack/setup-passwords auto   //ps:随机设置密码</span><br></pre></td></tr></table></figure></p><p>浏览器输入<a href="http://ip:9200" target="_blank" rel="noopener">http://ip:9200</a>  的时候会提示输入用户名和密码<br><img src="/image/elk/es-login.png"></p><h2 id="logstash安装x-pack"><a href="#logstash安装x-pack" class="headerlink" title="logstash安装x-pack"></a>logstash安装x-pack</h2><p>切换到logstash的bin目录执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./logstash-plugin install x-pack</span><br></pre></td></tr></table></figure></p><p>稍等片刻安装完成，此时重启logstash你会发现报错了…..<br>报错1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">but got an error. &#123;:url=&gt;&quot;http://logstash_system:xxxxxx@localhost:9200/</span><br></pre></td></tr></table></figure></p><p>在logstash.yml中添加<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">xpack.monitoring.elasticsearch.url:</span> <span class="attr">http://ip:9200</span></span><br></pre></td></tr></table></figure></p><p>报错2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WARN ][logstash.licensechecker.licensereader] Attempted to resurrect connection to dead ES instance, but got an error. &#123;:url=&gt;&quot;http://localhost:9200/&quot;, :error_type=&gt;LogStash::Outputs::ElasticSearch::HttpClient::Pool::HostUnreachableError, :error=&gt;&quot;Elasticsearch Unreachable: [http://localhost:9200/][Manticore::SocketException] Connection refused (Connection refused)&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="https://discuss.elastic.co/t/logstash-with-x-pack/90230" target="_blank" rel="noopener">https://discuss.elastic.co/t/logstash-with-x-pack/90230</a><br><a href="https://www.cnblogs.com/liang1101/p/8509978.html" target="_blank" rel="noopener">https://www.cnblogs.com/liang1101/p/8509978.html</a><br>也可以关闭xpack的monitoring检测<br>在logstash.yml中添加<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">xpack.monitoring.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>在logstash加载的配置文件配置es的用户名和密码:使用es用户的账号，其他账号由于权限问题会导致各种报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch&#123;</span><br><span class="line">      hosts =&gt; [&quot;ip:9200&quot;]</span><br><span class="line">      index =&gt; &quot;xxx-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">      user =&gt; &quot;esUser&quot;</span><br><span class="line">      password =&gt; &quot;espasswd&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="kibana安装xpack"><a href="#kibana安装xpack" class="headerlink" title="kibana安装xpack"></a>kibana安装xpack</h2><p>切换到kibana的bin目录<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kibana-plugin install xpack</span><br></pre></td></tr></table></figure></p><p>这个过程很慢，可以先去做其他的事情了<br>修改kibana配置<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi config/kibana.yml</span><br></pre></td></tr></table></figure></p><p>在kibana配置文件添加<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">xpack.reporting.encryptionKey:</span> <span class="string">"xxxxxxxxx"</span></span><br><span class="line"><span class="string">xpack.security.encryptionKey:</span> <span class="string">"something_at_least_32_characters"</span></span><br><span class="line"><span class="string">elasticsearch.username:</span> <span class="string">"esUser"</span></span><br><span class="line"><span class="string">elasticsearch.password:</span> <span class="string">"espasswd"</span></span><br></pre></td></tr></table></figure></p><p>启动kibana，访问 <a href="http://ip:5601" target="_blank" rel="noopener">http://ip:5601</a> ,输入用户名密码登录<br><img src="/image/elk/kibana.png"></p><h2 id="破解-pack（支持购买正版）"><a href="#破解-pack（支持购买正版）" class="headerlink" title="破解-pack（支持购买正版）"></a>破解-pack（支持购买正版）</h2><p>安装好x-pack后试用期只有一个月，可以在这个地址申请免费一年license：<a href="https://license.elastic.co/registration。" target="_blank" rel="noopener">https://license.elastic.co/registration。</a><br>如果你想要一个长期的证书，看下面的步骤（本人使用idea编译，也可以直接编写Java文件替换）</p><ul><li>1.新建LicenseVerifier.java 和 XPackBuild。包名和源文件保持一致（可以解压x-pack-core-xxx.jar查看文件）</li><li>2.将<code>elasticsearch-xxx/plugins/x-pack</code> 和 <code>elasticsearch-xxx/lib</code>文件拷贝到本地项目中</li><li><p>3.编写LicenseVerifier.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.elasticsearch.license;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LicenseVerifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifyLicense</span><span class="params">(<span class="keyword">final</span> License license, <span class="keyword">final</span> <span class="keyword">byte</span>[] encryptedPublicKeyData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifyLicense</span><span class="params">(<span class="keyword">final</span> License license)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4.编写XPackBuild.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.elasticsearch.xpack.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.SuppressForbidden;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.io.PathUtils;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPackBuild</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> XPackBuild CURRENT;</span><br><span class="line">    <span class="keyword">private</span> String shortHash;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressForbidden</span>(reason = <span class="string">"looks up path of xpack.jar directly"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Path <span class="title">getElasticsearchCodebase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> URL url = XPackBuild.class.getProtectionDomain().getCodeSource().getLocation();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> PathUtils.get(url.toURI());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException bogus) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(bogus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    XPackBuild(<span class="keyword">final</span> String shortHash, <span class="keyword">final</span> String date) &#123;</span><br><span class="line">        <span class="keyword">this</span>.shortHash = shortHash;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.shortHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Path path = getElasticsearchCodebase();</span><br><span class="line">        String shortHash = <span class="keyword">null</span>;</span><br><span class="line">        String date = <span class="keyword">null</span>;</span><br><span class="line">        Label_0157:</span><br><span class="line">        &#123;</span><br><span class="line">            shortHash = <span class="string">"Unknown"</span>;</span><br><span class="line">            date = <span class="string">"Unknown"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CURRENT = <span class="keyword">new</span> XPackBuild(shortHash, date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>编译文件后，将生成的class替换到解压的x-pack-core-xxx.jar文件夹中，停止重新生成jar包丢到服务器对应的位置<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf x-pack-core-xxx.jar ./*</span><br></pre></td></tr></table></figure></p><p>停止es，重启  </p><p>我编译好的jar包在这,可以直接使用<br><a href="/raw/x-pack-core-6.2.4.jar">x-pack-core-6.2.4.jar</a>  </p><p>如果碰到这个问题<br><code>Cannot install a [PLATINUM] license unless TLS is configured or security is disabled</code><br>或者<br><code>Please set [xpack.security.transport.ssl.enabled] to [true] or disable security by setting [xpack.security.enabled] to [false].</code><br>可以在<code>elasticsearch.yml</code>文件中添加下面的配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xpack.security.enabled: false和xpack.security.transport.ssl.enabled: true都可以解决这个问题，任选一个</span></span><br><span class="line"><span class="comment">#xpack.security.enabled: false </span></span><br><span class="line"><span class="string">xpack.security.transport.ssl.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>修改上面下载的证书json文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"license"</span>: &#123;</span><br><span class="line">                <span class="attr">"uid"</span>: <span class="string">"你的uuid"</span>, </span><br><span class="line">                "type": "platinum", # 修改授权为白金版本</span><br><span class="line">                "issue_date_in_millis": 1526860800000,</span><br><span class="line">                "expiry_date_in_millis": 2524579200999, #修改到期时间</span><br><span class="line">                "max_nodes": 100, # 修改最大节点数</span><br><span class="line">                "issued_to": "xxxx", #你申请时填写的，不需要动</span><br><span class="line">                "issuer": "xxx", #你申请时填写的，不需要动</span><br><span class="line">                "signature": "xxxxxxaasa", #原文件中的签名，不需要动</span><br><span class="line">                "start_date_in_millis": 1526860800000</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>导入证书<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -u elastic:elastic -XPUT <span class="string">'http://es-ip:port/_xpack/license'</span> -H <span class="string">"Content-Type: application/json"</span> -d @license.json</span><br><span class="line">``` </span><br><span class="line">返回如下数据，说明激活成功</span><br><span class="line">```json</span><br><span class="line">&#123;<span class="string">"acknowledged"</span>:<span class="literal">true</span>,<span class="string">"license_status"</span>:<span class="string">"valid"</span>&#125;[</span><br></pre></td></tr></table></figure></p><p>将elk都重启后，打开kibana可以看到有效日期变化了。<br><img src="/image/elk/license.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> -elk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Spring Boot、Multipartfile上传文件路径错误问题</title>
      <link href="/2018/07/17/java/%E4%BD%BF%E7%94%A8Spring-Boot%E3%80%81Multipartfile%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98.html"/>
      <url>/2018/07/17/java/%E4%BD%BF%E7%94%A8Spring-Boot%E3%80%81Multipartfile%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h2><p>java.io.IOException: java.io.FileNotFoundException: /tmp/tomcat/…/tmp/files/xxx.jpg (No such file or directory)<br>问题源码： transferTo方法报错<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"/tmp/files/"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    multipartFile.transferTo(file);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>源码中文件定义的是相对路径，预期路径应该是项目路径/tmp/source/，但是报错确是一个系统临时文件路径（tomcat的）。<br>由于是transferTo方法报错，因此应该是该方法写入文件时报错，因此，我们跟入方法源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardMultipartHttpServletRequest</span> <span class="keyword">extends</span> <span class="title">AbstractMultipartHttpServletRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_DISPOSITION = <span class="string">"content-disposition"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILENAME_KEY = <span class="string">"filename="</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILENAME_WITH_CHARSET_KEY = <span class="string">"filename*="</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset US_ASCII = Charset.forName(<span class="string">"us-ascii"</span>);</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; multipartParameterNames;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardMultipartFile</span> <span class="keyword">implements</span> <span class="title">MultipartFile</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Part part;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String filename;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(File dest)</span> <span class="keyword">throws</span> IOException, IllegalStateException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.part.write(dest.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationPart</span> <span class="keyword">implements</span> <span class="title">Part</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="comment">// 问题在这里：如果文件不是绝对路径就重新创建！！</span></span><br><span class="line">        <span class="keyword">if</span> (!file.isAbsolute()) &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(<span class="keyword">this</span>.location, fileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.fileItem.write(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Servlet3.0的支持的上传文件功能时，如果我们没有使用绝对路径的话，transferTo方法会在相对路径前添加一个location路径，即：file = new File(location, fileName)，由于创建的File在项目路径/tmp/files/，而transferTo方法预期写入的文件路径为/tmp/tomcat/…/tmp/files/xxx.jpg，我们并没有创建该目录，因此会抛出异常。</p><h2 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h2><ul><li>1 使用绝对路径</li><li>2 修改location的值<br>这个location可以理解为临时文件目录，我们可以通过配置location的值，使其指向我们的项目路径，这样就解决了我们遇到的问题。<br>在Spring Boot下配置location，可以在main()方法所在文件中添加如下代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function">MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultipartConfigFactory factory = <span class="keyword">new</span> MultipartConfigFactory();</span><br><span class="line">    <span class="comment">//设置路径xxx</span></span><br><span class="line">    factory.setLocation(<span class="string">"/xxx"</span>);</span><br><span class="line">    <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Multipartfile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ELK+filebeat+kafka+zooKeeper搭建（单机版）</title>
      <link href="/2018/05/09/%E8%BF%90%E7%BB%B4/ELK-filebeat-kafka-zooKeeper%E6%90%AD%E5%BB%BA.html"/>
      <url>/2018/05/09/%E8%BF%90%E7%BB%B4/ELK-filebeat-kafka-zooKeeper%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<p>本教程中使用的<code>ELK和filebeat</code>版本是 <code>6.2.4</code></p><h2 id="1-elk安装"><a href="#1-elk安装" class="headerlink" title="1. elk安装"></a>1. elk安装</h2><p>关于elk的配置参考我之前的一篇文章，不在累述：<br>elk安装地址：<br><a href="https://jjlu521016.github.io/2018/05/01/springboot-logback-log4j-elk.html#2-elk%E9%85%8D%E7%BD%AE">https://jjlu521016.github.io/2018/05/01/springboot-logback-log4j-elk.html#2-elk%E9%85%8D%E7%BD%AE</a><br><a id="more"></a></p><h2 id="2-kafka及zookeeper安装"><a href="#2-kafka及zookeeper安装" class="headerlink" title="2. kafka及zookeeper安装"></a>2. kafka及zookeeper安装</h2><p>参考我之前的文章、把对应的配置改成单机即可：</p><h3 id="2-1-安装kafka："><a href="#2-1-安装kafka：" class="headerlink" title="2.1. 安装kafka："></a>2.1. 安装kafka：</h3><p> <a href="https://jjlu521016.github.io/2018/01/12/%E8%BF%90%E7%BB%B4/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html#more">https://jjlu521016.github.io/2018/01/12/%E8%BF%90%E7%BB%B4/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html#more</a></p><h3 id="2-2-安装zookeeper："><a href="#2-2-安装zookeeper：" class="headerlink" title="2.2. 安装zookeeper："></a>2.2. 安装zookeeper：</h3><p><a href="https://jjlu521016.github.io/2018/01/01/%E8%BF%90%E7%BB%B4/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html#more">https://jjlu521016.github.io/2018/01/01/%E8%BF%90%E7%BB%B4/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html#more</a></p><h3 id="2-3-启动zookeeper"><a href="#2-3-启动zookeeper" class="headerlink" title="2.3 启动zookeeper"></a>2.3 启动zookeeper</h3><p>我本地zookeeper配置了环境变量<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure></p><h3 id="2-4-启动kafka"><a href="#2-4-启动kafka" class="headerlink" title="2.4 启动kafka"></a>2.4 启动kafka</h3><p>启动kafka<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-server-start.sh config/server.properties</span></span><br></pre></td></tr></table></figure></p><p>创建topic<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-topics.sh --create --zookeeper 192.168.188.110:2181 --replication-factor 1 --partitions 1 --topic test</span></span><br></pre></td></tr></table></figure></p><p>创建生产者<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-console-producer.sh --broker-list 192.168.188.110:9092 --topic test</span></span><br></pre></td></tr></table></figure></p><p>创建消费者<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper 192.168.188.110:2181 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure></p><p>此时生产者输入的内容可以在消费者输出，证明kafka调用通了。</p><h2 id="3-集成logstash与kafka"><a href="#3-集成logstash与kafka" class="headerlink" title="3. 集成logstash与kafka"></a>3. 集成logstash与kafka</h2><p>参考：<br><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html</a><br>vi logstash_agent.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    bootstrap_servers =&gt; &quot;192.168.188.110:9092&quot;</span><br><span class="line">    #topic id</span><br><span class="line">    topics =&gt; &quot;test&quot;</span><br><span class="line">    codec =&gt; &quot;json&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    json &#123;</span><br><span class="line">      source =&gt; &quot;message&quot;</span><br><span class="line">      remove_field =&gt; &quot;message&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch&#123;</span><br><span class="line">      hosts =&gt; [&quot;192.168.188.110:9200&quot;]</span><br><span class="line">    index =&gt; &quot;kafka-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动elk之后，在kafka生产者输入一条信息之后logstash打印出对应的内容，说明集成成功了<br>。在kibana设置对应的日志。</p><h2 id="4-安装filebeat"><a href="#4-安装filebeat" class="headerlink" title="4. 安装filebeat"></a>4. 安装filebeat</h2><p>解压<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf filebeat-6.2.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>配置filebeat.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.prospectors:</span></span><br><span class="line"><span class="comment"># 这里面配置实际的日志路径</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/test1.log</span></span><br><span class="line"><span class="attr">  fields:</span></span><br><span class="line"><span class="attr">    log_topics:</span> <span class="string">test1</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/test2.log</span></span><br><span class="line"><span class="attr">  fields:</span></span><br><span class="line"><span class="attr">    log_topics:</span> <span class="string">test2</span></span><br><span class="line"><span class="string">output.kafka:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["10.112.101.90:9092"]</span></span><br><span class="line"><span class="attr">  topic:</span> <span class="string">'<span class="template-variable">%&#123;[fields][log_topics]&#125;</span>'</span></span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -e -c filebeat.yml</span><br></pre></td></tr></table></figure></p><p>把logstash停止，修改配置文件，添加filebeat配置的topic。重启logstash。打开kibana刷新页面，看到filebeat收集到的日志。</p><p><img src="https://github.com/jjlu521016/myblog/blob/master/source/image/resource/kibana1.png" alt=""></p><p>注意：<br>在logstash中，当input里面有多个kafka输入源时，client_id =&gt; “xxx”必须添加且需要不同，否则会报错javax.management.InstanceAlreadyExistsException: kafka.consumer:type=app-info,id=logstash-0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    </span><br><span class="line">     group_id =&gt; &quot;es1&quot;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  kafka &#123;</span><br><span class="line">     client_id =&gt; &quot;es2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springboot logback(log4j) elk 非集群</title>
      <link href="/2018/05/01/java/springboot-logback-log4j-elk.html"/>
      <url>/2018/05/01/java/springboot-logback-log4j-elk.html</url>
      
        <content type="html"><![CDATA[<p>好长时间没有写过blog了。抽时间把很久之前集成的一个简易的elk升级了下<br>本教程使用的软件如下：<br>springboot 2.*<br>jdk8<br>elk 6.2.4(elasticsearch logstash kibana)<br><a id="more"></a></p><h2 id="1-springboot集成logback-logstash"><a href="#1-springboot集成logback-logstash" class="headerlink" title="1. springboot集成logback+logstash"></a>1. springboot集成logback+logstash</h2><h3 id="1-1-pom加入依赖"><a href="#1-1-pom加入依赖" class="headerlink" title="1.1 pom加入依赖"></a>1.1 pom加入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Logstash encoder --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsonevent-layout<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-在application-yml中加载logback的配置文件"><a href="#1-2-在application-yml中加载logback的配置文件" class="headerlink" title="1.2 在application.yml中加载logback的配置文件"></a>1.2 在application.yml中加载logback的配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  config:</span> <span class="attr">classpath:logback.xml</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">logs</span></span><br></pre></td></tr></table></figure><h3 id="1-3-在logback-xml中配置logstash"><a href="#1-3-在logback-xml中配置logstash" class="headerlink" title="1.3 在logback.xml中配置logstash"></a>1.3 在logback.xml中配置logstash</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"logstash"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.188.110<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>4560<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- encoder is required --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"logstash"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-elk配置"><a href="#2-elk配置" class="headerlink" title="2.elk配置"></a>2.elk配置</h2><h3 id="2-1-配置es"><a href="#2-1-配置es" class="headerlink" title="2.1 配置es"></a>2.1 配置es</h3><p>解压文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf elasticsearch-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></p><p>由于es不能用root账户启动，所以需要添加一个非root账户<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd es</span><br></pre></td></tr></table></figure></p><p>修改es文件夹的权限<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es:es elasticsearch-6.2.4</span><br></pre></td></tr></table></figure></p><p>修改配置文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/elk/elasticsearch-6.2.4/config/elasticsearch.yml</span><br></pre></td></tr></table></figure></p><p>修改<code>elasticsearch.yml</code>的内容如下<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口</span></span><br><span class="line"><span class="string">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#ip</span></span><br><span class="line"><span class="string">network.host:</span> <span class="number">192.168</span><span class="number">.188</span><span class="number">.111</span></span><br><span class="line"><span class="comment">#data路径</span></span><br><span class="line"><span class="string">path.data:</span> <span class="string">/opt/elk/elasticsearch-6.2.4/data</span></span><br><span class="line"><span class="comment">#logs路径</span></span><br><span class="line"><span class="string">path.logs:</span> <span class="string">/opt/elk/elasticsearch-6.2.4/logs</span></span><br></pre></td></tr></table></figure></p><p>创建data和logs文件夹<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data logs</span><br></pre></td></tr></table></figure></p><p>启动es(为了方便观察日志没有后台启动)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure></p><h3 id="2-2-logstash-配置"><a href="#2-2-logstash-配置" class="headerlink" title="2.2 logstash 配置"></a>2.2 logstash 配置</h3><p>解压文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf logstash-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></p><p>进入config文件夹新建log4j_es.conf文件并编写内容<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi log4j_es.conf</span><br></pre></td></tr></table></figure></p><p>log4j_es.conf内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    # https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html</span><br><span class="line">    tcp &#123;  </span><br><span class="line">    mode =&gt; &quot;server&quot;  </span><br><span class="line">    host =&gt; &quot;192.168.188.110&quot;  </span><br><span class="line">    port =&gt; 4560  </span><br><span class="line">    codec =&gt; json_lines  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch&#123;</span><br><span class="line">        hosts =&gt; [&quot;192.168.188.110:9200&quot;]</span><br><span class="line">        index =&gt; &quot;log4j-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">        document_type =&gt; &quot;log4j_type&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动logstash (为了方便观察日志没有后台启动)<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f config/log4j_es.conf</span><br></pre></td></tr></table></figure></p><h3 id="2-3-kibana-配置"><a href="#2-3-kibana-配置" class="headerlink" title="2.3 kibana 配置"></a>2.3 kibana 配置</h3><p>解压<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf kibana-6.2.4-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>修改配置文件<code>kibana.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="comment"># To allow connections from remote users, set this parameter to a non-loopback address.</span></span><br><span class="line"><span class="string">server.host:</span> <span class="string">"192.168.188.110"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The URL of the Elasticsearch instance to use for all your queries.</span></span><br><span class="line"><span class="string">elasticsearch.url:</span> <span class="string">"http://192.168.188.110:9200"</span></span><br></pre></td></tr></table></figure></p><p>启动kibana<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kibana</span><br></pre></td></tr></table></figure></p><h2 id="3-kibana界面设置"><a href="#3-kibana界面设置" class="headerlink" title="3.kibana界面设置"></a>3.kibana界面设置</h2><p>进入kibana界面<br>点击 Management 点击Index Patterns<br>在 Create index pattern 的文本框输入索引名称，因为我在logstash中设置索引为 <code>log4j-%{+YYYY.MM.dd}</code>,所以我们填写 <code>log4j-*</code> 点击下一步设置直到完成。<br>点击<code>Discovery</code>可以看到我们的日志了。</p><p>接下来，将elk进行升级 使用elk+filebeat+kafka,敬请期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>localStorage简单封装设置失效时间</title>
      <link href="/2018/04/24/js/localStorage%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E8%AE%BE%E7%BD%AE%E5%A4%B1%E6%95%88%E6%97%B6%E9%97%B4.html"/>
      <url>/2018/04/24/js/localStorage%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E8%AE%BE%E7%BD%AE%E5%A4%B1%E6%95%88%E6%97%B6%E9%97%B4.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h3><p>在客户端存储数据<br>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><p>localStorage和cookie 的区别不详细对比，但是localStorage存储数据的时候有一点需要我们注意的。<br><a id="more"></a></p><h3 id="2-场景："><a href="#2-场景：" class="headerlink" title="2.场景："></a>2.场景：</h3><p>我们前端需要调用第三方api异步获取我们的数据A（短时间内数据都一样）,然后我们拿到数据A来进行其他操作。试想下从获取数据A再到用数据A获取我么想要的最终结果，这段时间对用户来说是很漫长了！<br>其实我们可以使用</p><ul><li>Cookie来存储数据，但是Cookie存储的数据有限制。</li><li>使用localStorage能满足存储数据的条件，但是它却没有失效时间。<br>那我们改怎么优化这种场景呢？</li></ul><p>综上所述，Cookie已经无法满足我们的要求了，那么我们就从localStorage入手吧。既然localStorage没有失效时间，我们就封装下使其满足我们的需求。</p><h3 id="3-实现："><a href="#3-实现：" class="headerlink" title="3.实现："></a>3.实现：</h3><p>下面的代码仅供参考：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storageUtil = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param key</span></span><br><span class="line"><span class="comment">     * @param data</span></span><br><span class="line"><span class="comment">     * @param time 失效时间（秒）,默认一周</span></span><br><span class="line"><span class="comment">     * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    put: <span class="function"><span class="keyword">function</span> (<span class="params">key, data, time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!localStorage) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!time || <span class="built_in">isNaN</span>(time)) &#123;</span><br><span class="line">                time = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> cacheExpireDate = (<span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="number">1</span>) + time * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">var</span> cacheVal = &#123;<span class="attr">val</span>: data, <span class="attr">exp</span>: cacheExpireDate&#125;;</span><br><span class="line">            localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(cacheVal));<span class="comment">//存入缓存值</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!localStorage) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> cacheVal = localStorage.getItem(key);</span><br><span class="line">            <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(cacheVal);</span><br><span class="line">            <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//缓存不存在</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//缓存过期</span></span><br><span class="line">            <span class="keyword">if</span> (now &gt; result.exp) &#123;</span><br><span class="line">                <span class="keyword">this</span>.remove(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result.val;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.remove(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!localStorage) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        localStorage.removeItem(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-使用实例"><a href="#4-使用实例" class="headerlink" title="4.使用实例"></a>4.使用实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">storageUtil.put(<span class="string">"aa"</span>,<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cacheData = storageUtil.get(<span class="string">"aa"</span>);</span><br><span class="line"><span class="keyword">if</span>(cacheData !== <span class="literal">null</span> || cacheData !== <span class="string">''</span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> localStorage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jmap命令使用</title>
      <link href="/2018/04/19/java/jmap%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8.html"/>
      <url>/2018/04/19/java/jmap%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h3 id="查看-JVM-堆内存情况"><a href="#查看-JVM-堆内存情况" class="headerlink" title="查看 JVM 堆内存情况"></a>查看 JVM 堆内存情况</h3><p>如果想分析自己的JAVA Application时，可以使用jmap程序来生成heapdump文例：<br><code>jmap -heap pid</code><br>jmap是JDK自带的一个工具，非常小巧方便，其支持参数如下：<br>    <code>-heap</code>：打印heap空间的概要，这里可以粗略的检验heap空间的使用情况。<br>官网对jmap的解释是:<br><a id="more"></a><br>DESCRIPTION<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmap prints shared object memory maps or heap memory details of a given process or core file or a remote debug server. If the given process is running on a 64-bit VM, you may need to specify the -J-d64 option, e.g.:</span><br><span class="line"></span><br><span class="line">jmap -J-d64 -heap pid</span><br><span class="line">NOTE - This utility is unsupported and may or may not be available in future versions of the JDK. In Windows Systems where dbgeng.dll is not present, &apos;Debugging Tools for Windows&apos; needs to be installed to have these tools working. Also, the PATH environment variable should contain the location of jvm.dll used by the target process or the location from which the Crash Dump file was produced.</span><br><span class="line">For example, set PATH=&lt;jdk&gt;\jre\bin\client;%PATH%</span><br></pre></td></tr></table></figure></p><p>OPTIONS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;no option&gt;</span><br><span class="line">When no option is used jmap prints shared object mappings. For each shared object loaded in the target VM, start address, the size of the mapping, and the full path of the shared object file are printed. This is similar to the Solaris pmap utility.</span><br><span class="line"></span><br><span class="line">-dump:[live,]format=b,file=&lt;filename&gt;</span><br><span class="line">Dumps the Java heap in hprof binary format to filename. The live suboption is optional. If specified, only the live objects in the heap are dumped. To browse the heap dump, you can use jhat (Java Heap Analysis Tool) to read the generated file.</span><br><span class="line"></span><br><span class="line">-finalizerinfo</span><br><span class="line">Prints information on objects awaiting finalization.</span><br><span class="line"></span><br><span class="line">-heap</span><br><span class="line">Prints a heap summary. GC algorithm used, heap configuration and generation wise heap usage are printed.</span><br><span class="line"></span><br><span class="line">-histo[:live]</span><br><span class="line">Prints a histogram of the heap. For each Java class, number of objects, memory size in bytes, and fully qualified class names are printed. VM internal class names are printed with &apos;*&apos; prefix. If the live suboption is specified, only live objects are counted.</span><br><span class="line"></span><br><span class="line">-permstat</span><br><span class="line">Prints class loader wise statistics of permanent generation of Java heap. For each class loader, its name, liveness, address, parent class loader, and the number and size of classes it has loaded are printed. In addition, the number and size of interned Strings are printed.</span><br><span class="line"></span><br><span class="line">-F</span><br><span class="line">Force. Use with jmap -dump or jmap -histo option if the pid does not respond. The live suboption is not supported in this mode.</span><br><span class="line"></span><br><span class="line">-h</span><br><span class="line">Prints a help message.</span><br><span class="line"></span><br><span class="line">-help</span><br><span class="line">Prints a help message.</span><br><span class="line"></span><br><span class="line">-J&lt;flag&gt;</span><br><span class="line">Passes &lt;flag&gt; to the Java virtual machine on which jmap is run.</span><br></pre></td></tr></table></figure></p><h3 id="jmap-heap命令显示的结果"><a href="#jmap-heap命令显示的结果" class="headerlink" title="jmap -heap命令显示的结果"></a>jmap -heap命令显示的结果</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 837</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 837, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)//GC 方式</span><br><span class="line">Heap Configuration: //堆内存初始化配置</span><br><span class="line">   MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">   MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">   MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">   NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">   MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">   OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">   NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">   SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">   PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">   MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">   G1HeapRegionSize = 0 (0.0MB)</span><br><span class="line">Heap Usage://堆内存使用情况</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space://Eden区内存分布</span><br><span class="line">   capacity = 33030144 (31.5MB)//Eden区总容量</span><br><span class="line">   used     = 1524040 (1.4534378051757812MB)  //Eden区已使用</span><br><span class="line">   free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量</span><br><span class="line">   4.614088270399305% used //Eden区使用比率</span><br><span class="line">From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:  //另一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation //当前的Old区内存分布</span><br><span class="line">   capacity = 86507520 (82.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 86507520 (82.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">   free     = 19523568 (18.619125366210938MB)</span><br><span class="line">   11.337498256138392% used</span><br><span class="line">670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> jmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql常用SQL</title>
      <link href="/2018/04/14/DB/mysql%E5%B8%B8%E7%94%A8SQL.html"/>
      <url>/2018/04/14/DB/mysql%E5%B8%B8%E7%94%A8SQL.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-查询一段时间内的数据："><a href="#1-查询一段时间内的数据：" class="headerlink" title="1. 查询一段时间内的数据："></a>1. 查询一段时间内的数据：</h3><p> 查询一天：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">to_days</span>(column_time) = <span class="keyword">to_days</span>(<span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="built_in">date</span>(column_time) = <span class="keyword">curdate</span>();</span><br></pre></td></tr></table></figure></p><p>查询一周：<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>   <span class="keyword">where</span> <span class="keyword">DATE_SUB</span>(<span class="keyword">CURDATE</span>(), <span class="built_in">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>) &lt;= <span class="built_in">date</span>(column_time);</span><br></pre></td></tr></table></figure></p><p>查询一个月：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">DATE_SUB</span>(<span class="keyword">CURDATE</span>(), <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>) &lt;= <span class="built_in">date</span>(column_time);</span><br></pre></td></tr></table></figure></p><p>更新待续……</p><h3 id="2-索引："><a href="#2-索引：" class="headerlink" title="2.索引："></a>2.索引：</h3><ul><li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></li></ul><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></p><ul><li>尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></li></ul><p>可以这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> all</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></p><ul><li>in 和 not in 也要慎用，否则会导致全表扫描。</li><li>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure></li></ul><p>可以改为强制查询使用索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure></p><ul><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描</li><li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li><li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</li><li>很多时候用 exists 代替 in 是一个好的选择：</li><li>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读写锁ReaderWriterLockSlim</title>
      <link href="/2018/03/29/java/%E8%AF%BB%E5%86%99%E9%94%81ReaderWriterLockSlim.html"/>
      <url>/2018/03/29/java/%E8%AF%BB%E5%86%99%E9%94%81ReaderWriterLockSlim.html</url>
      
        <content type="html"><![CDATA[<p>关于读写锁的定义可以到网上查询，这里不再啰嗦了。</p><h3 id="1-场景："><a href="#1-场景：" class="headerlink" title="1. 场景："></a>1. 场景：</h3><p>多个线程同时读写，读线程的数量远远大于写线程，该怎么办？</p><p>如果我们只是简单的使用lock方式去加锁，则会影响性能。如果采用读写锁，那么多个线程可以同时读取该对象，只有等到对象被写入锁占用的时候，才会阻塞。<br>也就是说某个线程进入了写入模式，那么其他线程无论是要写入还是读取，都是会被阻塞的。</p><ul><li>进入写入/读取模式有2种方法：<br>　　EnterReadLock尝试进入写入模式锁定状态。<br>　　TryEnterReadLock(Int32) 尝试进入读取模式锁定状态，可以选择整数超时时间。<br>　　EnterWriteLock 尝试进入写入模式锁定状态。<br>　　TryEnterWriteLock(Int32) 尝试进入写入模式锁定状态，可以选择超时时间。</li><li>退出写入/读取模式有2种方法：<br>　　ExitReadLock 减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。<br>　　ExitWriteLock 减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。</li></ul><h3 id="待续……"><a href="#待续……" class="headerlink" title="待续……."></a>待续…….</h3>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>详情页返回到列表页定位处理</title>
      <link href="/2018/03/22/js/%E8%AF%A6%E6%83%85%E9%A1%B5%E8%BF%94%E5%9B%9E%E5%88%B0%E5%88%97%E8%A1%A8%E9%A1%B5%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86.html"/>
      <url>/2018/03/22/js/%E8%AF%A6%E6%83%85%E9%A1%B5%E8%BF%94%E5%9B%9E%E5%88%B0%E5%88%97%E8%A1%A8%E9%A1%B5%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>在H5页面的电商系统中往往会有以下需求：<br>点击分类等跳转到商品列表页，点击某个商品之后再返回到列表页，返回列表页面的时候能记住之前浏览的位置：</p><h3 id="2-方案："><a href="#2-方案：" class="headerlink" title="2.方案："></a>2.方案：</h3><a id="more"></a><p>我们需要哪些数据？</p><ul><li>当前页数</li><li>当前已经加载的数据</li><li>当前滚动的高度</li></ul><h4 id="2-1-cookies和localstorage"><a href="#2-1-cookies和localstorage" class="headerlink" title="2.1 cookies和localstorage"></a>2.1 cookies和localstorage</h4><ul><li>在页面滚动的过程中将滚动的距离和当前页数记录下来(也有设置锚点的)。</li><li>加载新数据的时候将页面的数据及当前页数记录下来。</li><li>将上面三个数据存储到浏览器缓存中，并设计过期时间。</li><li>从商品详情页回到列表页面的时候,判断是否是从详情页返回的(可以根据 window.location.hash判断)。如果是从详情页返回的，将数据加载到html页面。</li><li>缓存过期后，清除缓存。</li></ul><p>这个方案有2个弊端</p><ul><li>浏览器必须支持 localstorage(主流的基本上都支持了)</li><li>缓存失效时间，如果处理不当可能造成数据混乱</li></ul><h4 id="2-2-html5的replaceState"><a href="#2-2-html5的replaceState" class="headerlink" title="2.2 html5的replaceState"></a>2.2 html5的replaceState</h4><p>history.pushState() 和 history.replaceState() 是什么有兴趣的可以到网上查下</p><ul><li>创建一个对象用于存储需要的信息</li><li>在页面滚动的过程中将当前滚动的距离记录下来。</li><li>加载新数据的时候替换老的数据。</li><li>点击进入商品详情页之前将当前页数、数据、滚动距离更新到对象中。</li><li>从商品详情页回到列表页面的时候，$(window).load()判断是否有数据，有就从对象中取，否则ajax请求</li><li>window.history.replaceState({}, “”, page); 清空数据</li></ul><p>总上所述，个人比较推荐方案2<br>现贴上方案2的部分代码，仅供参考</p><pre><code class="javascript">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{    <span class="keyword">if</span> ($(<span class="built_in">window</span>).scrollTop() + $(<span class="built_in">window</span>).height() - $(<span class="built_in">document</span>).height() &gt;= <span class="number">-1</span>) {        <span class="keyword">if</span> (!scrolling) {            curPage++;            showLoading();            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{                getList(<span class="number">10</span>);            }, <span class="number">3000</span>);        }    }});$(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{    <span class="comment">//判断如果有history.state.data，说明是从详情页返回的</span>    <span class="keyword">if</span> (!!(<span class="built_in">window</span>.history.state &amp;&amp; <span class="built_in">window</span>.history.state.data)) {        $(<span class="string">"#loading"</span>).hide();        $(<span class="string">"#nomore"</span>).hide();        $(<span class="string">"#loadmore"</span>).show(); <span class="comment">//隐藏loading，显示 加载更多（为了分页）</span>        dealWithResult(<span class="built_in">window</span>.history.state); <span class="comment">//根据记录的数据显示列表</span>        curPage = <span class="built_in">window</span>.history.state.curPage;        statedata = <span class="built_in">window</span>.history.state; <span class="comment">//把页面和data赋值给全局变量</span>        <span class="built_in">window</span>.history.replaceState({}, <span class="string">""</span>, <span class="string">"list.html"</span>); <span class="comment">//清空state，防止列表页点返回的时候会回到上一个state</span>    } <span class="keyword">else</span> {        getList(<span class="number">20</span>);     }});<span class="function"><span class="keyword">function</span> <span class="title">dealWithResult</span>(<span class="params">listdata</span>) </span>{    $(<span class="string">"#list"</span>).html(listdata.data)        <span class="comment">//判断如果是详情页回来，获取上次的滚动条位置</span>    <span class="keyword">if</span> (!!(<span class="built_in">window</span>.history.state &amp;&amp; <span class="built_in">window</span>.history.state.data)) {        <span class="comment">// 延迟 0.5秒滚动，防止页面中列表还没构建完</span>        setTimeout(<span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="built_in">window</span>.history.state.sh || <span class="number">0</span>), <span class="number">500</span>);    }}<span class="keyword">var</span> totalnum = <span class="number">0</span>;<span class="keyword">var</span> statedata = {};<span class="keyword">var</span> curPage = <span class="number">1</span>;<span class="function"><span class="keyword">function</span> <span class="title">getList</span>(<span class="params">num</span>) </span>{    <span class="keyword">var</span> li = <span class="string">''</span>;    <span class="keyword">for</span> (i = totalnum; i &lt; totalnum + num; i++) {        li += <span class="string">'&lt;li class="goodsDetail"&gt;&lt;a href="javascript:void(0);"&gt;list'</span> + (i + <span class="number">1</span>) + <span class="string">'&lt;/a&gt;&lt;/li&gt;'</span>;    }    totalnum += num    $(<span class="string">"#list"</span>).append(li);    statedata.data = $(<span class="string">"#list"</span>).html();    hideLoading();}<span class="function"><span class="keyword">function</span> <span class="title">showLoading</span>(<span class="params"></span>) </span>{    scrolling = <span class="literal">true</span>;    $(<span class="string">"#loading"</span>).show();}<span class="function"><span class="keyword">function</span> <span class="title">hideLoading</span>(<span class="params"></span>) </span>{    scrolling = <span class="literal">false</span>;    $(<span class="string">"#loading"</span>).hide();}$(<span class="string">"#list"</span>).on(<span class="string">'click'</span>, <span class="string">".goodsDetail"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{    <span class="comment">//所有数据</span>    <span class="keyword">var</span> data = $(<span class="string">"#list"</span>).html();    statedata.curPage = curPage    statedata.data = data    statedata.sh = scroll2Top();    <span class="keyword">var</span> hrefPage = <span class="string">"detail.html"</span>;    history.replaceState(statedata, <span class="string">""</span>, <span class="string">"list.html"</span>);    <span class="built_in">window</span>.location.href = hrefPage;});<span class="comment">//当前滚动条位置</span><span class="function"><span class="keyword">function</span> <span class="title">scroll2Top</span>(<span class="params"></span>) </span>{    <span class="keyword">var</span> scrollTop = <span class="number">0</span>;    <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement &amp;&amp; <span class="built_in">document</span>.documentElement.scrollTop) {        scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.body) {        scrollTop = <span class="built_in">document</span>.body.scrollTop;    }    <span class="keyword">return</span> scrollTop;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jquery中.attr和.data的区别</title>
      <link href="/2018/03/16/js/Jquery%E4%B8%AD-attr%E5%92%8C-data%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/2018/03/16/js/Jquery%E4%B8%AD-attr%E5%92%8C-data%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<p>$.attr()和$.data()本质上属于 <code>DOM属性</code> 和 <code>Jquery对象属性</code> 的区别：</p><ul><li>$.attr()每次都从DOM元素中取属性的值。</li><li>$.attr(‘data-xxx’, ‘xxxxx’)会将字符串’xxxx’塞到标签的’data-xxx’属性中。<a id="more"></a></li><li>$.data(‘xxx’)是从 Jquery对象中取值，由于对象属性值保存在内存中，因此可能和视图里的属性值不一致的情况。</li><li>$.data(‘xxx’, ‘xxxx’)会将字符串’xxxx’塞到 Jquery对象 的’xxx’属性中，而不是塞到视图标签的data-xxx属性中。</li></ul><p>所以$.attr()和$.data()应避免混合用</p><ul><li>通过$.attr()来进行set属性，然后通过$.data()进行get属性值；</li><li>通过$.data()来进行set属性，然后通过$.attr()进行get属性值。<br>同时从性能的角度来说，建议使用$.data()来进行set和get操作，因为它仅仅修改的 Jquey对象 的属性值，不会引起额外的DOM操作。 </li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>mybatis chose when条件的坑</title>
      <link href="/2018/03/15/DB/mybatis-chose-when%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%9D%91.html"/>
      <url>/2018/03/15/DB/mybatis-chose-when%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<p>在使用mybatis 条件判断的时候，我们最常用的是: </p><ol><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        and title = #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"content != null"</span>&gt;</span></span><br><span class="line">        and content = #&#123;content&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        and owner = "owner1"</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><p>在编码中 我们一般习惯用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125; elseif()&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中chose when otherwise等同于上面<br>看下面一段Mybatis代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"isThird == '0'"</span>&gt;</span></span><br><span class="line">        xxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"isThird == '1'"</span>&gt;</span></span><br><span class="line">       xxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    xxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>不知道你有没有发现问题。对，上面代码在执行的时候死活进不去when条件，这时我们可能会说没问题啊，一定是参数传错了……<br>当MyBatis 判断条件为等于的时候，常量需要加 .toString() 来转换，这种方法是稳定的，推荐使用！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis单个key存储的value很大</title>
      <link href="/2018/03/09/%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%8D%95%E4%B8%AAkey%E5%AD%98%E5%82%A8%E7%9A%84value%E5%BE%88%E5%A4%A7.html"/>
      <url>/2018/03/09/%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%8D%95%E4%B8%AAkey%E5%AD%98%E5%82%A8%E7%9A%84value%E5%BE%88%E5%A4%A7.html</url>
      
        <content type="html"><![CDATA[<p>Redis使用过程中经常会有各种大key的情况， 比如：</p><ul><li>单个简单的key存储的value很大</li><li>hash， set，zset，list 中存储过多的元素（以万为单位）<br>由于redis是单线程运行的，如果一次操作的value很大会对整个redis的响应时间造成负面影响，所以，业务上能拆则拆，下面举几个典型的分拆方案。<a id="more"></a><h3 id="1-单个简单的key存储的value很大"><a href="#1-单个简单的key存储的value很大" class="headerlink" title="1. 单个简单的key存储的value很大"></a>1. 单个简单的key存储的value很大</h3><h4 id="1-1-改对象需要每次都整存整取"><a href="#1-1-改对象需要每次都整存整取" class="headerlink" title="1.1 改对象需要每次都整存整取"></a>1.1 改对象需要每次都整存整取</h4>可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；    </li></ul><h4 id="1-2-该对象每次只需要存取部分数据"><a href="#1-2-该对象每次只需要存取部分数据" class="headerlink" title="1.2 该对象每次只需要存取部分数据"></a>1.2 该对象每次只需要存取部分数据</h4><p>可以像第一种做法一样，分拆成几个key-value，  也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性    </p><h3 id="2-hash、set、zset、list-中存储过多的元素"><a href="#2-hash、set、zset、list-中存储过多的元素" class="headerlink" title="2. hash、set、zset、list 中存储过多的元素"></a>2. hash、set、zset、list 中存储过多的元素</h3><p>类似于场景一种的第一个做法，可以将这些元素分拆。</p><p>以hash为例，原先的正常存取流程是  hget(hashKey, field) ; hset(hashKey, field, value)<br>现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newHashKey  =  hashKey + (*hash*(field) % <span class="number">10000</span>）;   </span><br><span class="line">hset (newHashKey, field, value) ;  </span><br><span class="line">hget(newHashKey, field)</span><br></pre></td></tr></table></figure></p><p>set, zset, list 也可以类似上述做法.</p><p>但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis常见问题</title>
      <link href="/2018/03/09/%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
      <url>/2018/03/09/%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1. 分布式锁"></a>1. 分布式锁</h3><p>说道Redis分布式锁，我们的第一印象就是setnx操作。<br>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。但是在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？<br><a id="more"></a><br>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><ul><li>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</li><li>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</li><li>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</li><li>XX ：只在键已经存在时，才对键进行设置操作。<br>所以set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用！<br>参考：<a href="http://redisdoc.com/string/set.html" target="_blank" rel="noopener">http://redisdoc.com/string/set.html</a></li></ul><h3 id="2-无阻塞取数据"><a href="#2-无阻塞取数据" class="headerlink" title="2. 无阻塞取数据"></a>2. 无阻塞取数据</h3><ul><li>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</li></ul><p>一般人会说：使用keys指令可以扫出指定模式的key列表。</p><ul><li>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</li></ul><p>因为redis的单线程的,keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="3-大量的key同一时间过期"><a href="#3-大量的key同一时间过期" class="headerlink" title="3. 大量的key同一时间过期"></a>3. 大量的key同一时间过期</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h3 id="4-Redis做持久化"><a href="#4-Redis做持久化" class="headerlink" title="4. Redis做持久化"></a>4. Redis做持久化</h3><ul><li>Redis如何做持久化的？</li></ul><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><ul><li>如果突然机器掉电会怎样？</li></ul><p>取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><ul><li>bgsave的原理是什么？</li></ul><p>fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tomcat特殊字符报400（The valid characters are defined in RFC 7230 and RFC 3986）</title>
      <link href="/2018/03/07/%E8%BF%90%E7%BB%B4/Tomcat%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%8A%A5400.html"/>
      <url>/2018/03/07/%E8%BF%90%E7%BB%B4/Tomcat%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%8A%A5400.html</url>
      
        <content type="html"><![CDATA[<p>Tomcat在 7.0.73, 8.0.39, 8.5.7 等版本后(详情：<a href="https://stackoverflow.com/questions/41053653/tomcat-8-is-not-able-to-handle-get-request-with-in-query-parameters/44005213#44005213)，添加了对于http头的验证,就是添加了些规则去限制HTTP头的规范性(详情：http://www.jianshu.com/p/1c870461fa41)" target="_blank" rel="noopener">https://stackoverflow.com/questions/41053653/tomcat-8-is-not-able-to-handle-get-request-with-in-query-parameters/44005213#44005213)，添加了对于http头的验证,就是添加了些规则去限制HTTP头的规范性(详情：http://www.jianshu.com/p/1c870461fa41)</a><br><a id="more"></a></p><ul><li><p>报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.coyote.http11.Http11Processor.service Error parsing HTTP request header</span><br><span class="line"> Note: further occurrences of HTTP header parsing errors will be logged at DEBUG level.</span><br><span class="line"> java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986</span><br></pre></td></tr></table></figure></li><li><p>根据rfc规范（RFC 3986规范定义了Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符(RFC3986中指定了以下字符为保留字符：! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ])）。</p></li><li>url中不允许有 |，{，}等特殊字符，但在实际生产中还是有些url有可能携带有这些字符，特别是|还是较为常见的。在tomcat升级到7以后，对url字符的检查都变严格了，如果出现这类字符，tomcat将直接返回400状态码。</li></ul><ul><li><p>修改tomcat的配置，在catalina.properties添加下面的配置，重启服务器即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat.util.http.parser.HttpParser.requestTargetAllow=|&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>tomcat官方说明<br><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/systemprops.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-7.0-doc/config/systemprops.html</a>;<br><a href="https://tomcat.apache.org/tomcat-8.5-doc/config/systemprops.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/systemprops.html</a></p></li><li><p>源码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_CONTROL[i] || i &gt; <span class="number">127</span> ||</span><br><span class="line">                i == <span class="string">' '</span> || i == <span class="string">'\"'</span> || i == <span class="string">'#'</span> || i == <span class="string">'&lt;'</span> || i == <span class="string">'&gt;'</span> || i == <span class="string">'\\'</span> ||</span><br><span class="line">                i == <span class="string">'^'</span> || i == <span class="string">'`'</span>  || i == <span class="string">'&#123;'</span> || i == <span class="string">'|'</span> || i == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">            IS_NOT_REQUEST_TARGET[i] = <span class="keyword">true</span>;  <span class="comment">// reject the character!</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Jedis在高并发报错 (java.net.SocketException: Connection reset by peer: socket write error)</title>
      <link href="/2018/01/17/java/%E4%BD%BF%E7%94%A8Jedis%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8A%A5%E9%94%99-java-net-SocketException-Connection-reset-by-peer-socket-write-error.html"/>
      <url>/2018/01/17/java/%E4%BD%BF%E7%94%A8Jedis%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8A%A5%E9%94%99-java-net-SocketException-Connection-reset-by-peer-socket-write-error.html</url>
      
        <content type="html"><![CDATA[<p>Connection reset by peer: socket write error错误分析：<br>常出现的Connection reset by peer: 原因可能是多方面的，不过更常见的原因是：<br>①：服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉；<br>②：客户关掉了浏览器，而服务器还在给客户端发送数据；<br>③：浏览器端按了Stop<br><a id="more"></a></p><h4 id="1-报错信息"><a href="#1-报错信息" class="headerlink" title="1.报错信息"></a>1.报错信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.InvocationTargetException: null</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">at java.lang.reflect.Method.invoke(Unknown Source)</span><br><span class="line">....</span><br><span class="line">at java.lang.Thread.run(Unknown Source)</span><br><span class="line">Caused by: redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketException: Connection reset by peer: socket write error</span><br><span class="line">at redis.clients.jedis.Connection.flush(Connection.java:334)</span><br><span class="line">at redis.clients.jedis.Connection.getBinaryBulkReply(Connection.java:257)</span><br><span class="line">at redis.clients.jedis.BinaryJedis.get(BinaryJedis.java:244)</span><br><span class="line">......</span><br><span class="line">... 15 common frames omitted</span><br><span class="line">Caused by: java.net.SocketException: Connection reset by peer: socket write error</span><br><span class="line">at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">at java.net.SocketOutputStream.socketWrite(Unknown Source)</span><br><span class="line">at java.net.SocketOutputStream.write(Unknown Source)</span><br><span class="line">at redis.clients.util.RedisOutputStream.flushBuffer(RedisOutputStream.java:52)</span><br><span class="line">at redis.clients.util.RedisOutputStream.flush(RedisOutputStream.java:216)</span><br><span class="line">at redis.clients.jedis.Connection.flush(Connection.java:331)</span><br><span class="line">... 22 common frames omitted</span><br></pre></td></tr></table></figure><p> 所以本问题是由 ①造成的</p><h4 id="2-修改之前的代码"><a href="#2-修改之前的代码" class="headerlink" title="2.修改之前的代码"></a>2.修改之前的代码</h4><p> 初始化jedis的代码<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在多线程环境同步初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">poolInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">         createJedisPool();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">* 获取一个jedis 对象</span><br><span class="line">  *</span><br><span class="line">  * <span class="meta">@return</span></span><br><span class="line">  */</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">         poolInit();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> pool.getResource();</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p> 使用jedis的代码<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Jedis jedis = JedisPoolUtil.getJedis();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(exists(key))&#123;</span><br><span class="line">          <span class="keyword">return</span> deserialize(jedis.get(key.getBytes()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-修改之后的代码"><a href="#3-修改之后的代码" class="headerlink" title="3.修改之后的代码"></a>3.修改之后的代码</h4><p> 初始化jedis的代码<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个jedis 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        poolInit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有以下代码会造成初始化的jedis拿不到 jedis对象</span></span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis = pool.getResource();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"获取redis失败 : &#123;&#125;"</span> + ExceptionUtils.getStackTrace(e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jedis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 使用jedis的代码</p><pre><code class="java"><span class="comment">/**</span><span class="comment">    * 读取对象</span><span class="comment">    *</span><span class="comment">    * <span class="doctag">@param</span> key</span><span class="comment">    * <span class="doctag">@return</span></span><span class="comment">    */</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getObject</span><span class="params">(String key)</span> </span>{       <span class="keyword">if</span> (exists(key)) {           <span class="comment">//初始化jedis用完之后关闭连接</span>           Jedis jedis = JedisPoolUtil.getJedis();           Object object = deserialize(jedis.get(key.getBytes()));           jedis.close();           <span class="keyword">return</span> object;       }       <span class="keyword">return</span> <span class="keyword">null</span>;   }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> jedis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring AOP中pointcut expression表达式解析 及匹配多个条件</title>
      <link href="/2018/01/15/java/Spring-AOP%E4%B8%ADpointcut-expression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90-%E5%8F%8A%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6.html"/>
      <url>/2018/01/15/java/Spring-AOP%E4%B8%ADpointcut-expression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90-%E5%8F%8A%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-AOP中pointcut-expression表达式解析-及匹配多个条件"><a href="#Spring-AOP中pointcut-expression表达式解析-及匹配多个条件" class="headerlink" title="Spring AOP中pointcut expression表达式解析 及匹配多个条件"></a>Spring AOP中pointcut expression表达式解析 及匹配多个条件</h2><p>任意公共方法的执行：<br>　　execution(public <em> </em>(..))<br>任何一个以“set”开始的方法的执行：<br>　　execution(<em> set</em>(..))<br>AccountService 接口的任意方法的执行：<br>　　execution(<em> com.xyz.service.AccountService.</em>(..))<br>定义在service包里的任意方法的执行：<br>　　execution(<em> com.xyz.service.</em>.<em>(..))<br>定义在service包和所有子包里的任意类的任意方法的执行：<br>　　execution(</em> com.xyz.service..<em>.</em>(..))<br>定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：<br>　　execution(<em> com.test.spring.aop.pointcutexp..JoinPointObjP2.</em>(..))”)<br>在多个表达式之间使用 ||,or表示 或，使用 &amp;&amp;,and表示 与，！表示 非.例如：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)&quot;)</span><br></pre></td></tr></table></figure></p><p>execution 用于匹配方法执行的连接点;<br>@within :使用 “@within(注解类型)” 匹配所以持有指定注解类型内的方法;注解类型也必须是全限定类型名;<br>@annotation :使用 “@annotation(注解类型)” 匹配当前执行方法持有指定注解的方法;注解类型也必须是全限定类型名;<br>@args 任何一个只接受一个参数的方法,且方法运行时传入的参数持有注解动态切入点,类似于 arg 指示符;<br>@target 任何目标对象持有 Secure 注解的类方法;必须是在目标对象上声明这个注解,在接口上声明的对它不起作用<br>@args :使用 “@args( 注解列表 )” 匹配当前执行的方法传入的参数持有指定注解的执行;注解类型也必须是全限定类型名;</p>]]></content>
      
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm参数配置笔记</title>
      <link href="/2018/01/15/java/jvm%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0.html"/>
      <url>/2018/01/15/java/jvm%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、堆设置（这里是重点）"><a href="#1、堆设置（这里是重点）" class="headerlink" title="1、堆设置（这里是重点）"></a>1、堆设置（这里是重点）</h3><p>-Xms:初始堆大小<br>-Xmx:最大堆大小<br>-XX:NewSize=n:设置年轻代初始大小<br>-XX:MaxNewSize=n设置年轻代最大大小<br>-Xmn:相当于-XX:NewSize和-XX:MaxNewSize设置为同一个值了，表示永久设置年轻代的大小。当然剩下的就是老年代咯。<br><a id="more"></a><br>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4<br>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</p><h3 id="2、方法区设置-重点"><a href="#2、方法区设置-重点" class="headerlink" title="2、方法区设置(重点)"></a>2、方法区设置(重点)</h3><p>-XX:PermSize=n：设置永久代初始大小<br>-XX:MaxPermSize=n:设置永久代最大大小</p><h3 id="3、收集器设置（java支持多种垃圾收集器，当然你或许连收集器的概念也不知道，赶紧看书去吧）"><a href="#3、收集器设置（java支持多种垃圾收集器，当然你或许连收集器的概念也不知道，赶紧看书去吧）" class="headerlink" title="3、收集器设置（java支持多种垃圾收集器，当然你或许连收集器的概念也不知道，赶紧看书去吧）"></a>3、收集器设置（java支持多种垃圾收集器，当然你或许连收集器的概念也不知道，赶紧看书去吧）</h3><p>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器</p><h3 id="4、垃圾回收统计信息（这个可以用于调试时候查看GC的情况）"><a href="#4、垃圾回收统计信息（这个可以用于调试时候查看GC的情况）" class="headerlink" title="4、垃圾回收统计信息（这个可以用于调试时候查看GC的情况）"></a>4、垃圾回收统计信息（这个可以用于调试时候查看GC的情况）</h3><p>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</p><h3 id="5、并行收集器设置"><a href="#5、并行收集器设置" class="headerlink" title="5、并行收集器设置"></a>5、并行收集器设置</h3><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p><h3 id="6、并发收集器设置"><a href="#6、并发收集器设置" class="headerlink" title="6、并发收集器设置"></a>6、并发收集器设置</h3><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p><h3 id="7、栈区设置（一般甚少用到，放最后）"><a href="#7、栈区设置（一般甚少用到，放最后）" class="headerlink" title="7、栈区设置（一般甚少用到，放最后）"></a>7、栈区设置（一般甚少用到，放最后）</h3><p>-Xss：每个线程的Stack大小，“-Xss 15120” 这使每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k. </p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka集群搭建步骤</title>
      <link href="/2018/01/12/%E8%BF%90%E7%BB%B4/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html"/>
      <url>/2018/01/12/%E8%BF%90%E7%BB%B4/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载kafka-scale编译版本不同，有不同的选择"><a href="#1-下载kafka-scale编译版本不同，有不同的选择" class="headerlink" title="1. 下载kafka(scale编译版本不同，有不同的选择)"></a>1. 下载kafka(scale编译版本不同，有不同的选择)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.apache.org/dyn/closer.cgi?path=/kafka/1.0.0/kafka_2.11-1.0.0.tgz</span><br><span class="line"><span class="comment">### 解压</span></span><br><span class="line">tar zxvf kafka_2.11-1.0.0.tgz</span><br><span class="line"><span class="comment">### 切换到kafka目录创建日志目录</span></span><br><span class="line"><span class="built_in">cd</span> kafka_2.11-1.0.0</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-配置server-properties"><a href="#2-配置server-properties" class="headerlink" title="2. 配置server.properties"></a>2. 配置<code>server.properties</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> config</span><br><span class="line">vi server.properties</span><br></pre></td></tr></table></figure><p>修改配置文件(按需修改)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 当前机器在集群中的唯一标识，和zookeeper的myid性质一样</span><br><span class="line">broker.id=0  </span><br><span class="line"># 当前kafka对外提供服务的端口默认是9092</span><br><span class="line"># port=9092 </span><br><span class="line"># 参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。</span><br><span class="line"># host.name=192.168.188.111 </span><br><span class="line">listeners=PLAINTEXT://192.168.188.111:9092</span><br><span class="line"># borker进行网络处理的线程数</span><br><span class="line">num.network.threads=3 </span><br><span class="line"># borker进行I/O处理的线程数</span><br><span class="line">num.io.threads=8 </span><br><span class="line"># 消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个</span><br><span class="line">log.dirs=/opt/microServer/kafka_2.11-1.0.0/logs</span><br><span class="line"># 发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能</span><br><span class="line">socket.send.buffer.bytes=102400 </span><br><span class="line"># kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘</span><br><span class="line">socket.receive.buffer.bytes=102400 </span><br><span class="line"> # 向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line"># 默认的分区数，一个topic默认1个分区数</span><br><span class="line">num.partitions=1</span><br><span class="line"># 默认消息的最大持久化时间，168小时，7天</span><br><span class="line">log.retention.hours=168</span><br><span class="line"># 消息保存的最大值5M</span><br><span class="line">message.max.byte=5242880  </span><br><span class="line"># kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务</span><br><span class="line">default.replication.factor=2 </span><br><span class="line"># 取消息的最大直接数 </span><br><span class="line">replica.fetch.max.bytes=5242880  </span><br><span class="line"># kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件</span><br><span class="line">log.segment.bytes=1073741824 </span><br><span class="line"># 每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除</span><br><span class="line">log.retention.check.interval.ms=300000 </span><br><span class="line"># 是否启用log压缩，一般不用启用，启用的话可以提高性能</span><br><span class="line">log.cleaner.enable=false</span><br><span class="line"># 设置zookeeper的连接端口</span><br><span class="line">zookeeper.connect=192.168.188.111:2181,192.168.188.112:2181,192.168.188.113:2181</span><br></pre></td></tr></table></figure></p><h3 id="3-启动Kafka集群并测试（zk开启）"><a href="#3-启动Kafka集群并测试（zk开启）" class="headerlink" title="3. 启动Kafka集群并测试（zk开启）"></a>3. 启动Kafka集群并测试（zk开启）</h3><ul><li><p>启动服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入kafka bin目录</span><br><span class="line"><span class="comment">##后台守护启动</span></span><br><span class="line">bin]<span class="comment"># ./kafka-server-start.sh -daemon ../config/server.properties</span></span><br></pre></td></tr></table></figure></li><li><p>检查服务是否启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jps</span></span><br><span class="line">2241 QuorumPeerMain</span><br><span class="line">3236 Jps</span><br><span class="line">3100 Kafka</span><br></pre></td></tr></table></figure></li><li><p>创建Topic来验证是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin]<span class="comment"># ./kafka-topics.sh --create --zookeeper 192.168.188.112:2181 --replication-factor 2 --partitions 1 --topic test</span></span><br><span class="line"><span class="comment">#创建一个broker，发布者</span></span><br><span class="line">bin]<span class="comment"># ./kafka-console-producer.sh --broker-list 192.168.188.112:9092 --topic test2</span></span><br><span class="line"><span class="string">''</span><span class="string">'在一台服务器上创建一个订阅者'</span><span class="string">''</span></span><br><span class="line">bin]<span class="comment"># ./kafka-console-consumer.sh --zookeeper 192.168.188.112:2181 --topic test2 --from-beginning</span></span><br></pre></td></tr></table></figure></li></ul><p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## server1</span><br><span class="line">bin]# ./kafka-console-producer.sh --broker-list 192.168.188.112:9092 --topic test2</span><br><span class="line">&gt;werwe</span><br><span class="line">&gt;hahaha</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">##server2 </span><br><span class="line">bin]# ./kafka-console-consumer.sh --zookeeper 192.168.188.112:2181 --topic test2 --from-beginning</span><br><span class="line">Using the ConsoleConsumer with old consumer is deprecated and will be removed in a future major release. Consider using the new consumer by passing [bootstrap-server] instead of [zookeeper].</span><br><span class="line">werwe</span><br><span class="line">hahaha</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zookeeper集群搭建步骤</title>
      <link href="/2018/01/01/%E8%BF%90%E7%BB%B4/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html"/>
      <url>/2018/01/01/%E8%BF%90%E7%BB%B4/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html</url>
      
        <content type="html"><![CDATA[<ul><li>zookeeper服务器的数量是 <code>2*n+1</code>台<h2 id="zookeeper集群搭建步骤"><a href="#zookeeper集群搭建步骤" class="headerlink" title="zookeeper集群搭建步骤"></a>zookeeper集群搭建步骤</h2>本人下载目录为 /opt/microServer/ 集群ip为192.168.188.111、192.168.188.112、192.168.188.113<h3 id="1-下载zookeeper"><a href="#1-下载zookeeper" class="headerlink" title="1. 下载zookeeper"></a>1. 下载zookeeper</h3>执行命令下载<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</span><br><span class="line">tar -zxvf zookeeper-3.4.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zookeeper-3.4.11</span><br><span class="line"><span class="comment">## 创建 data和log文件夹</span></span><br><span class="line">mkdir data <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="2-进入conf文件夹，配置zookeeper"><a href="#2-进入conf文件夹，配置zookeeper" class="headerlink" title="2. 进入conf文件夹，配置zookeeper"></a>2. 进入conf文件夹，配置zookeeper</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line">cp zoo_sample.cfg  zoo.cfg</span><br></pre></td></tr></table></figure><h3 id="3-编辑zoo-cf文件"><a href="#3-编辑zoo-cf文件" class="headerlink" title="3. 编辑zoo.cf文件"></a>3. 编辑zoo.cf文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">## tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</span><br><span class="line">tickTime=2000</span><br><span class="line">## initLimit： 这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒</span><br><span class="line">initLimit=10</span><br><span class="line">## syncLimit：这个配置项标识 Leader 与Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是5*2000=10秒</span><br><span class="line">syncLimit=5</span><br><span class="line">## dataDir：快照日志的存储路径</span><br><span class="line">dataDir=/opt/microServer/zookeeper-3.4.11/data</span><br><span class="line">## dataLogDir：事物日志的存储路径，如果不配置这个那么事物日志会默认存储到dataDir制定的目录，这样会严重影响zk的性能，当zk吞吐量较大的时候，产生的事物日志、快照日志太多</span><br><span class="line">dataLogDir=/opt/microServer/zookeeper-3.4.11/log</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=192.168.188.111:12888:13888</span><br><span class="line">server.2=192.168.188.112:12888:13888</span><br><span class="line">server.3=192.168.188.113:12888:13888</span><br><span class="line">#server.1 这个1是服务器的标识也可以是其他的数字， 表示这个是第几号服务器，用来标识服务器，这个标识要写到快照目录下面myid文件里</span><br><span class="line">#192.168.188.111为集群里的IP地址，第一个端口是master和slave之间的通信端口，默认是2888，第二个端口是leader选举的端口，集群刚启动的时候选举或者leader挂掉之后进行新的选举的端口默认是3888</span><br></pre></td></tr></table></figure><h3 id="4-复制zookeeper到其他机器"><a href="#4-复制zookeeper到其他机器" class="headerlink" title="4.复制zookeeper到其他机器"></a>4.复制zookeeper到其他机器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r zookeeper-3.4.11/ root@192.168.188.112:/opt/microServer/</span><br><span class="line">scp -r zookeeper-3.4.11/ root@192.168.188.113:/opt/microServer/</span><br></pre></td></tr></table></figure><h3 id="4-创建myid文件"><a href="#4-创建myid文件" class="headerlink" title="4. 创建myid文件"></a>4. 创建myid文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /opt/microServer/zookeeper-3.4.11/data/myid</span><br><span class="line"><span class="comment">#server2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2"</span> &gt; /opt/microServer/zookeeper-3.4.11/data/myid</span><br><span class="line"><span class="comment">#server3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3"</span> &gt; /opt/microServer/zookeeper-3.4.11/data/myid</span><br></pre></td></tr></table></figure><h3 id="启动服务并查看-可以在-etc-profile配置zk"><a href="#启动服务并查看-可以在-etc-profile配置zk" class="headerlink" title="启动服务并查看(可以在/etc/profile配置zk)"></a>启动服务并查看(可以在/etc/profile配置zk)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入到Zookeeper的bin目录下</span></span><br><span class="line"><span class="built_in">cd</span> /opt/zookeeper/zookeeper-3.4.6/bin</span><br><span class="line"><span class="comment">#启动服务（3台都需要操作）</span></span><br><span class="line">./zkServer.sh start</span><br><span class="line"><span class="comment">#检查服务器状态</span></span><br><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3353177-5f3aa2c07079af7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br><img src="http://upload-images.jianshu.io/upload_images/3353177-79931c930bf42288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br><img src="http://upload-images.jianshu.io/upload_images/3353177-ab82da0571ad20f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="*注意事项："></a>*注意事项：</h3><p>如果zkServer.sh status出现以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">]# zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/microserver/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Error contacting service. It is probably not running.</span><br></pre></td></tr></table></figure></p><p>到 /root/zookeeper.out看报错信息。如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> [myid:1] - WARN  [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:2181:Learner@237] - Unexpected exception, tries=0, connecting to /192.168.188.113:12888</span><br><span class="line">java.net.ConnectException: 拒绝连接 (Connection refused)</span><br><span class="line">at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">at org.apache.zookeeper.server.quorum.Learner.connectToLeader(Learner.java:229)</span><br><span class="line">at org.apache.zookeeper.server.quorum.Follower.followLeader(Follower.java:72)</span><br><span class="line">at org.apache.zookeeper.server.quorum.QuorumPeer.run(QuorumPeer.java:981)</span><br><span class="line">2018-01-14 20:35:45,726 [myid:1] - INFO  [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:2181:Learner@332] - Getting a diff from the leader 0x0</span><br></pre></td></tr></table></figure></p><p>这种情况需要关闭防火墙,执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br><span class="line">firewall-cmd --state <span class="comment">#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 集群 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[转载]关于垃圾回收被误解的 7 件事</title>
      <link href="/2017/12/30/java/%E8%BD%AC%E8%BD%BD-%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84-7-%E4%BB%B6%E4%BA%8B.html"/>
      <url>/2017/12/30/java/%E8%BD%AC%E8%BD%BD-%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84-7-%E4%BB%B6%E4%BA%8B.html</url>
      
        <content type="html"><![CDATA[<h5 id="对Java垃圾回收最大的误解是什么？它实际又是什么样的呢？"><a href="#对Java垃圾回收最大的误解是什么？它实际又是什么样的呢？" class="headerlink" title="对Java垃圾回收最大的误解是什么？它实际又是什么样的呢？"></a>对Java垃圾回收最大的误解是什么？它实际又是什么样的呢？</h5><p>当我还是小孩的时候，父母常说如果你不好好学习，就只能去扫大街了。但他们不知道的是，清理垃圾实际上是很棒的一件事。可能这也是即使在Java的世界中， 同样有很多开发者对GC算法产生误解的原因——包括它们怎样工作、GC是如何影响程序运行和你能对它做些什么。因此我们找到了Java性能调优专家<a href="https://twitter.com/lifeyx" target="_blank" rel="noopener">Haim Yadid</a>，并把名为<a href="http://blog.takipi.com/java-performance-tuning-how-to-get-the-most-out-of-your-garbage-collector/?utm_source=blog&amp;utm_medium=in-post&amp;utm_content=gcmisconceptions&amp;utm_campaign=java" target="_blank" rel="noopener">Java performance tuning guide</a>的文章发表在Takipi的博客上。<br><a id="more"></a><br>最新博文：关于垃圾回收被误解的7件事<br><a href="http://t.co/3QJLJuKCRq" target="_blank" rel="noopener">http://t.co/3QJLJuKCRq</a><a href="http://www.importnew.com/pic.twitter.com/aqQEF0zTkK" target="_blank" rel="noopener">pic.twitter.com/aqQEF0zTkK</a><br>— Takipi (@takipid) April 6, 2015</p><p>带着对性能调优指南浓厚的兴趣，我们决定在这篇后续的博文中收集一些关于垃圾回收的流行观点，并且指出为什么它们完全是错误的。</p><p>来看看前7名：</p><h3 id="1-只有一个垃圾回收器"><a href="#1-只有一个垃圾回收器" class="headerlink" title="1. 只有一个垃圾回收器"></a>1. 只有一个垃圾回收器</h3><p>不，并且4也是错误的答案。HotSpot JVM一共有4个垃圾回收器：<a href="http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/?utm_source=blog&amp;utm_medium=in-post&amp;utm_content=gcmisconceptions&amp;utm_campaign=java" target="_blank" rel="noopener">Serial, Parallel / Throughput. CMS, and the new kid on the block G1</a>。别急，另外还有一些非标准的垃圾回收器和更大胆的实现，比如<a href="http://openjdk.java.net/jeps/189" target="_blank" rel="noopener">Shenandoah</a>或 者其他JVM使用的回收器（C4——Azul开发的无停顿回收器）。HotSpot默认使用Parallel / Throughput回收器，但它常常不是你运行程序的最佳选择。比如CMS和G1会使GC停顿（GC pause）发生的频率降低，但是对于每次停顿所花费的时间，很可能比Parallel回收器更长。另一方面来说，在使用相同大小堆内存的情况下，Parallel回收器能带来更高的吞吐量。</p><p><strong>结论：</strong>根据你的需求（可接受的GC停顿频率和持续时间）选择合适的垃圾回收器。</p><h3 id="2-并行（Parallel）-＝-并发（Concurrent）"><a href="#2-并行（Parallel）-＝-并发（Concurrent）" class="headerlink" title="2. 并行（Parallel） ＝ 并发（Concurrent）"></a>2. 并行（Parallel） ＝ 并发（Concurrent）</h3><p>一个GC周期（Garbage Collection cycle）可以以STW（Stop-The-World）的形式出现，这会发生一次GC停顿，也可以并发地执行从而无需暂停应用程序。更进一步来 讲，GC算法本身可以是串行的（单线程），也可以是并行的（多线程）。因此当我们提到并发的GC时，并不代表它是并行完成的，相反当提到串行GC时，也并 不意味着就一定会出现GC停顿。在GC的世界中，并发和并行是两个完全不同的概念。并发针对的是GC周期，而并行针对GC算法自身。</p><p><strong>结论：</strong>垃圾回收的过程实际上有两步，启动GC周期和GC自身运行，这是不同的两件事。</p><h3 id="3-G1能解决所有问题"><a href="#3-G1能解决所有问题" class="headerlink" title="3. G1能解决所有问题"></a>3. G1能解决所有问题</h3><p>经过一系列修正和改 进，Java 7中引入了G1回收器，它是JVM垃圾回收器中最新的组件。G1最大的优势就是解决了CMS中常见的内存碎片问题：GC周期会从老年代（Old Generation）中释放内存块，结果内存变得像瑞士奶酪那样千疮百孔，直到JVM对其无从下手了，才不得不停下来处理这些碎片。但是故事没这么简 单，某些情况下其他回收器可能比G1有更好的表现，这完全取决于你的需求。</p><p><strong>结论：</strong>没有一个奇迹般的回收器能解决所有GC问题，你应该通过具体实验来选择合适的回收器。</p><h3 id="4-平均事务时间是最需要被关注的指标"><a href="#4-平均事务时间是最需要被关注的指标" class="headerlink" title="4. 平均事务时间是最需要被关注的指标"></a>4. 平均事务时间是最需要被关注的指标</h3><p>如 果你仅仅监控服务器的平均事务时间，那么很可能错过一些异常值。这些异常的情况可能对用户来说是毁灭性的，而人们没有意识到它的重要性。比如一个事务在正常情况下耗时100ms，但受到GC停顿的影响，花了1分钟才完成。除了用户没人会注意到这个问题，因为你只观察了平均事务时间。试想有1%或者更多的用 户经历了这个场景，如果只关注平均值，它就太容易被忽略了。想了解更多和延迟相关的问题和怎样正确处理，可以在<a href="http://latencytipoftheday.blogspot.com/" target="_blank" rel="noopener">这里</a>阅读<a href="https://twitter.com/giltene" target="_blank" rel="noopener">Gil Tene</a>的博客。</p><p><strong>结论：</strong>留心那些异常值，你可以知道系统最后那1%的状况。（<a href="http://cdn.zmescience.com/wp-content/uploads/2014/04/Who-Is-The-1.jpg" target="_blank" rel="noopener">可不是这个1%</a>）</p><h3 id="5-降低新对象的分配率可以改善GC的运行状况"><a href="#5-降低新对象的分配率可以改善GC的运行状况" class="headerlink" title="5. 降低新对象的分配率可以改善GC的运行状况"></a>5. 降低新对象的分配率可以改善GC的运行状况</h3><p>我们可以 粗略地把系统中的对象分为三种：长命（long-lived）对象，对它们我们一般做不了什么；中等寿命（mid-lived）对象，最大的问题可能出现在这；短命（short-lived）对象，它们的释放和回收通常都很快，在下个GC周期来临时就会消失。专注于中等寿命对象的分配率可以带来有益的结 果，这对短命和长命的对象却不是那么有效。另外，控制中等寿命对象往往是一项困难的工作。</p><p><strong>结论：</strong>给服务器带来压力的并不单纯是对象的分配率，在运行过程中这些对象的种类才是一切麻烦的根源。</p><h3 id="6-调优可以解决所有事"><a href="#6-调优可以解决所有事" class="headerlink" title="6. 调优可以解决所有事"></a>6. 调优可以解决所有事</h3><p>如果你的程序需要保存大量被频繁修改的状态，对JVM堆内存进行调优就无法带来很好的收益。较长的GC停顿是不可避免的。一个解决办 法是对架构进行改善，保证一个对响应时间有决定性影响或者造成瓶颈的过程中，不包含大量状态。大量状态和响应能力是难以良好共存的，因此将它们分开处理才 是上上之选。</p><p><strong>结论：</strong>不是所有的问题都可以通过调整JVM参数解决，有时你只需要回顾自己的绘图板。</p><p>（译注：重新审视程序的设计）</p><h3 id="7-GC日志会导致巨大的系统开销"><a href="#7-GC日志会导致巨大的系统开销" class="headerlink" title="7. GC日志会导致巨大的系统开销"></a>7. GC日志会导致巨大的系统开销</h3><p>简单来说，这是错的，尤 其在默认的日志配置下。日志数据是极为有价值的，Java 7中还引入了钩子来控制它们的大小，保证硬盘空间不被用尽。如果不收集GC日志，那么你会失去这几乎是唯一的，知晓JVM垃圾回收器在生产环境中工作状态 的方法。一般可接受的GC开销以5%作为上限，如果你能知道系统为GC停顿付出的代价，也能对最小化这个代价采取行动，这种程度的开销是不值一提的。</p><p><strong>结论：</strong>在能力范围内，尽可能多地获取系统在生产环境中的运行数据，你会发现那是一个全新的世界。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望上面的结论能帮助你们更好地把握Java垃圾回收器的工作。在你们的程序中出现过类似问题吗？你们周围还有没有其他对GC常见的误解？请在下面的评论区留言。</p><p>原文链接：</p><p> <a href="http://www.javacodegeeks.com/2015/04/7-things-you-thought-you-knew-about-garbage-collection-and-are-totally-wrong.html" target="_blank" rel="noopener">javacodegeeks</a> </p><p>翻译：</p><p> <a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew.com</a> </p><p>-</p><p> <a href="http://www.importnew.com/author/jiangshengwu" target="_blank" rel="noopener">蒋 生武</a></p><p>译文链接：</p><p> <a href="http://www.importnew.com/15796.html" target="_blank" rel="noopener">http://www.importnew.com/15796.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hashmap为什么在发生hash冲突后把元素放在链表的头部？</title>
      <link href="/2017/12/30/java/hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%8F%91%E7%94%9Fhash%E5%86%B2%E7%AA%81%E5%90%8E%E6%8A%8A%E5%85%83%E7%B4%A0%E6%94%BE%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E9%83%A8%EF%BC%9F.html"/>
      <url>/2017/12/30/java/hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%8F%91%E7%94%9Fhash%E5%86%B2%E7%AA%81%E5%90%8E%E6%8A%8A%E5%85%83%E7%B4%A0%E6%94%BE%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E9%83%A8%EF%BC%9F.html</url>
      
        <content type="html"><![CDATA[<p>有回答说是因为最后放入的元素会被再次操作的机会很大，所以放在头部，提高再次获取的效率，这个解释不能让人信服。 其实，仔细想想如果不放在头部，放在尾部或其它位置，是不是需要遍历，找到指定位置，如果链表的长度很长，性能会很低，反而不如放在链表的头部高效。 我个人觉得也不尽然，存放一个尾部地址也是分分钟钟的事，实现起来也不复杂，我还是比较倾向于第一种考虑，开发作者就是有这样的认知或统计:插入的数据被马上访问的概率也就越大。有没有其他的解释？</p>]]></content>
      
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一次线上数据库添加字段造成磁盘不够的问题</title>
      <link href="/2017/12/30/DB/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5%E9%80%A0%E6%88%90%E7%A3%81%E7%9B%98%E4%B8%8D%E5%A4%9F%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
      <url>/2017/12/30/DB/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5%E9%80%A0%E6%88%90%E7%A3%81%E7%9B%98%E4%B8%8D%E5%A4%9F%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司使用的是MySQL数据库，随着业务和用户的增加有张表的数据达到了150000000（1亿5千万）条左右，其中好几个功能都会对这张表进行增删改操作。在并发量比较大的时候，经常会出现死锁问题。<br>为了解决这个问题找到CTO和其他领导来请教方案。<br><a id="more"></a><br>经过分析之后，由于离业务繁忙期还有几天，并且1月是系统达到最大并发的时期，所以决定暂时先采取比较稳妥的版本号方案，即只往数据库insert和update数据，定时任务删除旧的数据（之后会采取数据分表分区的方案）版本号记录在redis里面。于是花了2天左右的时间把这些业务里面的代码重构和修改了一遍（其中涉及到使用第三方库修改的代码，修改这部分花了很多时间）。经测试人员测试没问题后，准备发到线上。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>要刷入得的SQL如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> K_VERSION <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>;</span><br></pre></td></tr></table></figure></p><p>17年12月29日凌晨左右，运维开始执行sql。到1点多的时候，运维说数据库所在的服务器硬盘满了，导致刷入失败。里面有人开始议论说，不就是刷入字段吗，怎么会造成磁盘满呢？运维当时立马通过阿里云德后台把数据库的服务器磁盘增大。当时我的第一反应：肯定这个SQL在表数据量大的时候会有问题。搜索之后发现，当数据量很大的时候，会占大量的undo空间，同时还会锁表。所以要想解决问题必须分开执行sql 最后执行sql如下:<br> 第一步:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> K_VERSION <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">COMMENT</span> <span class="string">'版本</span></span><br></pre></td></tr></table></figure></p><p>  第二步:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">MODIFY</span>(K_VERSION  <span class="keyword">DEFAULT</span> <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>第三步:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> XXX <span class="keyword">set</span> K_VERSION=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>之后也没有出现刷sql挂服务器的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java获取服务器所有信息</title>
      <link href="/2017/11/01/java/java%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF.html"/>
      <url>/2017/11/01/java/java%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF.html</url>
      
        <content type="html"><![CDATA[<p>java获取服务器所有信息代码如下<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line">package com.sinosoft.outher.listener;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.hyperic.sigar.CpuInfo;</span><br><span class="line">import org.hyperic.sigar.CpuPerc;</span><br><span class="line">import org.hyperic.sigar.FileSystem;</span><br><span class="line">import org.hyperic.sigar.FileSystemUsage;</span><br><span class="line">import org.hyperic.sigar.Mem;</span><br><span class="line">import org.hyperic.sigar.NetFlags;</span><br><span class="line">import org.hyperic.sigar.NetInterfaceConfig;</span><br><span class="line">import org.hyperic.sigar.NetInterfaceStat;</span><br><span class="line">import org.hyperic.sigar.OperatingSystem;</span><br><span class="line">import org.hyperic.sigar.Sigar;</span><br><span class="line">import org.hyperic.sigar.SigarException;</span><br><span class="line">import org.hyperic.sigar.Swap;</span><br><span class="line">import org.hyperic.sigar.Who;</span><br><span class="line">public class SysListener &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // System信息，从jvm获取</span><br><span class="line">            property();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // cpu信息</span><br><span class="line">            cpu();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 内存信息</span><br><span class="line">            memory();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 操作系统信息</span><br><span class="line">            os();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 用户信息</span><br><span class="line">            who();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 文件系统信息</span><br><span class="line">            file();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 网络信息</span><br><span class="line">            net();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 以太网信息</span><br><span class="line">            ethernet();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">        &#125; catch (Exception e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void property() throws UnknownHostException &#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        Properties props = System.getProperties();</span><br><span class="line">        InetAddress addr;</span><br><span class="line">        addr = InetAddress.getLocalHost();</span><br><span class="line">        String ip = addr.getHostAddress();</span><br><span class="line">        Map&lt;String, String&gt; map = System.getenv();</span><br><span class="line">        String userName = map.get(&quot;USERNAME&quot;);// 获取用户名</span><br><span class="line">        String computerName = map.get(&quot;COMPUTERNAME&quot;);// 获取计算机名</span><br><span class="line">        String userDomain = map.get(&quot;USERDOMAIN&quot;);// 获取计算机域名</span><br><span class="line">        System.out.println(&quot;用户名:    &quot; + userName);</span><br><span class="line">        System.out.println(&quot;计算机名:    &quot; + computerName);</span><br><span class="line">        System.out.println(&quot;计算机域名:    &quot; + userDomain);</span><br><span class="line">        System.out.println(&quot;本地ip地址:    &quot; + ip);</span><br><span class="line">        System.out.println(&quot;本地主机名:    &quot; + addr.getHostName());</span><br><span class="line">        System.out.println(&quot;JVM可以使用的总内存:    &quot; + r.totalMemory());</span><br><span class="line">        System.out.println(&quot;JVM可以使用的剩余内存:    &quot; + r.freeMemory());</span><br><span class="line">        System.out.println(&quot;JVM可以使用的处理器个数:    &quot; + r.availableProcessors());</span><br><span class="line">        System.out.println(&quot;Java的运行环境版本：    &quot; + props.getProperty(&quot;java.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java的运行环境供应商：    &quot; + props.getProperty(&quot;java.vendor&quot;));</span><br><span class="line">        System.out.println(&quot;Java供应商的URL：    &quot; + props.getProperty(&quot;java.vendor.url&quot;));</span><br><span class="line">        System.out.println(&quot;Java的安装路径：    &quot; + props.getProperty(&quot;java.home&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机规范版本：    &quot; + props.getProperty(&quot;java.vm.specification.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机规范供应商：    &quot; + props.getProperty(&quot;java.vm.specification.vendor&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机规范名称：    &quot; + props.getProperty(&quot;java.vm.specification.name&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机实现版本：    &quot; + props.getProperty(&quot;java.vm.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机实现供应商：    &quot; + props.getProperty(&quot;java.vm.vendor&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机实现名称：    &quot; + props.getProperty(&quot;java.vm.name&quot;));</span><br><span class="line">        System.out.println(&quot;Java运行时环境规范版本：    &quot; + props.getProperty(&quot;java.specification.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java运行时环境规范供应商：    &quot; + props.getProperty(&quot;java.specification.vender&quot;));</span><br><span class="line">        System.out.println(&quot;Java运行时环境规范名称：    &quot; + props.getProperty(&quot;java.specification.name&quot;));</span><br><span class="line">        System.out.println(&quot;Java的类格式版本号：    &quot; + props.getProperty(&quot;java.class.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java的类路径：    &quot; + props.getProperty(&quot;java.class.path&quot;));</span><br><span class="line">        System.out.println(&quot;加载库时搜索的路径列表：    &quot; + props.getProperty(&quot;java.library.path&quot;));</span><br><span class="line">        System.out.println(&quot;默认的临时文件路径：    &quot; + props.getProperty(&quot;java.io.tmpdir&quot;));</span><br><span class="line">        System.out.println(&quot;一个或多个扩展目录的路径：    &quot; + props.getProperty(&quot;java.ext.dirs&quot;));</span><br><span class="line">        System.out.println(&quot;操作系统的名称：    &quot; + props.getProperty(&quot;os.name&quot;));</span><br><span class="line">        System.out.println(&quot;操作系统的构架：    &quot; + props.getProperty(&quot;os.arch&quot;));</span><br><span class="line">        System.out.println(&quot;操作系统的版本：    &quot; + props.getProperty(&quot;os.version&quot;));</span><br><span class="line">        System.out.println(&quot;文件分隔符：    &quot; + props.getProperty(&quot;file.separator&quot;));</span><br><span class="line">        System.out.println(&quot;路径分隔符：    &quot; + props.getProperty(&quot;path.separator&quot;));</span><br><span class="line">        System.out.println(&quot;行分隔符：    &quot; + props.getProperty(&quot;line.separator&quot;));</span><br><span class="line">        System.out.println(&quot;用户的账户名称：    &quot; + props.getProperty(&quot;user.name&quot;));</span><br><span class="line">        System.out.println(&quot;用户的主目录：    &quot; + props.getProperty(&quot;user.home&quot;));</span><br><span class="line">        System.out.println(&quot;用户的当前工作目录：    &quot; + props.getProperty(&quot;user.dir&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void memory() throws SigarException &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        Mem mem = sigar.getMem();</span><br><span class="line">        // 内存总量</span><br><span class="line">        System.out.println(&quot;内存总量:    &quot; + mem.getTotal() / 1024L + &quot;K av&quot;);</span><br><span class="line">        // 当前内存使用量</span><br><span class="line">        System.out.println(&quot;当前内存使用量:    &quot; + mem.getUsed() / 1024L + &quot;K used&quot;);</span><br><span class="line">        // 当前内存剩余量</span><br><span class="line">        System.out.println(&quot;当前内存剩余量:    &quot; + mem.getFree() / 1024L + &quot;K free&quot;);</span><br><span class="line">        Swap swap = sigar.getSwap();</span><br><span class="line">        // 交换区总量</span><br><span class="line">        System.out.println(&quot;交换区总量:    &quot; + swap.getTotal() / 1024L + &quot;K av&quot;);</span><br><span class="line">        // 当前交换区使用量</span><br><span class="line">        System.out.println(&quot;当前交换区使用量:    &quot; + swap.getUsed() / 1024L + &quot;K used&quot;);</span><br><span class="line">        // 当前交换区剩余量</span><br><span class="line">        System.out.println(&quot;当前交换区剩余量:    &quot; + swap.getFree() / 1024L + &quot;K free&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void cpu() throws SigarException &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        CpuInfo infos[] = sigar.getCpuInfoList();</span><br><span class="line">        CpuPerc cpuList[] = null;</span><br><span class="line">        cpuList = sigar.getCpuPercList();</span><br><span class="line">        for (int i = 0; i &lt; infos.length; i++) &#123;// 不管是单块CPU还是多CPU都适用</span><br><span class="line">            CpuInfo info = infos[i];</span><br><span class="line">            System.out.println(&quot;第&quot; + (i + 1) + &quot;块CPU信息&quot;);</span><br><span class="line">            System.out.println(&quot;CPU的总量MHz:    &quot; + info.getMhz());// CPU的总量MHz</span><br><span class="line">            System.out.println(&quot;CPU生产商:    &quot; + info.getVendor());// 获得CPU的卖主，如：Intel</span><br><span class="line">            System.out.println(&quot;CPU类别:    &quot; + info.getModel());// 获得CPU的类别，如：Celeron</span><br><span class="line">            System.out.println(&quot;CPU缓存数量:    &quot; + info.getCacheSize());// 缓冲存储器数量</span><br><span class="line">            printCpuPerc(cpuList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printCpuPerc(CpuPerc cpu) &#123;</span><br><span class="line">        System.out.println(&quot;CPU用户使用率:    &quot; + CpuPerc.format(cpu.getUser()));// 用户使用率</span><br><span class="line">        System.out.println(&quot;CPU系统使用率:    &quot; + CpuPerc.format(cpu.getSys()));// 系统使用率</span><br><span class="line">        System.out.println(&quot;CPU当前等待率:    &quot; + CpuPerc.format(cpu.getWait()));// 当前等待率</span><br><span class="line">        System.out.println(&quot;CPU当前错误率:    &quot; + CpuPerc.format(cpu.getNice()));//</span><br><span class="line">        System.out.println(&quot;CPU当前空闲率:    &quot; + CpuPerc.format(cpu.getIdle()));// 当前空闲率</span><br><span class="line">        System.out.println(&quot;CPU总的使用率:    &quot; + CpuPerc.format(cpu.getCombined()));// 总的使用率</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void os() &#123;</span><br><span class="line">        OperatingSystem OS = OperatingSystem.getInstance();</span><br><span class="line">        // 操作系统内核类型如： 386、486、586等x86</span><br><span class="line">        System.out.println(&quot;操作系统:    &quot; + OS.getArch());</span><br><span class="line">        System.out.println(&quot;操作系统CpuEndian():    &quot; + OS.getCpuEndian());//</span><br><span class="line">        System.out.println(&quot;操作系统DataModel():    &quot; + OS.getDataModel());//</span><br><span class="line">        // 系统描述</span><br><span class="line">        System.out.println(&quot;操作系统的描述:    &quot; + OS.getDescription());</span><br><span class="line">        // 操作系统类型</span><br><span class="line">        // System.out.println(&quot;OS.getName():    &quot; + OS.getName());</span><br><span class="line">        // System.out.println(&quot;OS.getPatchLevel():    &quot; + OS.getPatchLevel());//</span><br><span class="line">        // 操作系统的卖主</span><br><span class="line">        System.out.println(&quot;操作系统的卖主:    &quot; + OS.getVendor());</span><br><span class="line">        // 卖主名称</span><br><span class="line">        System.out.println(&quot;操作系统的卖主名:    &quot; + OS.getVendorCodeName());</span><br><span class="line">        // 操作系统名称</span><br><span class="line">        System.out.println(&quot;操作系统名称:    &quot; + OS.getVendorName());</span><br><span class="line">        // 操作系统卖主类型</span><br><span class="line">        System.out.println(&quot;操作系统卖主类型:    &quot; + OS.getVendorVersion());</span><br><span class="line">        // 操作系统的版本号</span><br><span class="line">        System.out.println(&quot;操作系统的版本号:    &quot; + OS.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void who() throws SigarException &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        Who who[] = sigar.getWhoList();</span><br><span class="line">        if (who != null &amp;&amp; who.length &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; who.length; i++) &#123;</span><br><span class="line">                // System.out.println(&quot;当前系统进程表中的用户名&quot; + String.valueOf(i));</span><br><span class="line">                Who _who = who[i];</span><br><span class="line">                System.out.println(&quot;用户控制台:    &quot; + _who.getDevice());</span><br><span class="line">                System.out.println(&quot;用户host:    &quot; + _who.getHost());</span><br><span class="line">                // System.out.println(&quot;getTime():    &quot; + _who.getTime());</span><br><span class="line">                // 当前系统进程表中的用户名</span><br><span class="line">                System.out.println(&quot;当前系统进程表中的用户名:    &quot; + _who.getUser());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;private static void file() throws Exception &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        FileSystem fslist[] = sigar.getFileSystemList();</span><br><span class="line">        for (int i = 0; i &lt; fslist.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;分区的盘符名称&quot; + i);</span><br><span class="line">            FileSystem fs = fslist[i];</span><br><span class="line">            // 分区的盘符名称</span><br><span class="line">            System.out.println(&quot;盘符名称:    &quot; + fs.getDevName());</span><br><span class="line">            // 分区的盘符名称</span><br><span class="line">            System.out.println(&quot;盘符路径:    &quot; + fs.getDirName());</span><br><span class="line">            System.out.println(&quot;盘符标志:    &quot; + fs.getFlags());//</span><br><span class="line">            // 文件系统类型，比如 FAT32、NTFS</span><br><span class="line">            System.out.println(&quot;盘符类型:    &quot; + fs.getSysTypeName());</span><br><span class="line">            // 文件系统类型名，比如本地硬盘、光驱、网络文件系统等</span><br><span class="line">            System.out.println(&quot;盘符类型名:    &quot; + fs.getTypeName());</span><br><span class="line">            // 文件系统类型</span><br><span class="line">            System.out.println(&quot;盘符文件系统类型:    &quot; + fs.getType());</span><br><span class="line">            FileSystemUsage usage = null;</span><br><span class="line">            switch (fs.getType()) &#123;</span><br><span class="line">            case 0: // TYPE_UNKNOWN ：未知</span><br><span class="line">                break;</span><br><span class="line">            case 1: // TYPE_NONE</span><br><span class="line">                break;</span><br><span class="line">            case 2: // TYPE_LOCAL_DISK : 本地硬盘</span><br><span class="line">                // 文件系统总大小</span><br><span class="line">            usage = sigar.getFileSystemUsage(fs.getDirName());</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;总大小:    &quot; + usage.getTotal() + &quot;KB&quot;);</span><br><span class="line">                // 文件系统剩余大小</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;剩余大小:    &quot; + usage.getFree() + &quot;KB&quot;);</span><br><span class="line">                // 文件系统可用大小</span><br><span class="line">System.out.println(fs.getDevName() + &quot;可用大小: &quot; + usage.getAvail() + &quot;KB&quot;);</span><br><span class="line">                // 文件系统已经使用量</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;已经使用量:    &quot; + usage.getUsed() + &quot;KB&quot;);</span><br><span class="line">                double usePercent = usage.getUsePercent() * 100D;</span><br><span class="line">                // 文件系统资源的利用率</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;资源的利用率:    &quot; + usePercent + &quot;%&quot;);</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;读出：    &quot; + usage.getDiskReads());</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;写入：    &quot; + usage.getDiskWrites());</span><br><span class="line">                break;</span><br><span class="line">            case 3:// TYPE_NETWORK ：网络</span><br><span class="line">                break;</span><br><span class="line">            case 4:// TYPE_RAM_DISK ：闪存</span><br><span class="line">                break;</span><br><span class="line">            case 5:// TYPE_CDROM ：光驱</span><br><span class="line">                break;</span><br><span class="line">            case 6:// TYPE_SWAP ：页面交换</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void net() throws Exception &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        String ifNames[] = sigar.getNetInterfaceList();</span><br><span class="line">        for (int i = 0; i &lt; ifNames.length; i++) &#123;</span><br><span class="line">            String name = ifNames[i];</span><br><span class="line">            NetInterfaceConfig ifconfig = sigar.getNetInterfaceConfig(name);</span><br><span class="line">            System.out.println(&quot;网络设备名:    &quot; + name);// 网络设备名</span><br><span class="line">            System.out.println(&quot;IP地址:    &quot; + ifconfig.getAddress());// IP地址</span><br><span class="line">            System.out.println(&quot;子网掩码:    &quot; + ifconfig.getNetmask());// 子网掩码</span><br><span class="line">            if ((ifconfig.getFlags() &amp; 1L) &lt;= 0L) &#123;</span><br><span class="line">                System.out.println(&quot;!IFF_UP...skipping getNetInterfaceStat&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            NetInterfaceStat ifstat = sigar.getNetInterfaceStat(name);</span><br><span class="line">            System.out.println(name + &quot;接收的总包裹数:&quot; + ifstat.getRxPackets());// 接收的总包裹数</span><br><span class="line">            System.out.println(name + &quot;发送的总包裹数:&quot; + ifstat.getTxPackets());// 发送的总包裹数</span><br><span class="line">            System.out.println(name + &quot;接收到的总字节数:&quot; + ifstat.getRxBytes());// 接收到的总字节数</span><br><span class="line">            System.out.println(name + &quot;发送的总字节数:&quot; + ifstat.getTxBytes());// 发送的总字节数</span><br><span class="line">            System.out.println(name + &quot;接收到的错误包数:&quot; + ifstat.getRxErrors());// 接收到的错误包数</span><br><span class="line">            System.out.println(name + &quot;发送数据包时的错误数:&quot; + ifstat.getTxErrors());// 发送数据包时的错误数</span><br><span class="line">            System.out.println(name + &quot;接收时丢弃的包数:&quot; + ifstat.getRxDropped());// 接收时丢弃的包数</span><br><span class="line">            System.out.println(name + &quot;发送时丢弃的包数:&quot; + ifstat.getTxDropped());// 发送时丢弃的包数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void ethernet() throws SigarException &#123;</span><br><span class="line">        Sigar sigar = null;</span><br><span class="line">        sigar = new Sigar();</span><br><span class="line">        String[] ifaces = sigar.getNetInterfaceList();</span><br><span class="line">        for (int i = 0; i &lt; ifaces.length; i++) &#123;</span><br><span class="line">            NetInterfaceConfig cfg = sigar.getNetInterfaceConfig(ifaces[i]);</span><br><span class="line">            if (NetFlags.LOOPBACK_ADDRESS.equals(cfg.getAddress()) (cfg.getFlags() &amp; NetFlags.IFF_LOOPBACK) != 0</span><br><span class="line">                    NetFlags.NULL_HWADDR.equals(cfg.getHwaddr())) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(cfg.getName() + &quot;IP地址:&quot; + cfg.getAddress());// IP地址</span><br><span class="line">            System.out.println(cfg.getName() + &quot;网关广播地址:&quot; + cfg.getBroadcast());// 网关广播地址</span><br><span class="line">            System.out.println(cfg.getName() + &quot;网卡MAC地址:&quot; + cfg.getHwaddr());// 网卡MAC地址</span><br><span class="line">            System.out.println(cfg.getName() + &quot;子网掩码:&quot; + cfg.getNetmask());// 子网掩码</span><br><span class="line">            System.out.println(cfg.getName() + &quot;网卡描述信息:&quot; + cfg.getDescription());// 网卡描述信息</span><br><span class="line">            System.out.println(cfg.getName() + &quot;网卡类型&quot; + cfg.getType());//</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title> Spring AOP获取请求URL的入参及返回值(通用方法)</title>
      <link href="/2017/10/26/java/Spring-AOP%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82URL%E7%9A%84%E5%85%A5%E5%8F%82%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html"/>
      <url>/2017/10/26/java/Spring-AOP%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82URL%E7%9A%84%E5%85%A5%E5%8F%82%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>以下代码为通用的代码，其中json解析使用的是fastJson，可以记录用户访问的ip、url、入参和出参<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author jasonLu</span><br><span class="line"> * @date 2017/10/26 9:57</span><br><span class="line"> * @Description:获取请求的入参和出参</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class RequestAspect &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RequestAspect.class);</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)&quot;)</span><br><span class="line">    public void pointcut()</span><br><span class="line">    &#123;</span><br><span class="line">        // 空方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Around(&quot;pointcut()&quot;)</span><br><span class="line">    public Object handle(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        //IP地址</span><br><span class="line">        String ipAddr = getRemoteHost(request);</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        String reqParam = preHandle(joinPoint,request);</span><br><span class="line">        logger.info(&quot;请求源IP:【&#123;&#125;】,请求URL:【&#123;&#125;】,请求参数:【&#123;&#125;】&quot;,ipAddr,url,reqParam);</span><br><span class="line"></span><br><span class="line">        Object result= joinPoint.proceed();</span><br><span class="line">        String respParam = postHandle(result);</span><br><span class="line">        logger.info(&quot;请求源IP:【&#123;&#125;】,请求URL:【&#123;&#125;】,返回参数:【&#123;&#125;】&quot;,ipAddr,url,respParam);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入参数据</span><br><span class="line">     * @param joinPoint</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String preHandle(ProceedingJoinPoint joinPoint,HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        String reqParam = &quot;&quot;;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method targetMethod = methodSignature.getMethod();</span><br><span class="line">        Annotation[] annotations = targetMethod.getAnnotations();</span><br><span class="line">        for (Annotation annotation : annotations) &#123;</span><br><span class="line">            //此处可以改成自定义的注解</span><br><span class="line">            if (annotation.annotationType().equals(RequestMapping.class)) &#123;</span><br><span class="line">                reqParam = JSON.toJSONString(request.getParameterMap());</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return reqParam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回数据</span><br><span class="line">     * @param retVal</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String postHandle(Object retVal) &#123;</span><br><span class="line">        if(null == retVal)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return JSON.toJSONString(retVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取目标主机的ip</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String getRemoteHost(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;0:0:0:0:0:0:0:1&quot;.equals(ip) ? &quot;127.0.0.1&quot; : ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;context:component-scan&gt; 配置 —— 分库遇到问题（1）</title>
      <link href="/2017/07/26/java/context-component-scan-%E9%85%8D%E7%BD%AE-%E2%80%94%E2%80%94-%E5%88%86%E5%BA%93%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%881%EF%BC%89.html"/>
      <url>/2017/07/26/java/context-component-scan-%E9%85%8D%E7%BD%AE-%E2%80%94%E2%80%94-%E5%88%86%E5%BA%93%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%881%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>项目中 springMvc的部分配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:annotation /&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;xxx&quot;&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.RestController&quot; /&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></p><p>相信有些人看到我贴出来的配置就知道我要说明什么问题了，如果你还是没有头绪的话，可以看下我遇到的问题。<br><a id="more"></a><br>这个配置文件本来是想要扫描 xxx包下面的Controller和 RestControl注解，看起来并没有什么问题。我无意中一次测试发现某些service被初始化了两次！这跟spring中的单例模式是相悖的。并且一个service在spring根容器和springMvc容器分别初始化一次，导致在根容器初始化的Service里面的dubbo的 @Reference无法注入。<br>于是开始排查错误：除了dubbo:annotation是本人加的，其他的配置都是已经存在的。当时知道肯定是配置文件出了问题，但是不知道具体是哪里。问了公司的其他人员还是没有找到根本原因，经过反复排除并且在spring的官方文档发现了问题的根源。</p><h3 id="spring官方给的解释如下"><a href="#spring官方给的解释如下" class="headerlink" title="spring官方给的解释如下:"></a>spring官方给的解释如下:</h3><blockquote><p>The following example shows the configuration ignoring all @Repository annotations and using “stub” repositories instead.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;org.example&quot;,</span><br><span class="line">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span><br><span class="line">        excludeFilters = @Filter(Repository.class))</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>and the equivalent using XML<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;</span><br><span class="line">        &lt;context:include-filter type=&quot;regex&quot;</span><br><span class="line">                expression=&quot;.*Stub.*Repository&quot;/&gt;</span><br><span class="line">        &lt;context:exclude-filter type=&quot;annotation&quot;</span><br><span class="line">                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;</span><br><span class="line">    &lt;/context:component-scan&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>[Note]<br>You can also disable the default filters by setting useDefaultFilters=false on the annotation or providing use-default-filters=”false” as an attribute of the <component-scan> element. This will in effect disable automatic detection of classes annotated with @Component, @Repository, @Service, @Controller, or @Configuration.</component-scan></p><p>所以通过官方的描述可以看出原来是<component-scan>使用错误导致的。也就是说如果想让项目中的<a href="context:include-filter/" target="_blank" rel="noopener">context:include-filter/</a>生效就必须要加use-default-filters=”false” 否则 spring还是会扫描包下面的以下注解 @Component, @Repository, @Service, @Controller, or @Configuration.</component-scan></p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;dubbo:annotation &gt;配置 —— 分库遇到问题（2）</title>
      <link href="/2017/07/26/java/dubbo-annotation-%E9%85%8D%E7%BD%AE-%E2%80%94%E2%80%94-%E5%88%86%E5%BA%93%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%882%EF%BC%89.html"/>
      <url>/2017/07/26/java/dubbo-annotation-%E9%85%8D%E7%BD%AE-%E2%80%94%E2%80%94-%E5%88%86%E5%BA%93%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%882%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>在上篇笔记《<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a> 配置 —— 分库遇到问题（1）》中解决了 spring中某些实例被初始化了两次的问题，<br>但是紧接着又来了另一个头疼的问题，dubbo的@Reference为null无法注入 ！<br>Controller层的注解正常！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:annotation /&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;xxx&quot; use-default-filters=&quot;false&quot;&gt;</span><br><span class="line">&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;</span><br><span class="line">&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.RestController&quot; /&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>我把这个问题提出来之后，大家都提出来，在dubbo的service或者spring还没有初始化完成之前就开始扫描 @Reference导致取到null值。但是怎么去找到问题的根源呢？<br>于是几个人在一块排查，刚开始是修改spring的配置文件。把有关扫描的配置重新检查了一下，并没有发现问题。网上查关于dubbo初始化的资料，依然没有发现解决问题的方法！<br>查询无果后，开始往源码上面去研究。<br>我始终在想，之前dubbo使用没有问题的，就在我昨天加了use-default-filters=”false”才出现的这个问题，所以我围绕着 context:component-scan + dubbo:annotation寻找答案，其中一条结果是指向 Dubbo的官方文档。如下：</p><blockquote><p>服务提供方注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line">@Service(version=&quot;1.0.0&quot;)</span><br><span class="line">public class FooServiceImpl implements FooService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>服务提供方配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 公共信息，也可以用dubbo.properties配置 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;annotation-provider&quot; /&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;127.0.0.1:4548&quot; /&gt;</span><br><span class="line">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span><br><span class="line">&lt;dubbo:annotation package=&quot;com.foo.bar.service&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>服务消费方注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class BarAction &#123;</span><br><span class="line">    @Reference(version=&quot;1.0.0&quot;)</span><br><span class="line">    private FooService fooService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务消费方配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 公共信息，也可以用dubbo.properties配置 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;annotation-consumer&quot; /&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;127.0.0.1:4548&quot; /&gt;</span><br><span class="line">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span><br><span class="line">&lt;dubbo:annotation package=&quot;com.foo.bar.action&quot; /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="也可以使用：-等价于前面的：-lt-dubbo-annotation-package-”com-foo-bar-service”-gt"><a href="#也可以使用：-等价于前面的：-lt-dubbo-annotation-package-”com-foo-bar-service”-gt" class="headerlink" title="也可以使用：(等价于前面的：&lt;dubbo:annotation package=”com.foo.bar.service” /&gt;)"></a>也可以使用：(等价于前面的：&lt;dubbo:annotation package=”com.foo.bar.service” /&gt;)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:annotation /&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.foo.bar.service&quot;&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;com.alibaba.dubbo.config.annotation.Service&quot; /&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><p>从官方给的样例找到了问题产生的原因。dubbo:annotation不指定包名的话会在spring bean中查找对应实例的类配置了dubbo注解的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo Filter 传递上下文环境信息</title>
      <link href="/2017/07/26/java/Dubbo-Filter-%E4%BC%A0%E9%80%92%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF.html"/>
      <url>/2017/07/26/java/Dubbo-Filter-%E4%BC%A0%E9%80%92%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF.html</url>
      
        <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>一般dubbo的service层都是一些通用的，无状态的服务。但是在某些特殊的需求下，需要传递一些上下文环境,打个不恰当的比方，例如需要在每次调用dubbo的服务的时候，记录一下用户名或者需要知道sessionid等。<br><a id="more"></a></p><h3 id="解决办法1"><a href="#解决办法1" class="headerlink" title="解决办法1"></a>解决办法1</h3><p>如果是在项目设计的时候就意识到这一点的话，就好办，把所有的dubbo服务请求的参数都封装一个公共的父类，把一些上下文环境在放在父类的属性中。<br><img src="http://upload-images.jianshu.io/upload_images/3353177-4178b9514ef69d51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这样做的好处就是，dubbo接口的参数都统一的，在Dubbo中可以做一些统一的处理（例如把上下文环境取出来，放在ThreadLocal中）。</p><h4 id="解决办法2"><a href="#解决办法2" class="headerlink" title="解决办法2"></a>解决办法2</h4><p>但是并不是所有的项目一开始就有这个需求的，但是突然有一天他猝不及防的出现了（比如本人就接到要使用多数据，每次前端请求的时候根据参数选择使用的数据库），如果项目已经基本定型的情况下，再改造成上面的解决办法，改动量太大（不怕麻烦的也可以，但是本人就比较懒）。<br>其实Dubbo的文档中已经有这个解决办法，就是隐式传参，<br><a href="http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-%E9%9A%90%E5%BC%8F%E4%BC%A0%E5%8F%82" target="_blank" rel="noopener">http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-%E9%9A%90%E5%BC%8F%E4%BC%A0%E5%8F%82</a><br>改造方案<br>代码如下</p><h4 id="DubboConsumer"><a href="#DubboConsumer" class="headerlink" title="DubboConsumer:"></a>DubboConsumer:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Activate(group = Constants.CONSUMER)</span><br><span class="line">public class DubboConsumerContextFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; attachments = new HashMap&lt;&gt;();</span><br><span class="line">        attachments.put(xxx, xxx);</span><br><span class="line">        attachments.put(xxx, xxx);</span><br><span class="line">        //设置需要的内容</span><br><span class="line">        RpcContext.getContext().setAttachments(attachments);</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DubboProvider："><a href="#DubboProvider：" class="headerlink" title="DubboProvider："></a>DubboProvider：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Activate(group = Constants.PROVIDER)</span><br><span class="line">public class DubboProviderContextFilter implements Filter &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        logger.info(&quot;DbProviderContextFilter attachments=&#123;&#125;&quot;, RpcContext.getContext().getAttachments());</span><br><span class="line"></span><br><span class="line">        String datasource = RpcContext.getContext().getAttachment(DbContextHolder.DATASOURCE_KEY);</span><br><span class="line">        String schema = RpcContext.getContext().getAttachment(DbContextHolder.SCHEMA_KEY);</span><br><span class="line">        if (StringUtils.isNotEmpty(datasource)) &#123;</span><br><span class="line">            DbContextHolder.setDatasource(datasource);</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isNotEmpty(schema)) &#123;</span><br><span class="line">            DbContextHolder.setSchema(schema);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在resources中创建文件<br>META-INF/dubbo/com.alibaba.dubbo.rpc.Filter</p><p>注意是 META-INF文件下的dubbo文件夹下的”com.alibaba.dubbo.rpc.Filter”文件<br><img src="http://upload-images.jianshu.io/upload_images/3353177-01d142b5d2ef144f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>并在里面加入,也就是第一步中创建的类的路径<br>dubboContextFilter=com.xxx.DubboContextFilter<br>第三步：在配置文件中加入<br>&lt;dubbo:provider filter=”dubboContextFilter” /&gt;</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h4><p>其实dubbo内置了一些filter，我们可以自定义自己的filter来完成一些和业务流程无关的逻辑，例如可以写IP白名单等等</p>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java异常小结</title>
      <link href="/2017/07/20/java/Java%E5%BC%82%E5%B8%B8%E5%B0%8F%E7%BB%93.html"/>
      <url>/2017/07/20/java/Java%E5%BC%82%E5%B8%B8%E5%B0%8F%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>题目：请聊一下，你对java异常的理解？区分一下运行时异常和一般异常有何异同？你在平时工作中遇到的异常类有哪些，详细说明一下这些异常是怎么产生的？</p><h3 id="1-Java异常的理解？"><a href="#1-Java异常的理解？" class="headerlink" title="1 Java异常的理解？"></a>1 Java异常的理解？</h3><p>异常主要处理编译期不能捕获的错误。出现问题时能继续顺利执行下去，而不导致程序终止。确保程序的健壮性。</p><p>处理过程：产生异常状态时，如果当前的context不具备处理当前异常的能力，将在heap上new出来一个异常对象，停止当前的执行路线，把产生的异常对象抛给更高层的context。<br><a id="more"></a><br>Throwable：异常类；Error ：系统异常；不能恢复；Exception ：普通异常；可恢复。</p><p>利用try／catch／finally来处理异常。</p><p>在你会到了上面的东西，有的面试官会问你什么时候用到finally呢？你应该这样回答，某些事物（除内存外）在异常处理完后需要恢复到原始状态，如：开启的文件，网络连接等。</p><h3 id="2-运行时异常和一般异常有何异同？"><a href="#2-运行时异常和一般异常有何异同？" class="headerlink" title="2 运行时异常和一般异常有何异同？"></a>2 运行时异常和一般异常有何异同？</h3><p>异常分为runtime exception和checked exception。</p><p>checked exception：java编译器强制要求catch此类异常，如io异常、sql异常。</p><p>runtime exception：不需要强制性处理，一旦出现异常，交由虚拟机接管。</p><h3 id="3-遇到的异常类有哪些-产生的原因？"><a href="#3-遇到的异常类有哪些-产生的原因？" class="headerlink" title="3 遇到的异常类有哪些?产生的原因？"></a>3 遇到的异常类有哪些?产生的原因？</h3><p>NullPointerException：空指针。</p><p>ArrayIndexOutOfBoundsException：数组越界。</p><p>IllegalArgumentException：参数非法。</p><p>BufferOverflowException：缓存溢出。</p><p>ClassNotFoundException：在编译时无法找到指定的类。</p><p>ClassCastException：类型强转。</p><p>ExceptionInInitializerError：静态初始值或静态变量初始值期间发生异常。</p><p>UnsatisfiedLinkError：JNI加载dll或者so文件时未找到。</p><p>NoClassDefFoundError：在编译时能找到合适的类，而在运行时不能找到合适的类。</p><p>上面说了这么多常见的异常类，下面咱们详细的聊一下OutOfMemoryError（内存溢出）这个异常。</p><h4 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a>产生的原因：</h4><ul><li><p>内存中加载的数据量过于庞大，如一次从数据库取出过多数据。</p></li><li><p>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。</p></li><li><p>代码中存在死循环或循环产生过多重复的对象实体。</p></li><li><p>使用的第三方软件中的BUG。</p></li><li><p>启动参数内存值设定的过小。</p></li></ul><h3 id="重点排查以下几点："><a href="#重点排查以下几点：" class="headerlink" title="重点排查以下几点："></a>重点排查以下几点：</h3><ul><li><p>1 检查代码中是否有死循环或递归调用。</p></li><li><p>2 检查是否有大循环重复产生新对象实体。</p></li><li><p>3 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p></li><li><p>4 检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</p></li><li><p>5 检查对大文件的读取是否采用类nio的方式。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> exception </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle恢复到某一个时间点</title>
      <link href="/2017/03/24/DB/Oracle%E6%81%A2%E5%A4%8D%E5%88%B0%E6%9F%90%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E7%82%B9.html"/>
      <url>/2017/03/24/DB/Oracle%E6%81%A2%E5%A4%8D%E5%88%B0%E6%9F%90%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flashback table tb_goods_sku to timestamp to_timestamp('2016-04-29 12:12:12','yyyy-mm-dd hh24:mi:ss');</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_goods_sku <span class="keyword">enable</span> <span class="keyword">row</span> <span class="keyword">movement</span>;</span><br></pre></td></tr></table></figure><p>操作数据库一不小心将很重要的数据删除了，找备份也没有，幸好Oracle有闪回的功能。<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flashback table pb_acc_user  to timestamp to_timestamp</span><br><span class="line">('2014-0315 09:30:00','yyyy-mm-dd hh24:mi:ss');</span><br></pre></td></tr></table></figure></p><p>提示ORA-08189: 因为未启用行移动功能, 不能闪回表 。一般来说出现这种错误，就是数据库表不支持闪回功能，修复很简单，开启即可。<br>所以执行以下语句 再执行闪回.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> pb_acc_user <span class="keyword">enable</span> <span class="keyword">row</span> <span class="keyword">movement</span>;</span><br></pre></td></tr></table></figure></p><p>成功闪回修改.</p>]]></content>
      
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mybatis传 ARRAY给Oracle存储过程</title>
      <link href="/2017/03/10/java/Mybatis%E4%BC%A0-ARRAY%E7%BB%99Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html"/>
      <url>/2017/03/10/java/Mybatis%E4%BC%A0-ARRAY%E7%BB%99Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-首先建立相关的存储过程，如图："><a href="#1-首先建立相关的存储过程，如图：" class="headerlink" title="1. 首先建立相关的存储过程，如图："></a>1. 首先建立相关的存储过程，如图：</h3><p><img src="http://upload-images.jianshu.io/upload_images/3353177-084719ab0ad30505.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br><a id="more"></a></p><h3 id="2-在service实现层填充参数-例如："><a href="#2-在service实现层填充参数-例如：" class="headerlink" title="2.在service实现层填充参数 例如："></a>2.在service实现层填充参数 例如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dto <span class="title">addFloorList</span><span class="params">(BannerRequest req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dto dto = <span class="keyword">new</span> Dto();</span><br><span class="line">List&lt;IndexFloor&gt; list = <span class="keyword">new</span> ArrayList&lt;IndexFloor&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">IndexFloor flr = <span class="keyword">new</span> IndexFloor();</span><br><span class="line">flr.setFloorId(i + <span class="number">3</span>);</span><br><span class="line">flr.setFloorTitle(<span class="string">"测试数据 "</span> + i + <span class="number">1</span>);</span><br><span class="line">flr.setFlrSort(i + <span class="number">1</span>);</span><br><span class="line">flr.setFlrCat(<span class="number">2</span>);</span><br><span class="line">list.add(flr);</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Object&gt; param = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">param.put(<span class="string">"id"</span>, <span class="number">2</span>);</span><br><span class="line">param.put(<span class="string">"floor_list"</span>, list);</span><br><span class="line"><span class="comment">//调用存储过程</span></span><br><span class="line">webMapper.spInsertInfo(param);</span><br><span class="line"><span class="keyword">int</span> rtnCode = (Integer) param.get(<span class="string">"rtnCode"</span>);</span><br><span class="line">String rtnMsg = String.valueOf(param.get(<span class="string">"rtnMsg"</span>));</span><br><span class="line">System.out.print(rtnCode + <span class="string">"------"</span> + rtnMsg);</span><br></pre></td></tr></table></figure><h3 id="3-编写工具类，用来处理Array参数："><a href="#3-编写工具类，用来处理Array参数：" class="headerlink" title="3.编写工具类，用来处理Array参数："></a>3.编写工具类，用来处理Array参数：</h3><p>  核心代码如下（详见附件中的 handler/ArrayHandler.java）:</p><p><img src="http://upload-images.jianshu.io/upload_images/3353177-0c0e8e0d9bfd65bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"></p><p>（注意：上图中的IndexFloor为测试bean。具体bean对象，根据需要编写）</p><h3 id="4-在MyBatis配置文件中，配置，handler为我们写好的工具类："><a href="#4-在MyBatis配置文件中，配置，handler为我们写好的工具类：" class="headerlink" title="4.在MyBatis配置文件中，配置，handler为我们写好的工具类："></a>4.在MyBatis配置文件中，配置<typehandlers>，handler为我们写好的工具类：</typehandlers></h3><p>配置代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 自定义传入参数类型(TypeHandler) --&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 如果没有在Handler中加注解，用第一个 --&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--&lt;typeHandler javaType="list" jdbcType="ARRAY" handler="cn.hao24.api.handler.ArrayHandler"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">javaType</span>=<span class="string">"list"</span> <span class="attr">handler</span>=<span class="string">"cn.hao24.api.handler.ArrayHandler"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="5-在Mapper-xml文件中调用存储过程并传参数："><a href="#5-在Mapper-xml文件中调用存储过程并传参数：" class="headerlink" title="5.在Mapper.xml文件中调用存储过程并传参数："></a>5.在Mapper.xml文件中调用存储过程并传参数：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"spInsertInfo"</span> <span class="attr">parameterType</span>=<span class="string">"Map"</span> <span class="attr">resultType</span>=<span class="string">"Map"</span> <span class="attr">statementType</span>=<span class="string">"CALLABLE"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> call TMP_LUJIE_TEST_ARRAY</span><br><span class="line"></span><br><span class="line"> (</span><br><span class="line"></span><br><span class="line"> #&#123;rtnCode,mode=OUT,jdbcType=INTEGER,javaType=Integer&#125;,</span><br><span class="line"></span><br><span class="line"> #&#123;rtnMsg,mode=OUT,jdbcType=VARCHAR,javaType=String&#125;,</span><br><span class="line"></span><br><span class="line"> #&#123;id,mode=IN,jdbcType=INTEGER,javaType=Integer&#125;,</span><br><span class="line"></span><br><span class="line"> **  #&#123;floor_list,jdbcType=ARRAY,javaType=list&#125;**</span><br><span class="line"></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6．调试代码。"><a href="#6．调试代码。" class="headerlink" title="6．调试代码。"></a>6．调试代码。</h3><p>参考资料：</p><p>1.how-to-pass-java-list-of-objects-to-oracle-stored-procedure-using-mybatis：</p><p><a href="http://stackoverflow.com/questions/12719689/how-to-pass-java-list-of-objects-to-oracle-stored-procedure-using-mybatis" target="_blank" rel="noopener">http://stackoverflow.com/questions/12719689/how-to-pass-java-list-of-objects-to-oracle-stored-procedure-using-mybatis</a></p><p>2. myBatis自定义传入参数类型(TypeHandler)</p><p><a href="http://jusesgod.iteye.com/blog/1740889" target="_blank" rel="noopener">http://jusesgod.iteye.com/blog/1740889</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>oracle 用interval 求时间</title>
      <link href="/2016/10/19/DB/oracle-%E7%94%A8interval-%E6%B1%82%E6%97%B6%E9%97%B4.html"/>
      <url>/2016/10/19/DB/oracle-%E7%94%A8interval-%E6%B1%82%E6%97%B6%E9%97%B4.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'20'</span> <span class="keyword">day</span> <span class="keyword">as</span> <span class="string">"20天前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'20'</span> <span class="keyword">hour</span> <span class="keyword">as</span> <span class="string">"20小时前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'20'</span> <span class="keyword">minute</span> <span class="keyword">as</span> <span class="string">"20分钟前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'20'</span> <span class="keyword">second</span> <span class="keyword">as</span> <span class="string">"20秒钟前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="number">20</span> <span class="keyword">as</span> <span class="string">"20天前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="number">20</span> / <span class="number">24</span> <span class="keyword">as</span> <span class="string">"20小时前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="number">20</span> / (<span class="number">24</span> * <span class="number">60</span>) <span class="keyword">as</span> <span class="string">"20分钟前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="number">20</span> / (<span class="number">24</span> * <span class="number">3600</span>) <span class="keyword">as</span> <span class="string">"20秒钟前"</span></span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure><p>这里的 interval表示某段时间,格式是: interval ‘时间’ ;</p><p>例如 interval ‘20’ day 表示20天</p>]]></content>
      
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
