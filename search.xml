<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>使用Spring Boot、Multipartfile上传文件路径错误问题</title>
      <link href="/2018/07/17/java/%E4%BD%BF%E7%94%A8Spring-Boot%E3%80%81Multipartfile%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98.html"/>
      <content type="html"><![CDATA[<h2 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h2><p>java.io.IOException: java.io.FileNotFoundException: /tmp/tomcat/…/tmp/files/xxx.jpg (No such file or directory)<br>问题源码： transferTo方法报错<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"/tmp/files/"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    multipartFile.transferTo(file);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>源码中文件定义的是相对路径，预期路径应该是项目路径/tmp/source/，但是报错确是一个系统临时文件路径（tomcat的）。<br>由于是transferTo方法报错，因此应该是该方法写入文件时报错，因此，我们跟入方法源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardMultipartHttpServletRequest</span> <span class="keyword">extends</span> <span class="title">AbstractMultipartHttpServletRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_DISPOSITION = <span class="string">"content-disposition"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILENAME_KEY = <span class="string">"filename="</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILENAME_WITH_CHARSET_KEY = <span class="string">"filename*="</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset US_ASCII = Charset.forName(<span class="string">"us-ascii"</span>);</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; multipartParameterNames;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardMultipartFile</span> <span class="keyword">implements</span> <span class="title">MultipartFile</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Part part;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String filename;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(File dest)</span> <span class="keyword">throws</span> IOException, IllegalStateException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.part.write(dest.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationPart</span> <span class="keyword">implements</span> <span class="title">Part</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="comment">// 问题在这里：如果文件不是绝对路径就重新创建！！</span></span><br><span class="line">        <span class="keyword">if</span> (!file.isAbsolute()) &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(<span class="keyword">this</span>.location, fileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.fileItem.write(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Servlet3.0的支持的上传文件功能时，如果我们没有使用绝对路径的话，transferTo方法会在相对路径前添加一个location路径，即：file = new File(location, fileName)，由于创建的File在项目路径/tmp/files/，而transferTo方法预期写入的文件路径为/tmp/tomcat/…/tmp/files/xxx.jpg，我们并没有创建该目录，因此会抛出异常。</p><h2 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h2><ul><li>1 使用绝对路径</li><li>2 修改location的值<br>这个location可以理解为临时文件目录，我们可以通过配置location的值，使其指向我们的项目路径，这样就解决了我们遇到的问题。<br>在Spring Boot下配置location，可以在main()方法所在文件中添加如下代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function">MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultipartConfigFactory factory = <span class="keyword">new</span> MultipartConfigFactory();</span><br><span class="line">    <span class="comment">//设置路径xxx</span></span><br><span class="line">    factory.setLocation(<span class="string">"/xxx"</span>);</span><br><span class="line">    <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Multipartfile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ELK+filebeat+kafka+zooKeeper搭建（单机版）</title>
      <link href="/2018/05/09/%E8%BF%90%E7%BB%B4/ELK-filebeat-kafka-zooKeeper%E6%90%AD%E5%BB%BA.html"/>
      <content type="html"><![CDATA[<p>本教程中使用的<code>ELK和filebeat</code>版本是 <code>6.2.4</code></p><h2 id="1-elk安装"><a href="#1-elk安装" class="headerlink" title="1. elk安装"></a>1. elk安装</h2><p>关于elk的配置参考我之前的一篇文章，不在累述：<br>elk安装地址：<br><a href="https://jjlu521016.github.io/2018/05/01/springboot-logback-log4j-elk.html#2-elk%E9%85%8D%E7%BD%AE">https://jjlu521016.github.io/2018/05/01/springboot-logback-log4j-elk.html#2-elk%E9%85%8D%E7%BD%AE</a><br><a id="more"></a></p><h2 id="2-kafka及zookeeper安装"><a href="#2-kafka及zookeeper安装" class="headerlink" title="2. kafka及zookeeper安装"></a>2. kafka及zookeeper安装</h2><p>参考我之前的文章、把对应的配置改成单机即可：</p><h3 id="2-1-安装kafka："><a href="#2-1-安装kafka：" class="headerlink" title="2.1. 安装kafka："></a>2.1. 安装kafka：</h3><p> <a href="https://jjlu521016.github.io/2018/01/12/%E8%BF%90%E7%BB%B4/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html#more">https://jjlu521016.github.io/2018/01/12/%E8%BF%90%E7%BB%B4/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html#more</a></p><h3 id="2-2-安装zookeeper："><a href="#2-2-安装zookeeper：" class="headerlink" title="2.2. 安装zookeeper："></a>2.2. 安装zookeeper：</h3><p><a href="https://jjlu521016.github.io/2018/01/01/%E8%BF%90%E7%BB%B4/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html#more">https://jjlu521016.github.io/2018/01/01/%E8%BF%90%E7%BB%B4/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html#more</a></p><h3 id="2-3-启动zookeeper"><a href="#2-3-启动zookeeper" class="headerlink" title="2.3 启动zookeeper"></a>2.3 启动zookeeper</h3><p>我本地zookeeper配置了环境变量<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure></p><h3 id="2-4-启动kafka"><a href="#2-4-启动kafka" class="headerlink" title="2.4 启动kafka"></a>2.4 启动kafka</h3><p>启动kafka<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-server-start.sh config/server.properties</span></span><br></pre></td></tr></table></figure></p><p>创建topic<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-topics.sh --create --zookeeper 192.168.188.110:2181 --replication-factor 1 --partitions 1 --topic test</span></span><br></pre></td></tr></table></figure></p><p>创建生产者<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-console-producer.sh --broker-list 192.168.188.110:9092 --topic test</span></span><br></pre></td></tr></table></figure></p><p>创建消费者<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper 192.168.188.110:2181 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure></p><p>此时生产者输入的内容可以在消费者输出，证明kafka调用通了。</p><h2 id="3-集成logstash与kafka"><a href="#3-集成logstash与kafka" class="headerlink" title="3. 集成logstash与kafka"></a>3. 集成logstash与kafka</h2><p>参考：<br><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html</a><br>vi logstash_agent.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    bootstrap_servers =&gt; &quot;192.168.188.110:9092&quot;</span><br><span class="line">    #topic id</span><br><span class="line">    topics =&gt; &quot;test&quot;</span><br><span class="line">    codec =&gt; &quot;json&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    json &#123;</span><br><span class="line">      source =&gt; &quot;message&quot;</span><br><span class="line">      remove_field =&gt; &quot;message&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch&#123;</span><br><span class="line">      hosts =&gt; [&quot;192.168.188.110:9200&quot;]</span><br><span class="line">    index =&gt; &quot;kafka-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动elk之后，在kafka生产者输入一条信息之后logstash打印出对应的内容，说明集成成功了<br>。在kibana设置对应的日志。</p><h2 id="4-安装filebeat"><a href="#4-安装filebeat" class="headerlink" title="4. 安装filebeat"></a>4. 安装filebeat</h2><p>解压<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf filebeat-6.2.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>配置filebeat.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.prospectors:</span></span><br><span class="line"><span class="comment"># 这里面配置实际的日志路径</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/test1.log</span></span><br><span class="line"><span class="attr">  fields:</span></span><br><span class="line"><span class="attr">    log_topics:</span> <span class="string">test1</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/test2.log</span></span><br><span class="line"><span class="attr">  fields:</span></span><br><span class="line"><span class="attr">    log_topics:</span> <span class="string">test2</span></span><br><span class="line"><span class="string">output.kafka:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["10.112.101.90:9092"]</span></span><br><span class="line"><span class="attr">  topic:</span> <span class="string">'<span class="template-variable">%&#123;[fields][log_topics]&#125;</span>'</span></span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -e -c filebeat.yml</span><br></pre></td></tr></table></figure></p><p>把logstash停止，修改配置文件，添加filebeat配置的topic。重启logstash。打开kibana刷新页面，看到filebeat收集到的日志。</p><p><img src="https://github.com/jjlu521016/myblog/blob/master/source/image/resource/kibana1.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springboot logback(log4j) elk 非集群</title>
      <link href="/2018/05/01/%E8%BF%90%E7%BB%B4/springboot-logback-log4j-elk.html"/>
      <content type="html"><![CDATA[<p>好长时间没有写过blog了。抽时间把很久之前集成的一个简易的elk升级了下<br>本教程使用的软件如下：<br>springboot 2.*<br>jdk8<br>elk 6.2.4(elasticsearch logstash kibana)<br><a id="more"></a></p><h2 id="1-springboot集成logback-logstash"><a href="#1-springboot集成logback-logstash" class="headerlink" title="1. springboot集成logback+logstash"></a>1. springboot集成logback+logstash</h2><h3 id="1-1-pom加入依赖"><a href="#1-1-pom加入依赖" class="headerlink" title="1.1 pom加入依赖"></a>1.1 pom加入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Logstash encoder --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsonevent-layout<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-在application-yml中加载logback的配置文件"><a href="#1-2-在application-yml中加载logback的配置文件" class="headerlink" title="1.2 在application.yml中加载logback的配置文件"></a>1.2 在application.yml中加载logback的配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  config:</span> <span class="attr">classpath:logback.xml</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">logs</span></span><br></pre></td></tr></table></figure><h3 id="1-3-在logback-xml中配置logstash"><a href="#1-3-在logback-xml中配置logstash" class="headerlink" title="1.3 在logback.xml中配置logstash"></a>1.3 在logback.xml中配置logstash</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"logstash"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.188.110<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>4560<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- encoder is required --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"logstash"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-elk配置"><a href="#2-elk配置" class="headerlink" title="2.elk配置"></a>2.elk配置</h2><h3 id="2-1-配置es"><a href="#2-1-配置es" class="headerlink" title="2.1 配置es"></a>2.1 配置es</h3><p>解压文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf elasticsearch-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></p><p>由于es不能用root账户启动，所以需要添加一个非root账户<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd es</span><br></pre></td></tr></table></figure></p><p>修改es文件夹的权限<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es:es elasticsearch-6.2.4</span><br></pre></td></tr></table></figure></p><p>修改配置文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/elk/elasticsearch-6.2.4/config/elasticsearch.yml</span><br></pre></td></tr></table></figure></p><p>修改<code>elasticsearch.yml</code>的内容如下<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口</span></span><br><span class="line"><span class="string">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#ip</span></span><br><span class="line"><span class="string">network.host:</span> <span class="number">192.168</span><span class="number">.188</span><span class="number">.111</span></span><br><span class="line"><span class="comment">#data路径</span></span><br><span class="line"><span class="string">path.data:</span> <span class="string">/opt/elk/elasticsearch-6.2.4/data</span></span><br><span class="line"><span class="comment">#logs路径</span></span><br><span class="line"><span class="string">path.logs:</span> <span class="string">/opt/elk/elasticsearch-6.2.4/logs</span></span><br></pre></td></tr></table></figure></p><p>创建data和logs文件夹<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data logs</span><br></pre></td></tr></table></figure></p><p>启动es(为了方便观察日志没有后台启动)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure></p><h3 id="2-2-logstash-配置"><a href="#2-2-logstash-配置" class="headerlink" title="2.2 logstash 配置"></a>2.2 logstash 配置</h3><p>解压文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf logstash-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></p><p>进入config文件夹新建log4j_es.conf文件并编写内容<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi log4j_es.conf</span><br></pre></td></tr></table></figure></p><p>log4j_es.conf内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    # https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html</span><br><span class="line">    tcp &#123;  </span><br><span class="line">    mode =&gt; &quot;server&quot;  </span><br><span class="line">    host =&gt; &quot;192.168.188.110&quot;  </span><br><span class="line">    port =&gt; 4560  </span><br><span class="line">    codec =&gt; json_lines  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch&#123;</span><br><span class="line">        hosts =&gt; [&quot;192.168.188.110:9200&quot;]</span><br><span class="line">        index =&gt; &quot;log4j-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">        document_type =&gt; &quot;log4j_type&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动logstash (为了方便观察日志没有后台启动)<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f config/log4j_es.conf</span><br></pre></td></tr></table></figure></p><h3 id="2-3-kibana-配置"><a href="#2-3-kibana-配置" class="headerlink" title="2.3 kibana 配置"></a>2.3 kibana 配置</h3><p>解压<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf kibana-6.2.4-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>修改配置文件<code>kibana.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="comment"># To allow connections from remote users, set this parameter to a non-loopback address.</span></span><br><span class="line"><span class="string">server.host:</span> <span class="string">"192.168.188.110"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The URL of the Elasticsearch instance to use for all your queries.</span></span><br><span class="line"><span class="string">elasticsearch.url:</span> <span class="string">"http://192.168.188.110:9200"</span></span><br></pre></td></tr></table></figure></p><p>启动kibana<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kibana</span><br></pre></td></tr></table></figure></p><h2 id="3-kibana界面设置"><a href="#3-kibana界面设置" class="headerlink" title="3.kibana界面设置"></a>3.kibana界面设置</h2><p>进入kibana界面<br>点击 Management 点击Index Patterns<br>在 Create index pattern 的文本框输入索引名称，因为我在logstash中设置索引为 <code>log4j-%{+YYYY.MM.dd}</code>,所以我们填写 <code>log4j-*</code> 点击下一步设置直到完成。<br>点击<code>Discovery</code>可以看到我们的日志了。</p><p>接下来，将elk进行升级 使用elk+filebeat+kafka,敬请期待。</p>]]></content>
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>localStorage简单封装设置失效时间</title>
      <link href="/2018/04/24/js/localStorage%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E8%AE%BE%E7%BD%AE%E5%A4%B1%E6%95%88%E6%97%B6%E9%97%B4.html"/>
      <content type="html"><![CDATA[<h3 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h3><p>在客户端存储数据<br>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><p>localStorage和cookie 的区别不详细对比，但是localStorage存储数据的时候有一点需要我们注意的。<br><a id="more"></a></p><h3 id="2-场景："><a href="#2-场景：" class="headerlink" title="2.场景："></a>2.场景：</h3><p>我们前端需要调用第三方api异步获取我们的数据A（短时间内数据都一样）,然后我们拿到数据A来进行其他操作。试想下从获取数据A再到用数据A获取我么想要的最终结果，这段时间对用户来说是很漫长了！<br>其实我们可以使用</p><ul><li>Cookie来存储数据，但是Cookie存储的数据有限制。</li><li>使用localStorage能满足存储数据的条件，但是它却没有失效时间。<br>那我们改怎么优化这种场景呢？</li></ul><p>综上所述，Cookie已经无法满足我们的要求了，那么我们就从localStorage入手吧。既然localStorage没有失效时间，我们就封装下使其满足我们的需求。</p><h3 id="3-实现："><a href="#3-实现：" class="headerlink" title="3.实现："></a>3.实现：</h3><p>下面的代码仅供参考：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storageUtil = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param key</span></span><br><span class="line"><span class="comment">     * @param data</span></span><br><span class="line"><span class="comment">     * @param time 失效时间（秒）,默认一周</span></span><br><span class="line"><span class="comment">     * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    put: <span class="function"><span class="keyword">function</span> (<span class="params">key, data, time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!localStorage) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!time || <span class="built_in">isNaN</span>(time)) &#123;</span><br><span class="line">                time = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> cacheExpireDate = (<span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="number">1</span>) + time * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">var</span> cacheVal = &#123;<span class="attr">val</span>: data, <span class="attr">exp</span>: cacheExpireDate&#125;;</span><br><span class="line">            localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(cacheVal));<span class="comment">//存入缓存值</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!localStorage) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> cacheVal = localStorage.getItem(key);</span><br><span class="line">            <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(cacheVal);</span><br><span class="line">            <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//缓存不存在</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//缓存过期</span></span><br><span class="line">            <span class="keyword">if</span> (now &gt; result.exp) &#123;</span><br><span class="line">                <span class="keyword">this</span>.remove(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result.val;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.remove(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!localStorage) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        localStorage.removeItem(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-使用实例"><a href="#4-使用实例" class="headerlink" title="4.使用实例"></a>4.使用实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">storageUtil.put(<span class="string">"aa"</span>,<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cacheData = storageUtil.get(<span class="string">"aa"</span>);</span><br><span class="line"><span class="keyword">if</span>(cacheData !== <span class="literal">null</span> || cacheData !== <span class="string">''</span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> localStorage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jmap命令使用</title>
      <link href="/2018/04/19/java/jmap%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8.html"/>
      <content type="html"><![CDATA[<h3 id="查看-JVM-堆内存情况"><a href="#查看-JVM-堆内存情况" class="headerlink" title="查看 JVM 堆内存情况"></a>查看 JVM 堆内存情况</h3><p>如果想分析自己的JAVA Application时，可以使用jmap程序来生成heapdump文例：<br><code>jmap -heap pid</code><br>jmap是JDK自带的一个工具，非常小巧方便，其支持参数如下：<br>    <code>-heap</code>：打印heap空间的概要，这里可以粗略的检验heap空间的使用情况。<br>官网对jmap的解释是:<br><a id="more"></a><br>DESCRIPTION<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmap prints shared object memory maps or heap memory details of a given process or core file or a remote debug server. If the given process is running on a 64-bit VM, you may need to specify the -J-d64 option, e.g.:</span><br><span class="line"></span><br><span class="line">jmap -J-d64 -heap pid</span><br><span class="line">NOTE - This utility is unsupported and may or may not be available in future versions of the JDK. In Windows Systems where dbgeng.dll is not present, &apos;Debugging Tools for Windows&apos; needs to be installed to have these tools working. Also, the PATH environment variable should contain the location of jvm.dll used by the target process or the location from which the Crash Dump file was produced.</span><br><span class="line">For example, set PATH=&lt;jdk&gt;\jre\bin\client;%PATH%</span><br></pre></td></tr></table></figure></p><p>OPTIONS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;no option&gt;</span><br><span class="line">When no option is used jmap prints shared object mappings. For each shared object loaded in the target VM, start address, the size of the mapping, and the full path of the shared object file are printed. This is similar to the Solaris pmap utility.</span><br><span class="line"></span><br><span class="line">-dump:[live,]format=b,file=&lt;filename&gt;</span><br><span class="line">Dumps the Java heap in hprof binary format to filename. The live suboption is optional. If specified, only the live objects in the heap are dumped. To browse the heap dump, you can use jhat (Java Heap Analysis Tool) to read the generated file.</span><br><span class="line"></span><br><span class="line">-finalizerinfo</span><br><span class="line">Prints information on objects awaiting finalization.</span><br><span class="line"></span><br><span class="line">-heap</span><br><span class="line">Prints a heap summary. GC algorithm used, heap configuration and generation wise heap usage are printed.</span><br><span class="line"></span><br><span class="line">-histo[:live]</span><br><span class="line">Prints a histogram of the heap. For each Java class, number of objects, memory size in bytes, and fully qualified class names are printed. VM internal class names are printed with &apos;*&apos; prefix. If the live suboption is specified, only live objects are counted.</span><br><span class="line"></span><br><span class="line">-permstat</span><br><span class="line">Prints class loader wise statistics of permanent generation of Java heap. For each class loader, its name, liveness, address, parent class loader, and the number and size of classes it has loaded are printed. In addition, the number and size of interned Strings are printed.</span><br><span class="line"></span><br><span class="line">-F</span><br><span class="line">Force. Use with jmap -dump or jmap -histo option if the pid does not respond. The live suboption is not supported in this mode.</span><br><span class="line"></span><br><span class="line">-h</span><br><span class="line">Prints a help message.</span><br><span class="line"></span><br><span class="line">-help</span><br><span class="line">Prints a help message.</span><br><span class="line"></span><br><span class="line">-J&lt;flag&gt;</span><br><span class="line">Passes &lt;flag&gt; to the Java virtual machine on which jmap is run.</span><br></pre></td></tr></table></figure></p><h3 id="jmap-heap命令显示的结果"><a href="#jmap-heap命令显示的结果" class="headerlink" title="jmap -heap命令显示的结果"></a>jmap -heap命令显示的结果</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 837</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 837, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)//GC 方式</span><br><span class="line">Heap Configuration: //堆内存初始化配置</span><br><span class="line">   MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">   MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">   MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">   NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">   MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">   OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">   NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">   SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">   PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">   MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">   G1HeapRegionSize = 0 (0.0MB)</span><br><span class="line">Heap Usage://堆内存使用情况</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space://Eden区内存分布</span><br><span class="line">   capacity = 33030144 (31.5MB)//Eden区总容量</span><br><span class="line">   used     = 1524040 (1.4534378051757812MB)  //Eden区已使用</span><br><span class="line">   free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量</span><br><span class="line">   4.614088270399305% used //Eden区使用比率</span><br><span class="line">From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:  //另一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation //当前的Old区内存分布</span><br><span class="line">   capacity = 86507520 (82.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 86507520 (82.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">   free     = 19523568 (18.619125366210938MB)</span><br><span class="line">   11.337498256138392% used</span><br><span class="line">670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> jmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>感悟1</title>
      <link href="/2018/04/18/%E5%85%B6%E4%BB%96/%E6%84%9F%E6%82%9F1.html"/>
      <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>转眼间已经毕业3年了，从13年工作算起也算是工作5年多了，期间做过android、 flex 、c#、前端偏js、Java、半运维。最终还是选择了曾经最讨厌的Java。<br>在现在这份工作之前，给别人的感觉我就是跳槽频繁。说实话，如果一份工作在薪水和体现你能力之间有个相对权衡的点，相信都不会想着跳槽的，毕竟一个新的环境一个新的坑，你能不能像在之前公司被器重都是未知数。<br>在此写下本人的一些感触。<br><a id="more"></a></p><h3 id="2-感悟"><a href="#2-感悟" class="headerlink" title="2.感悟"></a>2.感悟</h3><p>个人认为当一个程序员工作年限在3年+的时候，</p><h4 id="2-1-对于java程序员"><a href="#2-1-对于java程序员" class="headerlink" title="2.1 对于java程序员:"></a>2.1 <code>对于java程序员</code>:</h4><p>如果没有接触过线上的各种事故和OOM问题、sql优化、性能优化、jstack、jvisualvm等jvm监控工具的使用，而是仅仅写curd，或ctrl+c ctrl+v那么你就要好反思下差距了，现在学习这些还不晚。</p><h4 id="2-2-对于前端偏js："><a href="#2-2-对于前端偏js：" class="headerlink" title="2.2 对于前端偏js："></a>2.2 <code>对于前端偏js</code>：</h4><p>这里不说具体的技术，仅仅谈论通用性。当你写代码的时候，有没有考虑过网络请求的io、js代码执行的效率加密压缩、网页加载速度、localstorage等h5新特性的使用。如果没有，请此刻注意下你的代码。</p><h4 id="2-3-代码规范："><a href="#2-3-代码规范：" class="headerlink" title="2.3 代码规范："></a>2.3 <code>代码规范</code>：</h4><p>对于程序员来说，我认为你只有代码写的很规范才算是一个优秀程序员的开始，应该很少有很优秀的程序员代码写的很烂吧。之前我带过的人，每一个我都会强调不管你技术怎么样，先把需求分析好，把代码写规范再说，别过了一段时间之后自己都看不懂了。</p><h4 id="2-4-代码不是写完就算了"><a href="#2-4-代码不是写完就算了" class="headerlink" title="2.4 代码不是写完就算了"></a>2.4 <code>代码不是写完就算了</code></h4><p>在学习的过程中，我们总能对新的事物有新的看法。你刚写完功能的时候感觉写的很完美几乎没有瑕疵，但是一段时间之后你就会发现当时写的太烂了。在此建议在写代码的时候尽量考虑下健壮性，尽量不要出现对代码大的改动。</p><h4 id="2-5-不要抱怨别人代码写的多烂"><a href="#2-5-不要抱怨别人代码写的多烂" class="headerlink" title="2.5 不要抱怨别人代码写的多烂"></a>2.5 <code>不要抱怨别人代码写的多烂</code></h4><p>基本上每个人都会说，这个代码写的太烂了，我看都不想看。任何一段当时完美的代码在一段时间之后都会变成烂代码（业务和技术推动）。面对这个问题一般有以下做法</p><ul><li>1.视而不见，反正不是我的，找别人改去</li><li>2.反正别人的代码我不想动，我把这段代码ctrl+c ctrl+v一份加上自己的逻辑。</li><li>3.仔细分析之前代码的逻辑，根据需求去优化代码并考虑影响到的功能。<br>能做到第3的我相信你的能力绝对不会低的。</li></ul><h4 id="2-6-找到一个自学的方向，专而不泛"><a href="#2-6-找到一个自学的方向，专而不泛" class="headerlink" title="2.6 找到一个自学的方向，专而不泛"></a>2.6 <code>找到一个自学的方向，专而不泛</code></h4><p>我要把想学的学懂了再说其他的，最好的学习路径是官网和源码，百度或Google搜出来的很多都是没用甚至错误的!!!不要轻易的跟别人说精通这两个字，否则你会很尴尬。</p><h4 id="2-7-保持谦虚"><a href="#2-7-保持谦虚" class="headerlink" title="2.7 保持谦虚"></a>2.7 <code>保持谦虚</code></h4><p>人，在做一件的时候尽量保持虚心的态度。不要觉得别人很菜，有可能别人在某一个点上比你强很多很多。不要小瞧任何一个人。</p><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续….."></a>未完待续…..</h3>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql常用SQL</title>
      <link href="/2018/04/14/DB/mysql%E5%B8%B8%E7%94%A8SQL.html"/>
      <content type="html"><![CDATA[<h3 id="1-查询一段时间内的数据："><a href="#1-查询一段时间内的数据：" class="headerlink" title="1. 查询一段时间内的数据："></a>1. 查询一段时间内的数据：</h3><p> 查询一天：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">to_days</span>(column_time) = <span class="keyword">to_days</span>(<span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="built_in">date</span>(column_time) = <span class="keyword">curdate</span>();</span><br></pre></td></tr></table></figure></p><p>查询一周：<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>   <span class="keyword">where</span> <span class="keyword">DATE_SUB</span>(<span class="keyword">CURDATE</span>(), <span class="built_in">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>) &lt;= <span class="built_in">date</span>(column_time);</span><br></pre></td></tr></table></figure></p><p>查询一个月：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">DATE_SUB</span>(<span class="keyword">CURDATE</span>(), <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>) &lt;= <span class="built_in">date</span>(column_time);</span><br></pre></td></tr></table></figure></p><p>更新待续……</p><h3 id="2-索引："><a href="#2-索引：" class="headerlink" title="2.索引："></a>2.索引：</h3><ul><li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></li></ul><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></p><ul><li>尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></li></ul><p>可以这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> all</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></p><ul><li>in 和 not in 也要慎用，否则会导致全表扫描。</li><li>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure></li></ul><p>可以改为强制查询使用索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure></p><ul><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描</li><li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li><li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</li><li>很多时候用 exists 代替 in 是一个好的选择：</li><li>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读写自旋锁</title>
      <link href="/2018/03/29/%E8%AF%BB%E5%86%99%E8%87%AA%E6%97%8B%E9%94%81.html"/>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>读写锁ReaderWriterLockSlim</title>
      <link href="/2018/03/29/%E8%AF%BB%E5%86%99%E9%94%81ReaderWriterLockSlim.html"/>
      <content type="html"><![CDATA[<p>关于读写锁的定义可以到网上查询，这里不再啰嗦了。</p><h3 id="1-场景："><a href="#1-场景：" class="headerlink" title="1. 场景："></a>1. 场景：</h3><p>多个线程同时读写，读线程的数量远远大于写线程，该怎么办？</p><p>如果我们只是简单的使用lock方式去加锁，则会影响性能。如果采用读写锁，那么多个线程可以同时读取该对象，只有等到对象被写入锁占用的时候，才会阻塞。<br>也就是说某个线程进入了写入模式，那么其他线程无论是要写入还是读取，都是会被阻塞的。</p><ul><li>进入写入/读取模式有2种方法：<br>　　EnterReadLock尝试进入写入模式锁定状态。<br>　　TryEnterReadLock(Int32) 尝试进入读取模式锁定状态，可以选择整数超时时间。<br>　　EnterWriteLock 尝试进入写入模式锁定状态。<br>　　TryEnterWriteLock(Int32) 尝试进入写入模式锁定状态，可以选择超时时间。</li><li>退出写入/读取模式有2种方法：<br>　　ExitReadLock 减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。<br>　　ExitWriteLock 减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。</li></ul><h3 id="待续……"><a href="#待续……" class="headerlink" title="待续……."></a>待续…….</h3>]]></content>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>详情页返回到列表页定位处理</title>
      <link href="/2018/03/22/js/%E8%AF%A6%E6%83%85%E9%A1%B5%E8%BF%94%E5%9B%9E%E5%88%B0%E5%88%97%E8%A1%A8%E9%A1%B5%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86.html"/>
      <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>在H5页面的电商系统中往往会有以下需求：<br>点击分类等跳转到商品列表页，点击某个商品之后再返回到列表页，返回列表页面的时候能记住之前浏览的位置：</p><h3 id="2-方案："><a href="#2-方案：" class="headerlink" title="2.方案："></a>2.方案：</h3><a id="more"></a><p>我们需要哪些数据？</p><ul><li>当前页数</li><li>当前已经加载的数据</li><li>当前滚动的高度</li></ul><h4 id="2-1-cookies和localstorage"><a href="#2-1-cookies和localstorage" class="headerlink" title="2.1 cookies和localstorage"></a>2.1 cookies和localstorage</h4><ul><li>在页面滚动的过程中将滚动的距离和当前页数记录下来(也有设置锚点的)。</li><li>加载新数据的时候将页面的数据及当前页数记录下来。</li><li>将上面三个数据存储到浏览器缓存中，并设计过期时间。</li><li>从商品详情页回到列表页面的时候,判断是否是从详情页返回的(可以根据 window.location.hash判断)。如果是从详情页返回的，将数据加载到html页面。</li><li>缓存过期后，清除缓存。</li></ul><p>这个方案有2个弊端</p><ul><li>浏览器必须支持 localstorage(主流的基本上都支持了)</li><li>缓存失效时间，如果处理不当可能造成数据混乱</li></ul><h4 id="2-2-html5的replaceState"><a href="#2-2-html5的replaceState" class="headerlink" title="2.2 html5的replaceState"></a>2.2 html5的replaceState</h4><p>history.pushState() 和 history.replaceState() 是什么有兴趣的可以到网上查下</p><ul><li>创建一个对象用于存储需要的信息</li><li>在页面滚动的过程中将当前滚动的距离记录下来。</li><li>加载新数据的时候替换老的数据。</li><li>点击进入商品详情页之前将当前页数、数据、滚动距离更新到对象中。</li><li>从商品详情页回到列表页面的时候，$(window).load()判断是否有数据，有就从对象中取，否则ajax请求</li><li>window.history.replaceState({}, “”, page); 清空数据</li></ul><p>总上所述，个人比较推荐方案2<br>现贴上方案2的部分代码，仅供参考</p><pre><code class="javascript">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{    <span class="keyword">if</span> ($(<span class="built_in">window</span>).scrollTop() + $(<span class="built_in">window</span>).height() - $(<span class="built_in">document</span>).height() &gt;= <span class="number">-1</span>) {        <span class="keyword">if</span> (!scrolling) {            curPage++;            showLoading();            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{                getList(<span class="number">10</span>);            }, <span class="number">3000</span>);        }    }});$(<span class="built_in">window</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{    <span class="comment">//判断如果有history.state.data，说明是从详情页返回的</span>    <span class="keyword">if</span> (!!(<span class="built_in">window</span>.history.state &amp;&amp; <span class="built_in">window</span>.history.state.data)) {        $(<span class="string">"#loading"</span>).hide();        $(<span class="string">"#nomore"</span>).hide();        $(<span class="string">"#loadmore"</span>).show(); <span class="comment">//隐藏loading，显示 加载更多（为了分页）</span>        dealWithResult(<span class="built_in">window</span>.history.state); <span class="comment">//根据记录的数据显示列表</span>        curPage = <span class="built_in">window</span>.history.state.curPage;        statedata = <span class="built_in">window</span>.history.state; <span class="comment">//把页面和data赋值给全局变量</span>        <span class="built_in">window</span>.history.replaceState({}, <span class="string">""</span>, <span class="string">"list.html"</span>); <span class="comment">//清空state，防止列表页点返回的时候会回到上一个state</span>    } <span class="keyword">else</span> {        getList(<span class="number">20</span>);     }});<span class="function"><span class="keyword">function</span> <span class="title">dealWithResult</span>(<span class="params">listdata</span>) </span>{    $(<span class="string">"#list"</span>).html(listdata.data)        <span class="comment">//判断如果是详情页回来，获取上次的滚动条位置</span>    <span class="keyword">if</span> (!!(<span class="built_in">window</span>.history.state &amp;&amp; <span class="built_in">window</span>.history.state.data)) {        <span class="comment">// 延迟 0.5秒滚动，防止页面中列表还没构建完</span>        setTimeout(<span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="built_in">window</span>.history.state.sh || <span class="number">0</span>), <span class="number">500</span>);    }}<span class="keyword">var</span> totalnum = <span class="number">0</span>;<span class="keyword">var</span> statedata = {};<span class="keyword">var</span> curPage = <span class="number">1</span>;<span class="function"><span class="keyword">function</span> <span class="title">getList</span>(<span class="params">num</span>) </span>{    <span class="keyword">var</span> li = <span class="string">''</span>;    <span class="keyword">for</span> (i = totalnum; i &lt; totalnum + num; i++) {        li += <span class="string">'&lt;li class="goodsDetail"&gt;&lt;a href="javascript:void(0);"&gt;list'</span> + (i + <span class="number">1</span>) + <span class="string">'&lt;/a&gt;&lt;/li&gt;'</span>;    }    totalnum += num    $(<span class="string">"#list"</span>).append(li);    statedata.data = $(<span class="string">"#list"</span>).html();    hideLoading();}<span class="function"><span class="keyword">function</span> <span class="title">showLoading</span>(<span class="params"></span>) </span>{    scrolling = <span class="literal">true</span>;    $(<span class="string">"#loading"</span>).show();}<span class="function"><span class="keyword">function</span> <span class="title">hideLoading</span>(<span class="params"></span>) </span>{    scrolling = <span class="literal">false</span>;    $(<span class="string">"#loading"</span>).hide();}$(<span class="string">"#list"</span>).on(<span class="string">'click'</span>, <span class="string">".goodsDetail"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{    <span class="comment">//所有数据</span>    <span class="keyword">var</span> data = $(<span class="string">"#list"</span>).html();    statedata.curPage = curPage    statedata.data = data    statedata.sh = scroll2Top();    <span class="keyword">var</span> hrefPage = <span class="string">"detail.html"</span>;    history.replaceState(statedata, <span class="string">""</span>, <span class="string">"list.html"</span>);    <span class="built_in">window</span>.location.href = hrefPage;});<span class="comment">//当前滚动条位置</span><span class="function"><span class="keyword">function</span> <span class="title">scroll2Top</span>(<span class="params"></span>) </span>{    <span class="keyword">var</span> scrollTop = <span class="number">0</span>;    <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement &amp;&amp; <span class="built_in">document</span>.documentElement.scrollTop) {        scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.body) {        scrollTop = <span class="built_in">document</span>.body.scrollTop;    }    <span class="keyword">return</span> scrollTop;}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jquery中.attr和.data的区别</title>
      <link href="/2018/03/16/js/Jquery%E4%B8%AD-attr%E5%92%8C-data%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <content type="html"><![CDATA[<p>$.attr()和$.data()本质上属于 <code>DOM属性</code> 和 <code>Jquery对象属性</code> 的区别：</p><ul><li>$.attr()每次都从DOM元素中取属性的值。</li><li>$.attr(‘data-xxx’, ‘xxxxx’)会将字符串’xxxx’塞到标签的’data-xxx’属性中。<a id="more"></a></li><li>$.data(‘xxx’)是从 Jquery对象中取值，由于对象属性值保存在内存中，因此可能和视图里的属性值不一致的情况。</li><li>$.data(‘xxx’, ‘xxxx’)会将字符串’xxxx’塞到 Jquery对象 的’xxx’属性中，而不是塞到视图标签的data-xxx属性中。</li></ul><p>所以$.attr()和$.data()应避免混合用</p><ul><li>通过$.attr()来进行set属性，然后通过$.data()进行get属性值；</li><li>通过$.data()来进行set属性，然后通过$.attr()进行get属性值。<br>同时从性能的角度来说，建议使用$.data()来进行set和get操作，因为它仅仅修改的 Jquey对象 的属性值，不会引起额外的DOM操作。 </li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>mybatis chose when条件的坑</title>
      <link href="/2018/03/15/DB/mybatis-chose-when%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%9D%91.html"/>
      <content type="html"><![CDATA[<p>在使用mybatis 条件判断的时候，我们最常用的是: </p><ol><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        and title = #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"content != null"</span>&gt;</span></span><br><span class="line">        and content = #&#123;content&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        and owner = "owner1"</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><p>在编码中 我们一般习惯用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125; elseif()&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中chose when otherwise等同于上面<br>看下面一段Mybatis代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"isThird == '0'"</span>&gt;</span></span><br><span class="line">        xxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"isThird == '1'"</span>&gt;</span></span><br><span class="line">       xxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    xxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>不知道你有没有发现问题。对，上面代码在执行的时候死活进不去when条件，这时我们可能会说没问题啊，一定是参数传错了……<br>当MyBatis 判断条件为等于的时候，常量需要加 .toString() 来转换，这种方法是稳定的，推荐使用！！</p>]]></content>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis单个key存储的value很大</title>
      <link href="/2018/03/09/%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%8D%95%E4%B8%AAkey%E5%AD%98%E5%82%A8%E7%9A%84value%E5%BE%88%E5%A4%A7.html"/>
      <content type="html"><![CDATA[<p>Redis使用过程中经常会有各种大key的情况， 比如：</p><ul><li>单个简单的key存储的value很大</li><li>hash， set，zset，list 中存储过多的元素（以万为单位）<br>由于redis是单线程运行的，如果一次操作的value很大会对整个redis的响应时间造成负面影响，所以，业务上能拆则拆，下面举几个典型的分拆方案。<a id="more"></a><h3 id="1-单个简单的key存储的value很大"><a href="#1-单个简单的key存储的value很大" class="headerlink" title="1. 单个简单的key存储的value很大"></a>1. 单个简单的key存储的value很大</h3><h4 id="1-1-改对象需要每次都整存整取"><a href="#1-1-改对象需要每次都整存整取" class="headerlink" title="1.1 改对象需要每次都整存整取"></a>1.1 改对象需要每次都整存整取</h4>可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；    </li></ul><h4 id="1-2-该对象每次只需要存取部分数据"><a href="#1-2-该对象每次只需要存取部分数据" class="headerlink" title="1.2 该对象每次只需要存取部分数据"></a>1.2 该对象每次只需要存取部分数据</h4><p>可以像第一种做法一样，分拆成几个key-value，  也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性    </p><h3 id="2-hash、set、zset、list-中存储过多的元素"><a href="#2-hash、set、zset、list-中存储过多的元素" class="headerlink" title="2. hash、set、zset、list 中存储过多的元素"></a>2. hash、set、zset、list 中存储过多的元素</h3><p>类似于场景一种的第一个做法，可以将这些元素分拆。</p><p>以hash为例，原先的正常存取流程是  hget(hashKey, field) ; hset(hashKey, field, value)<br>现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newHashKey  =  hashKey + (*hash*(field) % <span class="number">10000</span>）;   </span><br><span class="line">hset (newHashKey, field, value) ;  </span><br><span class="line">hget(newHashKey, field)</span><br></pre></td></tr></table></figure></p><p>set, zset, list 也可以类似上述做法.</p><p>但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。</p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis常见问题</title>
      <link href="/2018/03/09/%E5%88%86%E5%B8%83%E5%BC%8F/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
      <content type="html"><![CDATA[<h3 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1. 分布式锁"></a>1. 分布式锁</h3><p>说道Redis分布式锁，我们的第一印象就是setnx操作。<br>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。但是在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？<br><a id="more"></a><br>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><ul><li>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</li><li>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</li><li>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</li><li>XX ：只在键已经存在时，才对键进行设置操作。<br>所以set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用！<br>参考：<a href="http://redisdoc.com/string/set.html" target="_blank" rel="noopener">http://redisdoc.com/string/set.html</a></li></ul><h3 id="2-无阻塞取数据"><a href="#2-无阻塞取数据" class="headerlink" title="2. 无阻塞取数据"></a>2. 无阻塞取数据</h3><ul><li>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</li></ul><p>一般人会说：使用keys指令可以扫出指定模式的key列表。</p><ul><li>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</li></ul><p>因为redis的单线程的,keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="3-大量的key同一时间过期"><a href="#3-大量的key同一时间过期" class="headerlink" title="3. 大量的key同一时间过期"></a>3. 大量的key同一时间过期</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h3 id="4-Redis做持久化"><a href="#4-Redis做持久化" class="headerlink" title="4. Redis做持久化"></a>4. Redis做持久化</h3><ul><li>Redis如何做持久化的？</li></ul><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><ul><li>如果突然机器掉电会怎样？</li></ul><p>取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><ul><li>bgsave的原理是什么？</li></ul><p>fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tomcat特殊字符报400（The valid characters are defined in RFC 7230 and RFC 3986）</title>
      <link href="/2018/03/07/%E8%BF%90%E7%BB%B4/Tomcat%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%8A%A5400.html"/>
      <content type="html"><![CDATA[<p>Tomcat在 7.0.73, 8.0.39, 8.5.7 等版本后(详情：<a href="https://stackoverflow.com/questions/41053653/tomcat-8-is-not-able-to-handle-get-request-with-in-query-parameters/44005213#44005213)，添加了对于http头的验证,就是添加了些规则去限制HTTP头的规范性(详情：http://www.jianshu.com/p/1c870461fa41)" target="_blank" rel="noopener">https://stackoverflow.com/questions/41053653/tomcat-8-is-not-able-to-handle-get-request-with-in-query-parameters/44005213#44005213)，添加了对于http头的验证,就是添加了些规则去限制HTTP头的规范性(详情：http://www.jianshu.com/p/1c870461fa41)</a><br><a id="more"></a></p><ul><li><p>报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.coyote.http11.Http11Processor.service Error parsing HTTP request header</span><br><span class="line"> Note: further occurrences of HTTP header parsing errors will be logged at DEBUG level.</span><br><span class="line"> java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986</span><br></pre></td></tr></table></figure></li><li><p>根据rfc规范（RFC 3986规范定义了Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符(RFC3986中指定了以下字符为保留字符：! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ])）。</p></li><li>url中不允许有 |，{，}等特殊字符，但在实际生产中还是有些url有可能携带有这些字符，特别是|还是较为常见的。在tomcat升级到7以后，对url字符的检查都变严格了，如果出现这类字符，tomcat将直接返回400状态码。</li></ul><ul><li><p>修改tomcat的配置，在catalina.properties添加下面的配置，重启服务器即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat.util.http.parser.HttpParser.requestTargetAllow=|&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>tomcat官方说明<br><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/systemprops.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-7.0-doc/config/systemprops.html</a>;<br><a href="https://tomcat.apache.org/tomcat-8.5-doc/config/systemprops.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/systemprops.html</a></p></li><li><p>源码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_CONTROL[i] || i &gt; <span class="number">127</span> ||</span><br><span class="line">                i == <span class="string">' '</span> || i == <span class="string">'\"'</span> || i == <span class="string">'#'</span> || i == <span class="string">'&lt;'</span> || i == <span class="string">'&gt;'</span> || i == <span class="string">'\\'</span> ||</span><br><span class="line">                i == <span class="string">'^'</span> || i == <span class="string">'`'</span>  || i == <span class="string">'&#123;'</span> || i == <span class="string">'|'</span> || i == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">            IS_NOT_REQUEST_TARGET[i] = <span class="keyword">true</span>;  <span class="comment">// reject the character!</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Jedis在高并发报错 (java.net.SocketException: Connection reset by peer: socket write error)</title>
      <link href="/2018/01/17/java/%E4%BD%BF%E7%94%A8Jedis%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8A%A5%E9%94%99-java-net-SocketException-Connection-reset-by-peer-socket-write-error.html"/>
      <content type="html"><![CDATA[<p>Connection reset by peer: socket write error错误分析：<br>常出现的Connection reset by peer: 原因可能是多方面的，不过更常见的原因是：<br>①：服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉；<br>②：客户关掉了浏览器，而服务器还在给客户端发送数据；<br>③：浏览器端按了Stop<br><a id="more"></a></p><h4 id="1-报错信息"><a href="#1-报错信息" class="headerlink" title="1.报错信息"></a>1.报错信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.InvocationTargetException: null</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">at java.lang.reflect.Method.invoke(Unknown Source)</span><br><span class="line">....</span><br><span class="line">at java.lang.Thread.run(Unknown Source)</span><br><span class="line">Caused by: redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketException: Connection reset by peer: socket write error</span><br><span class="line">at redis.clients.jedis.Connection.flush(Connection.java:334)</span><br><span class="line">at redis.clients.jedis.Connection.getBinaryBulkReply(Connection.java:257)</span><br><span class="line">at redis.clients.jedis.BinaryJedis.get(BinaryJedis.java:244)</span><br><span class="line">......</span><br><span class="line">... 15 common frames omitted</span><br><span class="line">Caused by: java.net.SocketException: Connection reset by peer: socket write error</span><br><span class="line">at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">at java.net.SocketOutputStream.socketWrite(Unknown Source)</span><br><span class="line">at java.net.SocketOutputStream.write(Unknown Source)</span><br><span class="line">at redis.clients.util.RedisOutputStream.flushBuffer(RedisOutputStream.java:52)</span><br><span class="line">at redis.clients.util.RedisOutputStream.flush(RedisOutputStream.java:216)</span><br><span class="line">at redis.clients.jedis.Connection.flush(Connection.java:331)</span><br><span class="line">... 22 common frames omitted</span><br></pre></td></tr></table></figure><p> 所以本问题是由 ①造成的</p><h4 id="2-修改之前的代码"><a href="#2-修改之前的代码" class="headerlink" title="2.修改之前的代码"></a>2.修改之前的代码</h4><p> 初始化jedis的代码<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在多线程环境同步初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">poolInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">         createJedisPool();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">* 获取一个jedis 对象</span><br><span class="line">  *</span><br><span class="line">  * <span class="meta">@return</span></span><br><span class="line">  */</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">         poolInit();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> pool.getResource();</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p> 使用jedis的代码<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Jedis jedis = JedisPoolUtil.getJedis();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(exists(key))&#123;</span><br><span class="line">          <span class="keyword">return</span> deserialize(jedis.get(key.getBytes()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-修改之后的代码"><a href="#3-修改之后的代码" class="headerlink" title="3.修改之后的代码"></a>3.修改之后的代码</h4><p> 初始化jedis的代码<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个jedis 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        poolInit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有以下代码会造成初始化的jedis拿不到 jedis对象</span></span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis = pool.getResource();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"获取redis失败 : &#123;&#125;"</span> + ExceptionUtils.getStackTrace(e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jedis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 使用jedis的代码</p><pre><code class="java"><span class="comment">/**</span><span class="comment">    * 读取对象</span><span class="comment">    *</span><span class="comment">    * <span class="doctag">@param</span> key</span><span class="comment">    * <span class="doctag">@return</span></span><span class="comment">    */</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getObject</span><span class="params">(String key)</span> </span>{       <span class="keyword">if</span> (exists(key)) {           <span class="comment">//初始化jedis用完之后关闭连接</span>           Jedis jedis = JedisPoolUtil.getJedis();           Object object = deserialize(jedis.get(key.getBytes()));           jedis.close();           <span class="keyword">return</span> object;       }       <span class="keyword">return</span> <span class="keyword">null</span>;   }</code></pre>]]></content>
      
      
        <tags>
            
            <tag> jedis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring AOP中pointcut expression表达式解析 及匹配多个条件</title>
      <link href="/2018/01/15/java/Spring-AOP%E4%B8%ADpointcut-expression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90-%E5%8F%8A%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6.html"/>
      <content type="html"><![CDATA[<h2 id="Spring-AOP中pointcut-expression表达式解析-及匹配多个条件"><a href="#Spring-AOP中pointcut-expression表达式解析-及匹配多个条件" class="headerlink" title="Spring AOP中pointcut expression表达式解析 及匹配多个条件"></a>Spring AOP中pointcut expression表达式解析 及匹配多个条件</h2><p>任意公共方法的执行：<br>　　execution(public <em> </em>(..))<br>任何一个以“set”开始的方法的执行：<br>　　execution(<em> set</em>(..))<br>AccountService 接口的任意方法的执行：<br>　　execution(<em> com.xyz.service.AccountService.</em>(..))<br>定义在service包里的任意方法的执行：<br>　　execution(<em> com.xyz.service.</em>.<em>(..))<br>定义在service包和所有子包里的任意类的任意方法的执行：<br>　　execution(</em> com.xyz.service..<em>.</em>(..))<br>定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：<br>　　execution(<em> com.test.spring.aop.pointcutexp..JoinPointObjP2.</em>(..))”)<br>在多个表达式之间使用 ||,or表示 或，使用 &amp;&amp;,and表示 与，！表示 非.例如：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)&quot;)</span><br></pre></td></tr></table></figure></p><p>execution 用于匹配方法执行的连接点;<br>@within :使用 “@within(注解类型)” 匹配所以持有指定注解类型内的方法;注解类型也必须是全限定类型名;<br>@annotation :使用 “@annotation(注解类型)” 匹配当前执行方法持有指定注解的方法;注解类型也必须是全限定类型名;<br>@args 任何一个只接受一个参数的方法,且方法运行时传入的参数持有注解动态切入点,类似于 arg 指示符;<br>@target 任何目标对象持有 Secure 注解的类方法;必须是在目标对象上声明这个注解,在接口上声明的对它不起作用<br>@args :使用 “@args( 注解列表 )” 匹配当前执行的方法传入的参数持有指定注解的执行;注解类型也必须是全限定类型名;</p>]]></content>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm参数配置笔记</title>
      <link href="/2018/01/15/java/jvm%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0.html"/>
      <content type="html"><![CDATA[<h3 id="1、堆设置（这里是重点）"><a href="#1、堆设置（这里是重点）" class="headerlink" title="1、堆设置（这里是重点）"></a>1、堆设置（这里是重点）</h3><p>-Xms:初始堆大小<br>-Xmx:最大堆大小<br>-XX:NewSize=n:设置年轻代初始大小<br>-XX:MaxNewSize=n设置年轻代最大大小<br>-Xmn:相当于-XX:NewSize和-XX:MaxNewSize设置为同一个值了，表示永久设置年轻代的大小。当然剩下的就是老年代咯。<br><a id="more"></a><br>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4<br>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</p><h3 id="2、方法区设置-重点"><a href="#2、方法区设置-重点" class="headerlink" title="2、方法区设置(重点)"></a>2、方法区设置(重点)</h3><p>-XX:PermSize=n：设置永久代初始大小<br>-XX:MaxPermSize=n:设置永久代最大大小</p><h3 id="3、收集器设置（java支持多种垃圾收集器，当然你或许连收集器的概念也不知道，赶紧看书去吧）"><a href="#3、收集器设置（java支持多种垃圾收集器，当然你或许连收集器的概念也不知道，赶紧看书去吧）" class="headerlink" title="3、收集器设置（java支持多种垃圾收集器，当然你或许连收集器的概念也不知道，赶紧看书去吧）"></a>3、收集器设置（java支持多种垃圾收集器，当然你或许连收集器的概念也不知道，赶紧看书去吧）</h3><p>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器</p><h3 id="4、垃圾回收统计信息（这个可以用于调试时候查看GC的情况）"><a href="#4、垃圾回收统计信息（这个可以用于调试时候查看GC的情况）" class="headerlink" title="4、垃圾回收统计信息（这个可以用于调试时候查看GC的情况）"></a>4、垃圾回收统计信息（这个可以用于调试时候查看GC的情况）</h3><p>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</p><h3 id="5、并行收集器设置"><a href="#5、并行收集器设置" class="headerlink" title="5、并行收集器设置"></a>5、并行收集器设置</h3><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p><h3 id="6、并发收集器设置"><a href="#6、并发收集器设置" class="headerlink" title="6、并发收集器设置"></a>6、并发收集器设置</h3><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p><h3 id="7、栈区设置（一般甚少用到，放最后）"><a href="#7、栈区设置（一般甚少用到，放最后）" class="headerlink" title="7、栈区设置（一般甚少用到，放最后）"></a>7、栈区设置（一般甚少用到，放最后）</h3><p>-Xss：每个线程的Stack大小，“-Xss 15120” 这使每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k. </p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka集群搭建步骤</title>
      <link href="/2018/01/12/%E8%BF%90%E7%BB%B4/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html"/>
      <content type="html"><![CDATA[<h3 id="1-下载kafka-scale编译版本不同，有不同的选择"><a href="#1-下载kafka-scale编译版本不同，有不同的选择" class="headerlink" title="1. 下载kafka(scale编译版本不同，有不同的选择)"></a>1. 下载kafka(scale编译版本不同，有不同的选择)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.apache.org/dyn/closer.cgi?path=/kafka/1.0.0/kafka_2.11-1.0.0.tgz</span><br><span class="line"><span class="comment">### 解压</span></span><br><span class="line">tar zxvf kafka_2.11-1.0.0.tgz</span><br><span class="line"><span class="comment">### 切换到kafka目录创建日志目录</span></span><br><span class="line"><span class="built_in">cd</span> kafka_2.11-1.0.0</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-配置server-properties"><a href="#2-配置server-properties" class="headerlink" title="2. 配置server.properties"></a>2. 配置<code>server.properties</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> config</span><br><span class="line">vi server.properties</span><br></pre></td></tr></table></figure><p>修改配置文件(按需修改)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 当前机器在集群中的唯一标识，和zookeeper的myid性质一样</span><br><span class="line">broker.id=0  </span><br><span class="line"># 当前kafka对外提供服务的端口默认是9092</span><br><span class="line"># port=9092 </span><br><span class="line"># 参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。</span><br><span class="line"># host.name=192.168.188.111 </span><br><span class="line">listeners=PLAINTEXT://192.168.188.111:9092</span><br><span class="line"># borker进行网络处理的线程数</span><br><span class="line">num.network.threads=3 </span><br><span class="line"># borker进行I/O处理的线程数</span><br><span class="line">num.io.threads=8 </span><br><span class="line"># 消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个</span><br><span class="line">log.dirs=/opt/microServer/kafka_2.11-1.0.0/logs</span><br><span class="line"># 发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能</span><br><span class="line">socket.send.buffer.bytes=102400 </span><br><span class="line"># kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘</span><br><span class="line">socket.receive.buffer.bytes=102400 </span><br><span class="line"> # 向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line"># 默认的分区数，一个topic默认1个分区数</span><br><span class="line">num.partitions=1</span><br><span class="line"># 默认消息的最大持久化时间，168小时，7天</span><br><span class="line">log.retention.hours=168</span><br><span class="line"># 消息保存的最大值5M</span><br><span class="line">message.max.byte=5242880  </span><br><span class="line"># kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务</span><br><span class="line">default.replication.factor=2 </span><br><span class="line"># 取消息的最大直接数 </span><br><span class="line">replica.fetch.max.bytes=5242880  </span><br><span class="line"># kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件</span><br><span class="line">log.segment.bytes=1073741824 </span><br><span class="line"># 每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除</span><br><span class="line">log.retention.check.interval.ms=300000 </span><br><span class="line"># 是否启用log压缩，一般不用启用，启用的话可以提高性能</span><br><span class="line">log.cleaner.enable=false</span><br><span class="line"># 设置zookeeper的连接端口</span><br><span class="line">zookeeper.connect=192.168.188.111:2181,192.168.188.112:2181,192.168.188.113:2181</span><br></pre></td></tr></table></figure></p><h3 id="3-启动Kafka集群并测试（zk开启）"><a href="#3-启动Kafka集群并测试（zk开启）" class="headerlink" title="3. 启动Kafka集群并测试（zk开启）"></a>3. 启动Kafka集群并测试（zk开启）</h3><ul><li><p>启动服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入kafka bin目录</span><br><span class="line"><span class="comment">##后台守护启动</span></span><br><span class="line">bin]<span class="comment"># ./kafka-server-start.sh -daemon ../config/server.properties</span></span><br></pre></td></tr></table></figure></li><li><p>检查服务是否启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jps</span></span><br><span class="line">2241 QuorumPeerMain</span><br><span class="line">3236 Jps</span><br><span class="line">3100 Kafka</span><br></pre></td></tr></table></figure></li><li><p>创建Topic来验证是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin]<span class="comment"># ./kafka-topics.sh --create --zookeeper 192.168.188.112:2181 --replication-factor 2 --partitions 1 --topic test</span></span><br><span class="line"><span class="comment">#创建一个broker，发布者</span></span><br><span class="line">bin]<span class="comment"># ./kafka-console-producer.sh --broker-list 192.168.188.112:9092 --topic test2</span></span><br><span class="line"><span class="string">''</span><span class="string">'在一台服务器上创建一个订阅者'</span><span class="string">''</span></span><br><span class="line">bin]<span class="comment"># ./kafka-console-consumer.sh --zookeeper 192.168.188.112:2181 --topic test2 --from-beginning</span></span><br></pre></td></tr></table></figure></li></ul><p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## server1</span><br><span class="line">bin]# ./kafka-console-producer.sh --broker-list 192.168.188.112:9092 --topic test2</span><br><span class="line">&gt;werwe</span><br><span class="line">&gt;hahaha</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">##server2 </span><br><span class="line">bin]# ./kafka-console-consumer.sh --zookeeper 192.168.188.112:2181 --topic test2 --from-beginning</span><br><span class="line">Using the ConsoleConsumer with old consumer is deprecated and will be removed in a future major release. Consider using the new consumer by passing [bootstrap-server] instead of [zookeeper].</span><br><span class="line">werwe</span><br><span class="line">hahaha</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式ID生成方法</title>
      <link href="/2018/01/07/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95.html"/>
      <content type="html"><![CDATA[<h3 id="1-使用数据库的-auto-increment-来生成全局唯一递增ID"><a href="#1-使用数据库的-auto-increment-来生成全局唯一递增ID" class="headerlink" title="1. 使用数据库的 auto_increment 来生成全局唯一递增ID"></a>1. 使用数据库的 auto_increment 来生成全局唯一递增ID</h3><p><strong>优点：</strong><br>（1）简单，使用数据库已有的功能<br>（2）能够保证唯一性<br>（3）能够保证递增性<br>（4）步长固定<br><strong>缺点：</strong><br>（1）可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了<br>（2）扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展<br><strong>改进方法：</strong><br>（1）增加主库，避免写入单点<br>（2）数据水平切分，保证各主库生成的ID不重复<br><img src="http://upload-images.jianshu.io/upload_images/3353177-636f805740d6e8a3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><p>如上图所述，由1个写库变成3个写库，<strong>每个写库设置不同的auto_increment初始值，以及相同的增长步长</strong>，以保证每个数据库生成的ID是不同的（上图中库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…）<br>改进后的架构保证了可用性，但<strong>缺点</strong>是：<br>（1）丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，我们的目标是趋势递增，不是绝对递增）<br>（2）数据库的写压力依然很大，每次生成ID都要访问数据库</p><h3 id="2-单点批量ID生成服务"><a href="#2-单点批量ID生成服务" class="headerlink" title="2. 单点批量ID生成服务"></a>2. 单点批量ID生成服务</h3><p>分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。<br><img src="http://upload-images.jianshu.io/upload_images/3353177-fa2d8f85b4c683fe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如0。ID生成服务假设每次批量拉取6个ID，服务访问数据库，将当前ID的最大值修改为5，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4,5这些ID了，当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6了。<br><strong>优点</strong>：<br>（1）保证了ID生成的绝对递增有序<br>（2）大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个<br><strong>缺点</strong>：<br>（1）服务仍然是单点<br>（2）如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4,5，数据库中max-id是5，分配到3时，服务重启了，下次会从6开始分配，4和5就成了空洞，不过这个问题也不大）<br>（3）虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展<br><strong>改进方法</strong>：<br>单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点（1）：</p><p><img src="http://upload-images.jianshu.io/upload_images/3353177-2793ac877c56a982?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。这个切换的过程对调用方是透明的，可以自动完成，常用的技术是vip+keepalived</p><h3 id="3-uuid"><a href="#3-uuid" class="headerlink" title="3. uuid"></a>3. uuid</h3><p>上述方案来生成ID，虽然性能大增，但由于是单点系统，总还是存在性能上限的。同时，上述两种方案，不管是数据库还是服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。有没有一种本地生成ID的方法，即高性能，又时延低呢？<br>uuid是一种常见的方案：string ID =GenUUID();<br><strong>优点：</strong><br>（1）本地生成ID，不需要进行远程调用，时延低<br>（2）扩展性好，基本可以认为没有性能上限<br><strong>缺点：</strong><br>（1）<strong>无法保证趋势递增</strong><br>（2）uuid过长，往往用字符串表示，作为主键<strong>建立索引查询效率低</strong>，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）</p><h3 id="4-取当前毫秒数"><a href="#4-取当前毫秒数" class="headerlink" title="4. 取当前毫秒数"></a>4. 取当前毫秒数</h3><p>uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？<br>取当前毫秒数是一种常见方案：uint64 ID = GenTimeMS();<br><strong>优点：</strong><br>（1）本地生成ID，不需要进行远程调用，时延低<br>（2）生成的ID趋势递增<br>（3）生成的ID是整数，建立索引后查询效率高<br><strong>缺点：</strong><br>（1）<strong>如果并发量超过1000，会生成重复的ID</strong>。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。</p><h3 id="5-snowflake算法"><a href="#5-snowflake算法" class="headerlink" title="5. snowflake算法"></a>5. snowflake算法</h3><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机<strong>每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID</strong>，完全能满足业务的需求。</p>]]></content>
      
      
        <tags>
            
            <tag> 分布式ID </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zookeeper集群搭建步骤</title>
      <link href="/2018/01/01/%E8%BF%90%E7%BB%B4/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4.html"/>
      <content type="html"><![CDATA[<ul><li>zookeeper服务器的数量是 <code>2*n+1</code>台<h2 id="zookeeper集群搭建步骤"><a href="#zookeeper集群搭建步骤" class="headerlink" title="zookeeper集群搭建步骤"></a>zookeeper集群搭建步骤</h2>本人下载目录为 /opt/microServer/ 集群ip为192.168.188.111、192.168.188.112、192.168.188.113<h3 id="1-下载zookeeper"><a href="#1-下载zookeeper" class="headerlink" title="1. 下载zookeeper"></a>1. 下载zookeeper</h3>执行命令下载<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</span><br><span class="line">tar -zxvf zookeeper-3.4.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zookeeper-3.4.11</span><br><span class="line"><span class="comment">## 创建 data和log文件夹</span></span><br><span class="line">mkdir data <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="2-进入conf文件夹，配置zookeeper"><a href="#2-进入conf文件夹，配置zookeeper" class="headerlink" title="2. 进入conf文件夹，配置zookeeper"></a>2. 进入conf文件夹，配置zookeeper</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line">cp zoo_sample.cfg  zoo.cfg</span><br></pre></td></tr></table></figure><h3 id="3-编辑zoo-cf文件"><a href="#3-编辑zoo-cf文件" class="headerlink" title="3. 编辑zoo.cf文件"></a>3. 编辑zoo.cf文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">## tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</span><br><span class="line">tickTime=2000</span><br><span class="line">## initLimit： 这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒</span><br><span class="line">initLimit=10</span><br><span class="line">## syncLimit：这个配置项标识 Leader 与Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是5*2000=10秒</span><br><span class="line">syncLimit=5</span><br><span class="line">## dataDir：快照日志的存储路径</span><br><span class="line">dataDir=/opt/microServer/zookeeper-3.4.11/data</span><br><span class="line">## dataLogDir：事物日志的存储路径，如果不配置这个那么事物日志会默认存储到dataDir制定的目录，这样会严重影响zk的性能，当zk吞吐量较大的时候，产生的事物日志、快照日志太多</span><br><span class="line">dataLogDir=/opt/microServer/zookeeper-3.4.11/log</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=192.168.188.111:12888:13888</span><br><span class="line">server.2=192.168.188.112:12888:13888</span><br><span class="line">server.3=192.168.188.113:12888:13888</span><br><span class="line">#server.1 这个1是服务器的标识也可以是其他的数字， 表示这个是第几号服务器，用来标识服务器，这个标识要写到快照目录下面myid文件里</span><br><span class="line">#192.168.188.111为集群里的IP地址，第一个端口是master和slave之间的通信端口，默认是2888，第二个端口是leader选举的端口，集群刚启动的时候选举或者leader挂掉之后进行新的选举的端口默认是3888</span><br></pre></td></tr></table></figure><h3 id="4-复制zookeeper到其他机器"><a href="#4-复制zookeeper到其他机器" class="headerlink" title="4.复制zookeeper到其他机器"></a>4.复制zookeeper到其他机器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r zookeeper-3.4.11/ root@192.168.188.112:/opt/microServer/</span><br><span class="line">scp -r zookeeper-3.4.11/ root@192.168.188.113:/opt/microServer/</span><br></pre></td></tr></table></figure><h3 id="4-创建myid文件"><a href="#4-创建myid文件" class="headerlink" title="4. 创建myid文件"></a>4. 创建myid文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /opt/microServer/zookeeper-3.4.11/data/myid</span><br><span class="line"><span class="comment">#server2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2"</span> &gt; /opt/microServer/zookeeper-3.4.11/data/myid</span><br><span class="line"><span class="comment">#server3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3"</span> &gt; /opt/microServer/zookeeper-3.4.11/data/myid</span><br></pre></td></tr></table></figure><h3 id="启动服务并查看-可以在-etc-profile配置zk"><a href="#启动服务并查看-可以在-etc-profile配置zk" class="headerlink" title="启动服务并查看(可以在/etc/profile配置zk)"></a>启动服务并查看(可以在/etc/profile配置zk)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入到Zookeeper的bin目录下</span></span><br><span class="line"><span class="built_in">cd</span> /opt/zookeeper/zookeeper-3.4.6/bin</span><br><span class="line"><span class="comment">#启动服务（3台都需要操作）</span></span><br><span class="line">./zkServer.sh start</span><br><span class="line"><span class="comment">#检查服务器状态</span></span><br><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3353177-5f3aa2c07079af7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br><img src="http://upload-images.jianshu.io/upload_images/3353177-79931c930bf42288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br><img src="http://upload-images.jianshu.io/upload_images/3353177-ab82da0571ad20f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="*注意事项："></a>*注意事项：</h3><p>如果zkServer.sh status出现以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">]# zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/microserver/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Error contacting service. It is probably not running.</span><br></pre></td></tr></table></figure></p><p>到 /root/zookeeper.out看报错信息。如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> [myid:1] - WARN  [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:2181:Learner@237] - Unexpected exception, tries=0, connecting to /192.168.188.113:12888</span><br><span class="line">java.net.ConnectException: 拒绝连接 (Connection refused)</span><br><span class="line">at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">at org.apache.zookeeper.server.quorum.Learner.connectToLeader(Learner.java:229)</span><br><span class="line">at org.apache.zookeeper.server.quorum.Follower.followLeader(Follower.java:72)</span><br><span class="line">at org.apache.zookeeper.server.quorum.QuorumPeer.run(QuorumPeer.java:981)</span><br><span class="line">2018-01-14 20:35:45,726 [myid:1] - INFO  [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:2181:Learner@332] - Getting a diff from the leader 0x0</span><br></pre></td></tr></table></figure></p><p>这种情况需要关闭防火墙,执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br><span class="line">firewall-cmd --state <span class="comment">#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 集群 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[转载]关于垃圾回收被误解的 7 件事</title>
      <link href="/2017/12/30/java/%E8%BD%AC%E8%BD%BD-%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84-7-%E4%BB%B6%E4%BA%8B.html"/>
      <content type="html"><![CDATA[<h5 id="对Java垃圾回收最大的误解是什么？它实际又是什么样的呢？"><a href="#对Java垃圾回收最大的误解是什么？它实际又是什么样的呢？" class="headerlink" title="对Java垃圾回收最大的误解是什么？它实际又是什么样的呢？"></a>对Java垃圾回收最大的误解是什么？它实际又是什么样的呢？</h5><p>当我还是小孩的时候，父母常说如果你不好好学习，就只能去扫大街了。但他们不知道的是，清理垃圾实际上是很棒的一件事。可能这也是即使在Java的世界中， 同样有很多开发者对GC算法产生误解的原因——包括它们怎样工作、GC是如何影响程序运行和你能对它做些什么。因此我们找到了Java性能调优专家<a href="https://twitter.com/lifeyx" target="_blank" rel="noopener">Haim Yadid</a>，并把名为<a href="http://blog.takipi.com/java-performance-tuning-how-to-get-the-most-out-of-your-garbage-collector/?utm_source=blog&amp;utm_medium=in-post&amp;utm_content=gcmisconceptions&amp;utm_campaign=java" target="_blank" rel="noopener">Java performance tuning guide</a>的文章发表在Takipi的博客上。<br><a id="more"></a><br>最新博文：关于垃圾回收被误解的7件事<br><a href="http://t.co/3QJLJuKCRq" target="_blank" rel="noopener">http://t.co/3QJLJuKCRq</a><a href="http://www.importnew.com/pic.twitter.com/aqQEF0zTkK" target="_blank" rel="noopener">pic.twitter.com/aqQEF0zTkK</a><br>— Takipi (@takipid) April 6, 2015</p><p>带着对性能调优指南浓厚的兴趣，我们决定在这篇后续的博文中收集一些关于垃圾回收的流行观点，并且指出为什么它们完全是错误的。</p><p>来看看前7名：</p><h3 id="1-只有一个垃圾回收器"><a href="#1-只有一个垃圾回收器" class="headerlink" title="1. 只有一个垃圾回收器"></a>1. 只有一个垃圾回收器</h3><p>不，并且4也是错误的答案。HotSpot JVM一共有4个垃圾回收器：<a href="http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/?utm_source=blog&amp;utm_medium=in-post&amp;utm_content=gcmisconceptions&amp;utm_campaign=java" target="_blank" rel="noopener">Serial, Parallel / Throughput. CMS, and the new kid on the block G1</a>。别急，另外还有一些非标准的垃圾回收器和更大胆的实现，比如<a href="http://openjdk.java.net/jeps/189" target="_blank" rel="noopener">Shenandoah</a>或 者其他JVM使用的回收器（C4——Azul开发的无停顿回收器）。HotSpot默认使用Parallel / Throughput回收器，但它常常不是你运行程序的最佳选择。比如CMS和G1会使GC停顿（GC pause）发生的频率降低，但是对于每次停顿所花费的时间，很可能比Parallel回收器更长。另一方面来说，在使用相同大小堆内存的情况下，Parallel回收器能带来更高的吞吐量。</p><p><strong>结论：</strong>根据你的需求（可接受的GC停顿频率和持续时间）选择合适的垃圾回收器。</p><h3 id="2-并行（Parallel）-＝-并发（Concurrent）"><a href="#2-并行（Parallel）-＝-并发（Concurrent）" class="headerlink" title="2. 并行（Parallel） ＝ 并发（Concurrent）"></a>2. 并行（Parallel） ＝ 并发（Concurrent）</h3><p>一个GC周期（Garbage Collection cycle）可以以STW（Stop-The-World）的形式出现，这会发生一次GC停顿，也可以并发地执行从而无需暂停应用程序。更进一步来 讲，GC算法本身可以是串行的（单线程），也可以是并行的（多线程）。因此当我们提到并发的GC时，并不代表它是并行完成的，相反当提到串行GC时，也并 不意味着就一定会出现GC停顿。在GC的世界中，并发和并行是两个完全不同的概念。并发针对的是GC周期，而并行针对GC算法自身。</p><p><strong>结论：</strong>垃圾回收的过程实际上有两步，启动GC周期和GC自身运行，这是不同的两件事。</p><h3 id="3-G1能解决所有问题"><a href="#3-G1能解决所有问题" class="headerlink" title="3. G1能解决所有问题"></a>3. G1能解决所有问题</h3><p>经过一系列修正和改 进，Java 7中引入了G1回收器，它是JVM垃圾回收器中最新的组件。G1最大的优势就是解决了CMS中常见的内存碎片问题：GC周期会从老年代（Old Generation）中释放内存块，结果内存变得像瑞士奶酪那样千疮百孔，直到JVM对其无从下手了，才不得不停下来处理这些碎片。但是故事没这么简 单，某些情况下其他回收器可能比G1有更好的表现，这完全取决于你的需求。</p><p><strong>结论：</strong>没有一个奇迹般的回收器能解决所有GC问题，你应该通过具体实验来选择合适的回收器。</p><h3 id="4-平均事务时间是最需要被关注的指标"><a href="#4-平均事务时间是最需要被关注的指标" class="headerlink" title="4. 平均事务时间是最需要被关注的指标"></a>4. 平均事务时间是最需要被关注的指标</h3><p>如 果你仅仅监控服务器的平均事务时间，那么很可能错过一些异常值。这些异常的情况可能对用户来说是毁灭性的，而人们没有意识到它的重要性。比如一个事务在正常情况下耗时100ms，但受到GC停顿的影响，花了1分钟才完成。除了用户没人会注意到这个问题，因为你只观察了平均事务时间。试想有1%或者更多的用 户经历了这个场景，如果只关注平均值，它就太容易被忽略了。想了解更多和延迟相关的问题和怎样正确处理，可以在<a href="http://latencytipoftheday.blogspot.com/" target="_blank" rel="noopener">这里</a>阅读<a href="https://twitter.com/giltene" target="_blank" rel="noopener">Gil Tene</a>的博客。</p><p><strong>结论：</strong>留心那些异常值，你可以知道系统最后那1%的状况。（<a href="http://cdn.zmescience.com/wp-content/uploads/2014/04/Who-Is-The-1.jpg" target="_blank" rel="noopener">可不是这个1%</a>）</p><h3 id="5-降低新对象的分配率可以改善GC的运行状况"><a href="#5-降低新对象的分配率可以改善GC的运行状况" class="headerlink" title="5. 降低新对象的分配率可以改善GC的运行状况"></a>5. 降低新对象的分配率可以改善GC的运行状况</h3><p>我们可以 粗略地把系统中的对象分为三种：长命（long-lived）对象，对它们我们一般做不了什么；中等寿命（mid-lived）对象，最大的问题可能出现在这；短命（short-lived）对象，它们的释放和回收通常都很快，在下个GC周期来临时就会消失。专注于中等寿命对象的分配率可以带来有益的结 果，这对短命和长命的对象却不是那么有效。另外，控制中等寿命对象往往是一项困难的工作。</p><p><strong>结论：</strong>给服务器带来压力的并不单纯是对象的分配率，在运行过程中这些对象的种类才是一切麻烦的根源。</p><h3 id="6-调优可以解决所有事"><a href="#6-调优可以解决所有事" class="headerlink" title="6. 调优可以解决所有事"></a>6. 调优可以解决所有事</h3><p>如果你的程序需要保存大量被频繁修改的状态，对JVM堆内存进行调优就无法带来很好的收益。较长的GC停顿是不可避免的。一个解决办 法是对架构进行改善，保证一个对响应时间有决定性影响或者造成瓶颈的过程中，不包含大量状态。大量状态和响应能力是难以良好共存的，因此将它们分开处理才 是上上之选。</p><p><strong>结论：</strong>不是所有的问题都可以通过调整JVM参数解决，有时你只需要回顾自己的绘图板。</p><p>（译注：重新审视程序的设计）</p><h3 id="7-GC日志会导致巨大的系统开销"><a href="#7-GC日志会导致巨大的系统开销" class="headerlink" title="7. GC日志会导致巨大的系统开销"></a>7. GC日志会导致巨大的系统开销</h3><p>简单来说，这是错的，尤 其在默认的日志配置下。日志数据是极为有价值的，Java 7中还引入了钩子来控制它们的大小，保证硬盘空间不被用尽。如果不收集GC日志，那么你会失去这几乎是唯一的，知晓JVM垃圾回收器在生产环境中工作状态 的方法。一般可接受的GC开销以5%作为上限，如果你能知道系统为GC停顿付出的代价，也能对最小化这个代价采取行动，这种程度的开销是不值一提的。</p><p><strong>结论：</strong>在能力范围内，尽可能多地获取系统在生产环境中的运行数据，你会发现那是一个全新的世界。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望上面的结论能帮助你们更好地把握Java垃圾回收器的工作。在你们的程序中出现过类似问题吗？你们周围还有没有其他对GC常见的误解？请在下面的评论区留言。</p><p>原文链接：</p><p> <a href="http://www.javacodegeeks.com/2015/04/7-things-you-thought-you-knew-about-garbage-collection-and-are-totally-wrong.html" target="_blank" rel="noopener">javacodegeeks</a> </p><p>翻译：</p><p> <a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew.com</a> </p><p>-</p><p> <a href="http://www.importnew.com/author/jiangshengwu" target="_blank" rel="noopener">蒋 生武</a></p><p>译文链接：</p><p> <a href="http://www.importnew.com/15796.html" target="_blank" rel="noopener">http://www.importnew.com/15796.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hashmap为什么在发生hash冲突后把元素放在链表的头部？</title>
      <link href="/2017/12/30/java/hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%8F%91%E7%94%9Fhash%E5%86%B2%E7%AA%81%E5%90%8E%E6%8A%8A%E5%85%83%E7%B4%A0%E6%94%BE%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E9%83%A8%EF%BC%9F.html"/>
      <content type="html"><![CDATA[<p>有回答说是因为最后放入的元素会被再次操作的机会很大，所以放在头部，提高再次获取的效率，这个解释不能让人信服。 其实，仔细想想如果不放在头部，放在尾部或其它位置，是不是需要遍历，找到指定位置，如果链表的长度很长，性能会很低，反而不如放在链表的头部高效。 我个人觉得也不尽然，存放一个尾部地址也是分分钟钟的事，实现起来也不复杂，我还是比较倾向于第一种考虑，开发作者就是有这样的认知或统计:插入的数据被马上访问的概率也就越大。有没有其他的解释？</p>]]></content>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一次线上数据库添加字段造成磁盘不够的问题</title>
      <link href="/2017/12/30/DB/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5%E9%80%A0%E6%88%90%E7%A3%81%E7%9B%98%E4%B8%8D%E5%A4%9F%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司使用的是MySQL数据库，随着业务和用户的增加有张表的数据达到了150000000（1亿5千万）条左右，其中好几个功能都会对这张表进行增删改操作。在并发量比较大的时候，经常会出现死锁问题。<br>为了解决这个问题找到CTO和其他领导来请教方案。<br><a id="more"></a><br>经过分析之后，由于离业务繁忙期还有几天，并且1月是系统达到最大并发的时期，所以决定暂时先采取比较稳妥的版本号方案，即只往数据库insert和update数据，定时任务删除旧的数据（之后会采取数据分表分区的方案）版本号记录在redis里面。于是花了2天左右的时间把这些业务里面的代码重构和修改了一遍（其中涉及到使用第三方库修改的代码，修改这部分花了很多时间）。经测试人员测试没问题后，准备发到线上。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>要刷入得的SQL如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> K_VERSION <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>;</span><br></pre></td></tr></table></figure></p><p>17年12月29日凌晨左右，运维开始执行sql。到1点多的时候，运维说数据库所在的服务器硬盘满了，导致刷入失败。里面有人开始议论说，不就是刷入字段吗，怎么会造成磁盘满呢？运维当时立马通过阿里云德后台把数据库的服务器磁盘增大。当时我的第一反应：肯定这个SQL在表数据量大的时候会有问题。搜索之后发现，当数据量很大的时候，会占大量的undo空间，同时还会锁表。所以要想解决问题必须分开执行sql 最后执行sql如下:<br> 第一步:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> xxx  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> K_VERSION <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">COMMENT</span> <span class="string">'版本</span></span><br></pre></td></tr></table></figure></p><p>  第二步:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> XXX <span class="keyword">MODIFY</span>(K_VERSION  <span class="keyword">DEFAULT</span> <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>第三步:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> XXX <span class="keyword">set</span> K_VERSION=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>之后也没有出现刷sql挂服务器的问题。</p>]]></content>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java获取服务器所有信息</title>
      <link href="/2017/11/01/java/java%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF.html"/>
      <content type="html"><![CDATA[<p>java获取服务器所有信息代码如下<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line">package com.sinosoft.outher.listener;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.hyperic.sigar.CpuInfo;</span><br><span class="line">import org.hyperic.sigar.CpuPerc;</span><br><span class="line">import org.hyperic.sigar.FileSystem;</span><br><span class="line">import org.hyperic.sigar.FileSystemUsage;</span><br><span class="line">import org.hyperic.sigar.Mem;</span><br><span class="line">import org.hyperic.sigar.NetFlags;</span><br><span class="line">import org.hyperic.sigar.NetInterfaceConfig;</span><br><span class="line">import org.hyperic.sigar.NetInterfaceStat;</span><br><span class="line">import org.hyperic.sigar.OperatingSystem;</span><br><span class="line">import org.hyperic.sigar.Sigar;</span><br><span class="line">import org.hyperic.sigar.SigarException;</span><br><span class="line">import org.hyperic.sigar.Swap;</span><br><span class="line">import org.hyperic.sigar.Who;</span><br><span class="line">public class SysListener &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // System信息，从jvm获取</span><br><span class="line">            property();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // cpu信息</span><br><span class="line">            cpu();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 内存信息</span><br><span class="line">            memory();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 操作系统信息</span><br><span class="line">            os();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 用户信息</span><br><span class="line">            who();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 文件系统信息</span><br><span class="line">            file();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 网络信息</span><br><span class="line">            net();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">            // 以太网信息</span><br><span class="line">            ethernet();</span><br><span class="line">            System.out.println(&quot;-&quot;);</span><br><span class="line">        &#125; catch (Exception e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void property() throws UnknownHostException &#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        Properties props = System.getProperties();</span><br><span class="line">        InetAddress addr;</span><br><span class="line">        addr = InetAddress.getLocalHost();</span><br><span class="line">        String ip = addr.getHostAddress();</span><br><span class="line">        Map&lt;String, String&gt; map = System.getenv();</span><br><span class="line">        String userName = map.get(&quot;USERNAME&quot;);// 获取用户名</span><br><span class="line">        String computerName = map.get(&quot;COMPUTERNAME&quot;);// 获取计算机名</span><br><span class="line">        String userDomain = map.get(&quot;USERDOMAIN&quot;);// 获取计算机域名</span><br><span class="line">        System.out.println(&quot;用户名:    &quot; + userName);</span><br><span class="line">        System.out.println(&quot;计算机名:    &quot; + computerName);</span><br><span class="line">        System.out.println(&quot;计算机域名:    &quot; + userDomain);</span><br><span class="line">        System.out.println(&quot;本地ip地址:    &quot; + ip);</span><br><span class="line">        System.out.println(&quot;本地主机名:    &quot; + addr.getHostName());</span><br><span class="line">        System.out.println(&quot;JVM可以使用的总内存:    &quot; + r.totalMemory());</span><br><span class="line">        System.out.println(&quot;JVM可以使用的剩余内存:    &quot; + r.freeMemory());</span><br><span class="line">        System.out.println(&quot;JVM可以使用的处理器个数:    &quot; + r.availableProcessors());</span><br><span class="line">        System.out.println(&quot;Java的运行环境版本：    &quot; + props.getProperty(&quot;java.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java的运行环境供应商：    &quot; + props.getProperty(&quot;java.vendor&quot;));</span><br><span class="line">        System.out.println(&quot;Java供应商的URL：    &quot; + props.getProperty(&quot;java.vendor.url&quot;));</span><br><span class="line">        System.out.println(&quot;Java的安装路径：    &quot; + props.getProperty(&quot;java.home&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机规范版本：    &quot; + props.getProperty(&quot;java.vm.specification.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机规范供应商：    &quot; + props.getProperty(&quot;java.vm.specification.vendor&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机规范名称：    &quot; + props.getProperty(&quot;java.vm.specification.name&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机实现版本：    &quot; + props.getProperty(&quot;java.vm.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机实现供应商：    &quot; + props.getProperty(&quot;java.vm.vendor&quot;));</span><br><span class="line">        System.out.println(&quot;Java的虚拟机实现名称：    &quot; + props.getProperty(&quot;java.vm.name&quot;));</span><br><span class="line">        System.out.println(&quot;Java运行时环境规范版本：    &quot; + props.getProperty(&quot;java.specification.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java运行时环境规范供应商：    &quot; + props.getProperty(&quot;java.specification.vender&quot;));</span><br><span class="line">        System.out.println(&quot;Java运行时环境规范名称：    &quot; + props.getProperty(&quot;java.specification.name&quot;));</span><br><span class="line">        System.out.println(&quot;Java的类格式版本号：    &quot; + props.getProperty(&quot;java.class.version&quot;));</span><br><span class="line">        System.out.println(&quot;Java的类路径：    &quot; + props.getProperty(&quot;java.class.path&quot;));</span><br><span class="line">        System.out.println(&quot;加载库时搜索的路径列表：    &quot; + props.getProperty(&quot;java.library.path&quot;));</span><br><span class="line">        System.out.println(&quot;默认的临时文件路径：    &quot; + props.getProperty(&quot;java.io.tmpdir&quot;));</span><br><span class="line">        System.out.println(&quot;一个或多个扩展目录的路径：    &quot; + props.getProperty(&quot;java.ext.dirs&quot;));</span><br><span class="line">        System.out.println(&quot;操作系统的名称：    &quot; + props.getProperty(&quot;os.name&quot;));</span><br><span class="line">        System.out.println(&quot;操作系统的构架：    &quot; + props.getProperty(&quot;os.arch&quot;));</span><br><span class="line">        System.out.println(&quot;操作系统的版本：    &quot; + props.getProperty(&quot;os.version&quot;));</span><br><span class="line">        System.out.println(&quot;文件分隔符：    &quot; + props.getProperty(&quot;file.separator&quot;));</span><br><span class="line">        System.out.println(&quot;路径分隔符：    &quot; + props.getProperty(&quot;path.separator&quot;));</span><br><span class="line">        System.out.println(&quot;行分隔符：    &quot; + props.getProperty(&quot;line.separator&quot;));</span><br><span class="line">        System.out.println(&quot;用户的账户名称：    &quot; + props.getProperty(&quot;user.name&quot;));</span><br><span class="line">        System.out.println(&quot;用户的主目录：    &quot; + props.getProperty(&quot;user.home&quot;));</span><br><span class="line">        System.out.println(&quot;用户的当前工作目录：    &quot; + props.getProperty(&quot;user.dir&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void memory() throws SigarException &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        Mem mem = sigar.getMem();</span><br><span class="line">        // 内存总量</span><br><span class="line">        System.out.println(&quot;内存总量:    &quot; + mem.getTotal() / 1024L + &quot;K av&quot;);</span><br><span class="line">        // 当前内存使用量</span><br><span class="line">        System.out.println(&quot;当前内存使用量:    &quot; + mem.getUsed() / 1024L + &quot;K used&quot;);</span><br><span class="line">        // 当前内存剩余量</span><br><span class="line">        System.out.println(&quot;当前内存剩余量:    &quot; + mem.getFree() / 1024L + &quot;K free&quot;);</span><br><span class="line">        Swap swap = sigar.getSwap();</span><br><span class="line">        // 交换区总量</span><br><span class="line">        System.out.println(&quot;交换区总量:    &quot; + swap.getTotal() / 1024L + &quot;K av&quot;);</span><br><span class="line">        // 当前交换区使用量</span><br><span class="line">        System.out.println(&quot;当前交换区使用量:    &quot; + swap.getUsed() / 1024L + &quot;K used&quot;);</span><br><span class="line">        // 当前交换区剩余量</span><br><span class="line">        System.out.println(&quot;当前交换区剩余量:    &quot; + swap.getFree() / 1024L + &quot;K free&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void cpu() throws SigarException &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        CpuInfo infos[] = sigar.getCpuInfoList();</span><br><span class="line">        CpuPerc cpuList[] = null;</span><br><span class="line">        cpuList = sigar.getCpuPercList();</span><br><span class="line">        for (int i = 0; i &lt; infos.length; i++) &#123;// 不管是单块CPU还是多CPU都适用</span><br><span class="line">            CpuInfo info = infos[i];</span><br><span class="line">            System.out.println(&quot;第&quot; + (i + 1) + &quot;块CPU信息&quot;);</span><br><span class="line">            System.out.println(&quot;CPU的总量MHz:    &quot; + info.getMhz());// CPU的总量MHz</span><br><span class="line">            System.out.println(&quot;CPU生产商:    &quot; + info.getVendor());// 获得CPU的卖主，如：Intel</span><br><span class="line">            System.out.println(&quot;CPU类别:    &quot; + info.getModel());// 获得CPU的类别，如：Celeron</span><br><span class="line">            System.out.println(&quot;CPU缓存数量:    &quot; + info.getCacheSize());// 缓冲存储器数量</span><br><span class="line">            printCpuPerc(cpuList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printCpuPerc(CpuPerc cpu) &#123;</span><br><span class="line">        System.out.println(&quot;CPU用户使用率:    &quot; + CpuPerc.format(cpu.getUser()));// 用户使用率</span><br><span class="line">        System.out.println(&quot;CPU系统使用率:    &quot; + CpuPerc.format(cpu.getSys()));// 系统使用率</span><br><span class="line">        System.out.println(&quot;CPU当前等待率:    &quot; + CpuPerc.format(cpu.getWait()));// 当前等待率</span><br><span class="line">        System.out.println(&quot;CPU当前错误率:    &quot; + CpuPerc.format(cpu.getNice()));//</span><br><span class="line">        System.out.println(&quot;CPU当前空闲率:    &quot; + CpuPerc.format(cpu.getIdle()));// 当前空闲率</span><br><span class="line">        System.out.println(&quot;CPU总的使用率:    &quot; + CpuPerc.format(cpu.getCombined()));// 总的使用率</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void os() &#123;</span><br><span class="line">        OperatingSystem OS = OperatingSystem.getInstance();</span><br><span class="line">        // 操作系统内核类型如： 386、486、586等x86</span><br><span class="line">        System.out.println(&quot;操作系统:    &quot; + OS.getArch());</span><br><span class="line">        System.out.println(&quot;操作系统CpuEndian():    &quot; + OS.getCpuEndian());//</span><br><span class="line">        System.out.println(&quot;操作系统DataModel():    &quot; + OS.getDataModel());//</span><br><span class="line">        // 系统描述</span><br><span class="line">        System.out.println(&quot;操作系统的描述:    &quot; + OS.getDescription());</span><br><span class="line">        // 操作系统类型</span><br><span class="line">        // System.out.println(&quot;OS.getName():    &quot; + OS.getName());</span><br><span class="line">        // System.out.println(&quot;OS.getPatchLevel():    &quot; + OS.getPatchLevel());//</span><br><span class="line">        // 操作系统的卖主</span><br><span class="line">        System.out.println(&quot;操作系统的卖主:    &quot; + OS.getVendor());</span><br><span class="line">        // 卖主名称</span><br><span class="line">        System.out.println(&quot;操作系统的卖主名:    &quot; + OS.getVendorCodeName());</span><br><span class="line">        // 操作系统名称</span><br><span class="line">        System.out.println(&quot;操作系统名称:    &quot; + OS.getVendorName());</span><br><span class="line">        // 操作系统卖主类型</span><br><span class="line">        System.out.println(&quot;操作系统卖主类型:    &quot; + OS.getVendorVersion());</span><br><span class="line">        // 操作系统的版本号</span><br><span class="line">        System.out.println(&quot;操作系统的版本号:    &quot; + OS.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void who() throws SigarException &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        Who who[] = sigar.getWhoList();</span><br><span class="line">        if (who != null &amp;&amp; who.length &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; who.length; i++) &#123;</span><br><span class="line">                // System.out.println(&quot;当前系统进程表中的用户名&quot; + String.valueOf(i));</span><br><span class="line">                Who _who = who[i];</span><br><span class="line">                System.out.println(&quot;用户控制台:    &quot; + _who.getDevice());</span><br><span class="line">                System.out.println(&quot;用户host:    &quot; + _who.getHost());</span><br><span class="line">                // System.out.println(&quot;getTime():    &quot; + _who.getTime());</span><br><span class="line">                // 当前系统进程表中的用户名</span><br><span class="line">                System.out.println(&quot;当前系统进程表中的用户名:    &quot; + _who.getUser());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;private static void file() throws Exception &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        FileSystem fslist[] = sigar.getFileSystemList();</span><br><span class="line">        for (int i = 0; i &lt; fslist.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;分区的盘符名称&quot; + i);</span><br><span class="line">            FileSystem fs = fslist[i];</span><br><span class="line">            // 分区的盘符名称</span><br><span class="line">            System.out.println(&quot;盘符名称:    &quot; + fs.getDevName());</span><br><span class="line">            // 分区的盘符名称</span><br><span class="line">            System.out.println(&quot;盘符路径:    &quot; + fs.getDirName());</span><br><span class="line">            System.out.println(&quot;盘符标志:    &quot; + fs.getFlags());//</span><br><span class="line">            // 文件系统类型，比如 FAT32、NTFS</span><br><span class="line">            System.out.println(&quot;盘符类型:    &quot; + fs.getSysTypeName());</span><br><span class="line">            // 文件系统类型名，比如本地硬盘、光驱、网络文件系统等</span><br><span class="line">            System.out.println(&quot;盘符类型名:    &quot; + fs.getTypeName());</span><br><span class="line">            // 文件系统类型</span><br><span class="line">            System.out.println(&quot;盘符文件系统类型:    &quot; + fs.getType());</span><br><span class="line">            FileSystemUsage usage = null;</span><br><span class="line">            switch (fs.getType()) &#123;</span><br><span class="line">            case 0: // TYPE_UNKNOWN ：未知</span><br><span class="line">                break;</span><br><span class="line">            case 1: // TYPE_NONE</span><br><span class="line">                break;</span><br><span class="line">            case 2: // TYPE_LOCAL_DISK : 本地硬盘</span><br><span class="line">                // 文件系统总大小</span><br><span class="line">            usage = sigar.getFileSystemUsage(fs.getDirName());</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;总大小:    &quot; + usage.getTotal() + &quot;KB&quot;);</span><br><span class="line">                // 文件系统剩余大小</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;剩余大小:    &quot; + usage.getFree() + &quot;KB&quot;);</span><br><span class="line">                // 文件系统可用大小</span><br><span class="line">System.out.println(fs.getDevName() + &quot;可用大小: &quot; + usage.getAvail() + &quot;KB&quot;);</span><br><span class="line">                // 文件系统已经使用量</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;已经使用量:    &quot; + usage.getUsed() + &quot;KB&quot;);</span><br><span class="line">                double usePercent = usage.getUsePercent() * 100D;</span><br><span class="line">                // 文件系统资源的利用率</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;资源的利用率:    &quot; + usePercent + &quot;%&quot;);</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;读出：    &quot; + usage.getDiskReads());</span><br><span class="line">                System.out.println(fs.getDevName() + &quot;写入：    &quot; + usage.getDiskWrites());</span><br><span class="line">                break;</span><br><span class="line">            case 3:// TYPE_NETWORK ：网络</span><br><span class="line">                break;</span><br><span class="line">            case 4:// TYPE_RAM_DISK ：闪存</span><br><span class="line">                break;</span><br><span class="line">            case 5:// TYPE_CDROM ：光驱</span><br><span class="line">                break;</span><br><span class="line">            case 6:// TYPE_SWAP ：页面交换</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void net() throws Exception &#123;</span><br><span class="line">        Sigar sigar = new Sigar();</span><br><span class="line">        String ifNames[] = sigar.getNetInterfaceList();</span><br><span class="line">        for (int i = 0; i &lt; ifNames.length; i++) &#123;</span><br><span class="line">            String name = ifNames[i];</span><br><span class="line">            NetInterfaceConfig ifconfig = sigar.getNetInterfaceConfig(name);</span><br><span class="line">            System.out.println(&quot;网络设备名:    &quot; + name);// 网络设备名</span><br><span class="line">            System.out.println(&quot;IP地址:    &quot; + ifconfig.getAddress());// IP地址</span><br><span class="line">            System.out.println(&quot;子网掩码:    &quot; + ifconfig.getNetmask());// 子网掩码</span><br><span class="line">            if ((ifconfig.getFlags() &amp; 1L) &lt;= 0L) &#123;</span><br><span class="line">                System.out.println(&quot;!IFF_UP...skipping getNetInterfaceStat&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            NetInterfaceStat ifstat = sigar.getNetInterfaceStat(name);</span><br><span class="line">            System.out.println(name + &quot;接收的总包裹数:&quot; + ifstat.getRxPackets());// 接收的总包裹数</span><br><span class="line">            System.out.println(name + &quot;发送的总包裹数:&quot; + ifstat.getTxPackets());// 发送的总包裹数</span><br><span class="line">            System.out.println(name + &quot;接收到的总字节数:&quot; + ifstat.getRxBytes());// 接收到的总字节数</span><br><span class="line">            System.out.println(name + &quot;发送的总字节数:&quot; + ifstat.getTxBytes());// 发送的总字节数</span><br><span class="line">            System.out.println(name + &quot;接收到的错误包数:&quot; + ifstat.getRxErrors());// 接收到的错误包数</span><br><span class="line">            System.out.println(name + &quot;发送数据包时的错误数:&quot; + ifstat.getTxErrors());// 发送数据包时的错误数</span><br><span class="line">            System.out.println(name + &quot;接收时丢弃的包数:&quot; + ifstat.getRxDropped());// 接收时丢弃的包数</span><br><span class="line">            System.out.println(name + &quot;发送时丢弃的包数:&quot; + ifstat.getTxDropped());// 发送时丢弃的包数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void ethernet() throws SigarException &#123;</span><br><span class="line">        Sigar sigar = null;</span><br><span class="line">        sigar = new Sigar();</span><br><span class="line">        String[] ifaces = sigar.getNetInterfaceList();</span><br><span class="line">        for (int i = 0; i &lt; ifaces.length; i++) &#123;</span><br><span class="line">            NetInterfaceConfig cfg = sigar.getNetInterfaceConfig(ifaces[i]);</span><br><span class="line">            if (NetFlags.LOOPBACK_ADDRESS.equals(cfg.getAddress()) (cfg.getFlags() &amp; NetFlags.IFF_LOOPBACK) != 0</span><br><span class="line">                    NetFlags.NULL_HWADDR.equals(cfg.getHwaddr())) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(cfg.getName() + &quot;IP地址:&quot; + cfg.getAddress());// IP地址</span><br><span class="line">            System.out.println(cfg.getName() + &quot;网关广播地址:&quot; + cfg.getBroadcast());// 网关广播地址</span><br><span class="line">            System.out.println(cfg.getName() + &quot;网卡MAC地址:&quot; + cfg.getHwaddr());// 网卡MAC地址</span><br><span class="line">            System.out.println(cfg.getName() + &quot;子网掩码:&quot; + cfg.getNetmask());// 子网掩码</span><br><span class="line">            System.out.println(cfg.getName() + &quot;网卡描述信息:&quot; + cfg.getDescription());// 网卡描述信息</span><br><span class="line">            System.out.println(cfg.getName() + &quot;网卡类型&quot; + cfg.getType());//</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title> Spring AOP获取请求URL的入参及返回值(通用方法)</title>
      <link href="/2017/10/26/java/Spring-AOP%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82URL%E7%9A%84%E5%85%A5%E5%8F%82%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html"/>
      <content type="html"><![CDATA[<p>以下代码为通用的代码，其中json解析使用的是fastJson，可以记录用户访问的ip、url、入参和出参<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author jasonLu</span><br><span class="line"> * @date 2017/10/26 9:57</span><br><span class="line"> * @Description:获取请求的入参和出参</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class RequestAspect &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RequestAspect.class);</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)&quot;)</span><br><span class="line">    public void pointcut()</span><br><span class="line">    &#123;</span><br><span class="line">        // 空方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Around(&quot;pointcut()&quot;)</span><br><span class="line">    public Object handle(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        //IP地址</span><br><span class="line">        String ipAddr = getRemoteHost(request);</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        String reqParam = preHandle(joinPoint,request);</span><br><span class="line">        logger.info(&quot;请求源IP:【&#123;&#125;】,请求URL:【&#123;&#125;】,请求参数:【&#123;&#125;】&quot;,ipAddr,url,reqParam);</span><br><span class="line"></span><br><span class="line">        Object result= joinPoint.proceed();</span><br><span class="line">        String respParam = postHandle(result);</span><br><span class="line">        logger.info(&quot;请求源IP:【&#123;&#125;】,请求URL:【&#123;&#125;】,返回参数:【&#123;&#125;】&quot;,ipAddr,url,respParam);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入参数据</span><br><span class="line">     * @param joinPoint</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String preHandle(ProceedingJoinPoint joinPoint,HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        String reqParam = &quot;&quot;;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method targetMethod = methodSignature.getMethod();</span><br><span class="line">        Annotation[] annotations = targetMethod.getAnnotations();</span><br><span class="line">        for (Annotation annotation : annotations) &#123;</span><br><span class="line">            //此处可以改成自定义的注解</span><br><span class="line">            if (annotation.annotationType().equals(RequestMapping.class)) &#123;</span><br><span class="line">                reqParam = JSON.toJSONString(request.getParameterMap());</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return reqParam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回数据</span><br><span class="line">     * @param retVal</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String postHandle(Object retVal) &#123;</span><br><span class="line">        if(null == retVal)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return JSON.toJSONString(retVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取目标主机的ip</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String getRemoteHost(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;0:0:0:0:0:0:0:1&quot;.equals(ip) ? &quot;127.0.0.1&quot; : ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java中的集合学习</title>
      <link href="/2017/08/31/java/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html"/>
      <content type="html"><![CDATA[<h3 id="java中的集合分为-value-、key-value-Collection、Map-两种"><a href="#java中的集合分为-value-、key-value-Collection、Map-两种" class="headerlink" title="java中的集合分为 value 、key-value(Collection、Map)两种"></a>java中的集合分为 value 、key-value(Collection、Map)两种</h3><h3 id="存储值又分为-List和Set"><a href="#存储值又分为-List和Set" class="headerlink" title="存储值又分为 List和Set"></a>存储值又分为 List和Set</h3><h4 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h4><ul><li>List是有序的,可以重复</li><li>Set是无序的，不可以重复的。根据equals和hashcode判断（一个对象要存储在Set中，必须重写equals和hashcode方法）。<a id="more"></a><h3 id="List常用的有ArrarList-与LinkedList-源码分析详见http-www-jianshu-com-p-0f3e65f68681"><a href="#List常用的有ArrarList-与LinkedList-源码分析详见http-www-jianshu-com-p-0f3e65f68681" class="headerlink" title="List常用的有ArrarList 与LinkedList(源码分析详见http://www.jianshu.com/p/0f3e65f68681)"></a>List常用的有ArrarList 与LinkedList(源码分析详见<a href="http://www.jianshu.com/p/0f3e65f68681" target="_blank" rel="noopener">http://www.jianshu.com/p/0f3e65f68681</a>)</h3><h4 id="ArrarList-与LinkedList的区别"><a href="#ArrarList-与LinkedList的区别" class="headerlink" title="ArrarList 与LinkedList的区别"></a>ArrarList 与LinkedList的区别</h4></li><li>ArrarList底层使用是数组，LinkedList使用的是链表</li></ul><ul><li>数组查询具有索引，查询特定元素比较快，而插入和删除比较慢（数组在内存中是一块连续的内存，如果插入或删除是需要移动内存）</li><li>链表不需要内存是连续的，在当前元素中存放下一个或上一个元素的地址，查询时需要从头部开始，一个一个的查找，所以查询效率低。插入时不需要移动内存只需要改变引用指向即可所以插入或删除的效率高。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayList与LinkedList 源码分析（基于JDK1.7）</title>
      <link href="/2017/08/29/java/ArrayList%E4%B8%8ELinkedList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8EJDK1-7%EF%BC%89.html"/>
      <content type="html"><![CDATA[<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List接口中的方法有很多，但最重要的无非是增删查改，我们从ArrayList与LinkedList的实现上来讨论他们的增删查改性能问题。先列出这几个重要的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    boolean add(E e); </span><br><span class="line">    void add(int index, E element);</span><br><span class="line">    E get(int index);</span><br><span class="line">    E set(int index, E element);</span><br><span class="line">    E remove(int index);</span><br><span class="line">    boolean remove(Object o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList的默认容量大小是 10 </p><p><img src="http://upload-images.jianshu.io/upload_images/3353177-31e9bddfa37838c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>构造函数<br>ArrayList底层使用的是动态数组，我们常用到的构造方法一般是如下两种:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Constructs an empty list with the specified initial capacity.</span><br><span class="line">    *</span><br><span class="line">    * @param  initialCapacity  the initial capacity of the list</span><br><span class="line">    * @throws IllegalArgumentException if the specified initial capacity</span><br><span class="line">    *         is negative</span><br><span class="line">    */</span><br><span class="line">   public ArrayList(int initialCapacity) &#123;</span><br><span class="line">       super();</span><br><span class="line">       if (initialCapacity &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       this.elementData = new Object[initialCapacity];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Constructs an empty list with an initial capacity of ten.</span><br><span class="line">    */</span><br><span class="line">   public ArrayList() &#123;</span><br><span class="line">       super();</span><br><span class="line">       this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，两者的区别在于初始化数组的长度，前者给定一个空数组，后者若initialCapacity大于0即给定一个initialCapacity大小的数组</p><h4 id="add一个元素"><a href="#add一个元素" class="headerlink" title="add一个元素"></a>add一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Appends the specified element to the end of this list.</span><br><span class="line">    *</span><br><span class="line">    * @param e element to be appended to this list</span><br><span class="line">    * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line">    */</span><br><span class="line">   public boolean add(E e) &#123;</span><br><span class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">       if (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">     modCount++;</span><br><span class="line"></span><br><span class="line">     // overflow-conscious code</span><br><span class="line">     if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">         grow(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>添加元素时会检测数组大小是否满足条件，不满足会去新建一个更大的数组，把原来数组中的元素都copy过来，可以看出，对于ArrayList的add操作来讲，是比较低效的(当需要扩容时)。<br>另外还有个public void add(int index, E element)方法，它在指定位置add元素时，需要把指定位置后面的所有元素都往后移动一个位置，所以也是比较低效的。</p><h4 id="get一个元素"><a href="#get一个元素" class="headerlink" title="get一个元素"></a>get一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        return elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private void rangeCheck(int index) &#123;</span><br><span class="line">        if (index &gt;= size)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，ArrayList的Get是非常高效的，只要index没有越界，直接从底层数组中返回即可，这也是ArrayList的优势所在。同理 ，ArrayList的Set也很高效，直接往数组中写即可。</p><h4 id="remove一个元素"><a href="#remove一个元素" class="headerlink" title="remove一个元素"></a>remove一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ArrayList在做删除操作时，因为需要把后面的所有元素整体前移来填空，所也也是非常耗资源的。<br>另外还有个public boolean remove(Object o)方法，这个是做一次遍历查询，然后删除。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>通过名字就可知道，LinkedList底层使用的是链表的形式去实现的，它的构造函数什么也没干:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="add一个元素-1"><a href="#add一个元素-1" class="headerlink" title="add一个元素"></a>add一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       linkLast(e);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * Links e as last element.</span><br><span class="line">    */</span><br><span class="line">   void linkLast(E e) &#123;</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">       last = newNode;</span><br><span class="line">       if (l == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           l.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>add一个元素就直接把这个元素放到链表的末端即可。但需要注意的是，相对于ArrayList的add方法，LinkedList的add方法并不见得高效，而且当数据量大后还远慢于ArrayList。<br>同时，LinkedList还是双向链表，所以内部同时保留了transient Node<e> last和transient Node<e> first;的引用。</e></e></p><h4 id="get一个元素-1"><a href="#get一个元素-1" class="headerlink" title="get一个元素"></a>get一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   public E get(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"> private void checkElementIndex(int index) &#123;</span><br><span class="line">        if (!isElementIndex(index))</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        // assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            for (int i = 0; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            return x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过查看index更靠近链表的哪一端，决定从哪一端去遍历。LinkedList在查找时需要遍历，所以相对于ArrayList的随机存取来说，会低效一些。</p><h4 id="remove一个元素-1"><a href="#remove一个元素-1" class="headerlink" title="remove一个元素"></a>remove一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        // assert x != null;</span><br><span class="line">        final E element = x.item;</span><br><span class="line">        final Node&lt;E&gt; next = x.next;</span><br><span class="line">        final Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        if (prev == null) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = null;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>ArrayList因为是基于动态数组去实现，在随机存取时，有着良好的性能。而增删时需要扩容，整块移动元素，所以相对较慢。但在数据量很大，顺序添加时是个例外，这种情况下它的性能优于LinkedList。</li><li>LinkedList因为是基于链表实现，随机增删较快，而存取时需要遍历查询，相对于ArrayList会更慢。<br>之后会比较下两种实现的迭代器性能。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;context:component-scan&gt; 配置 —— 分库遇到问题（1）</title>
      <link href="/2017/07/26/java/context-component-scan-%E9%85%8D%E7%BD%AE-%E2%80%94%E2%80%94-%E5%88%86%E5%BA%93%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%881%EF%BC%89.html"/>
      <content type="html"><![CDATA[<p>项目中 springMvc的部分配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:annotation /&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;xxx&quot;&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.RestController&quot; /&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></p><p>相信有些人看到我贴出来的配置就知道我要说明什么问题了，如果你还是没有头绪的话，可以看下我遇到的问题。<br><a id="more"></a><br>这个配置文件本来是想要扫描 xxx包下面的Controller和 RestControl注解，看起来并没有什么问题。我无意中一次测试发现某些service被初始化了两次！这跟spring中的单例模式是相悖的。并且一个service在spring根容器和springMvc容器分别初始化一次，导致在根容器初始化的Service里面的dubbo的 @Reference无法注入。<br>于是开始排查错误：除了dubbo:annotation是本人加的，其他的配置都是已经存在的。当时知道肯定是配置文件出了问题，但是不知道具体是哪里。问了公司的其他人员还是没有找到根本原因，经过反复排除并且在spring的官方文档发现了问题的根源。</p><h3 id="spring官方给的解释如下"><a href="#spring官方给的解释如下" class="headerlink" title="spring官方给的解释如下:"></a>spring官方给的解释如下:</h3><blockquote><p>The following example shows the configuration ignoring all @Repository annotations and using “stub” repositories instead.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;org.example&quot;,</span><br><span class="line">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span><br><span class="line">        excludeFilters = @Filter(Repository.class))</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>and the equivalent using XML<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;</span><br><span class="line">        &lt;context:include-filter type=&quot;regex&quot;</span><br><span class="line">                expression=&quot;.*Stub.*Repository&quot;/&gt;</span><br><span class="line">        &lt;context:exclude-filter type=&quot;annotation&quot;</span><br><span class="line">                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;</span><br><span class="line">    &lt;/context:component-scan&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>[Note]<br>You can also disable the default filters by setting useDefaultFilters=false on the annotation or providing use-default-filters=”false” as an attribute of the <component-scan> element. This will in effect disable automatic detection of classes annotated with @Component, @Repository, @Service, @Controller, or @Configuration.</component-scan></p><p>所以通过官方的描述可以看出原来是<component-scan>使用错误导致的。也就是说如果想让项目中的<a href="context:include-filter/" target="_blank" rel="noopener">context:include-filter/</a>生效就必须要加use-default-filters=”false” 否则 spring还是会扫描包下面的以下注解 @Component, @Repository, @Service, @Controller, or @Configuration.</component-scan></p>]]></content>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;dubbo:annotation &gt;配置 —— 分库遇到问题（2）</title>
      <link href="/2017/07/26/java/dubbo-annotation-%E9%85%8D%E7%BD%AE-%E2%80%94%E2%80%94-%E5%88%86%E5%BA%93%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%882%EF%BC%89.html"/>
      <content type="html"><![CDATA[<p>在上篇笔记《<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a> 配置 —— 分库遇到问题（1）》中解决了 spring中某些实例被初始化了两次的问题，<br>但是紧接着又来了另一个头疼的问题，dubbo的@Reference为null无法注入 ！<br>Controller层的注解正常！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:annotation /&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;xxx&quot; use-default-filters=&quot;false&quot;&gt;</span><br><span class="line">&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;</span><br><span class="line">&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.RestController&quot; /&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>我把这个问题提出来之后，大家都提出来，在dubbo的service或者spring还没有初始化完成之前就开始扫描 @Reference导致取到null值。但是怎么去找到问题的根源呢？<br>于是几个人在一块排查，刚开始是修改spring的配置文件。把有关扫描的配置重新检查了一下，并没有发现问题。网上查关于dubbo初始化的资料，依然没有发现解决问题的方法！<br>查询无果后，开始往源码上面去研究。<br>我始终在想，之前dubbo使用没有问题的，就在我昨天加了use-default-filters=”false”才出现的这个问题，所以我围绕着 context:component-scan + dubbo:annotation寻找答案，其中一条结果是指向 Dubbo的官方文档。如下：</p><blockquote><p>服务提供方注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line">@Service(version=&quot;1.0.0&quot;)</span><br><span class="line">public class FooServiceImpl implements FooService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>服务提供方配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 公共信息，也可以用dubbo.properties配置 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;annotation-provider&quot; /&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;127.0.0.1:4548&quot; /&gt;</span><br><span class="line">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span><br><span class="line">&lt;dubbo:annotation package=&quot;com.foo.bar.service&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>服务消费方注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class BarAction &#123;</span><br><span class="line">    @Reference(version=&quot;1.0.0&quot;)</span><br><span class="line">    private FooService fooService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务消费方配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 公共信息，也可以用dubbo.properties配置 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;annotation-consumer&quot; /&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;127.0.0.1:4548&quot; /&gt;</span><br><span class="line">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span><br><span class="line">&lt;dubbo:annotation package=&quot;com.foo.bar.action&quot; /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="也可以使用：-等价于前面的：-lt-dubbo-annotation-package-”com-foo-bar-service”-gt"><a href="#也可以使用：-等价于前面的：-lt-dubbo-annotation-package-”com-foo-bar-service”-gt" class="headerlink" title="也可以使用：(等价于前面的：&lt;dubbo:annotation package=”com.foo.bar.service” /&gt;)"></a>也可以使用：(等价于前面的：&lt;dubbo:annotation package=”com.foo.bar.service” /&gt;)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:annotation /&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.foo.bar.service&quot;&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;com.alibaba.dubbo.config.annotation.Service&quot; /&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><p>从官方给的样例找到了问题产生的原因。dubbo:annotation不指定包名的话会在spring bean中查找对应实例的类配置了dubbo注解的。</p>]]></content>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo Filter 传递上下文环境信息</title>
      <link href="/2017/07/26/java/Dubbo-Filter-%E4%BC%A0%E9%80%92%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF.html"/>
      <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>一般dubbo的service层都是一些通用的，无状态的服务。但是在某些特殊的需求下，需要传递一些上下文环境,打个不恰当的比方，例如需要在每次调用dubbo的服务的时候，记录一下用户名或者需要知道sessionid等。<br><a id="more"></a></p><h3 id="解决办法1"><a href="#解决办法1" class="headerlink" title="解决办法1"></a>解决办法1</h3><p>如果是在项目设计的时候就意识到这一点的话，就好办，把所有的dubbo服务请求的参数都封装一个公共的父类，把一些上下文环境在放在父类的属性中。<br><img src="http://upload-images.jianshu.io/upload_images/3353177-4178b9514ef69d51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这样做的好处就是，dubbo接口的参数都统一的，在Dubbo中可以做一些统一的处理（例如把上下文环境取出来，放在ThreadLocal中）。</p><h4 id="解决办法2"><a href="#解决办法2" class="headerlink" title="解决办法2"></a>解决办法2</h4><p>但是并不是所有的项目一开始就有这个需求的，但是突然有一天他猝不及防的出现了（比如本人就接到要使用多数据，每次前端请求的时候根据参数选择使用的数据库），如果项目已经基本定型的情况下，再改造成上面的解决办法，改动量太大（不怕麻烦的也可以，但是本人就比较懒）。<br>其实Dubbo的文档中已经有这个解决办法，就是隐式传参，<br><a href="http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-%E9%9A%90%E5%BC%8F%E4%BC%A0%E5%8F%82" target="_blank" rel="noopener">http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-%E9%9A%90%E5%BC%8F%E4%BC%A0%E5%8F%82</a><br>改造方案<br>代码如下</p><h4 id="DubboConsumer"><a href="#DubboConsumer" class="headerlink" title="DubboConsumer:"></a>DubboConsumer:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Activate(group = Constants.CONSUMER)</span><br><span class="line">public class DubboConsumerContextFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; attachments = new HashMap&lt;&gt;();</span><br><span class="line">        attachments.put(xxx, xxx);</span><br><span class="line">        attachments.put(xxx, xxx);</span><br><span class="line">        //设置需要的内容</span><br><span class="line">        RpcContext.getContext().setAttachments(attachments);</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DubboProvider："><a href="#DubboProvider：" class="headerlink" title="DubboProvider："></a>DubboProvider：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Activate(group = Constants.PROVIDER)</span><br><span class="line">public class DubboProviderContextFilter implements Filter &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        logger.info(&quot;DbProviderContextFilter attachments=&#123;&#125;&quot;, RpcContext.getContext().getAttachments());</span><br><span class="line"></span><br><span class="line">        String datasource = RpcContext.getContext().getAttachment(DbContextHolder.DATASOURCE_KEY);</span><br><span class="line">        String schema = RpcContext.getContext().getAttachment(DbContextHolder.SCHEMA_KEY);</span><br><span class="line">        if (StringUtils.isNotEmpty(datasource)) &#123;</span><br><span class="line">            DbContextHolder.setDatasource(datasource);</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isNotEmpty(schema)) &#123;</span><br><span class="line">            DbContextHolder.setSchema(schema);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在resources中创建文件<br>META-INF/dubbo/com.alibaba.dubbo.rpc.Filter</p><p>注意是 META-INF文件下的dubbo文件夹下的”com.alibaba.dubbo.rpc.Filter”文件<br><img src="http://upload-images.jianshu.io/upload_images/3353177-01d142b5d2ef144f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>并在里面加入,也就是第一步中创建的类的路径<br>dubboContextFilter=com.xxx.DubboContextFilter<br>第三步：在配置文件中加入<br>&lt;dubbo:provider filter=”dubboContextFilter” /&gt;</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h4><p>其实dubbo内置了一些filter，我们可以自定义自己的filter来完成一些和业务流程无关的逻辑，例如可以写IP白名单等等</p>]]></content>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java异常小结</title>
      <link href="/2017/07/20/java/Java%E5%BC%82%E5%B8%B8%E5%B0%8F%E7%BB%93.html"/>
      <content type="html"><![CDATA[<p>题目：请聊一下，你对java异常的理解？区分一下运行时异常和一般异常有何异同？你在平时工作中遇到的异常类有哪些，详细说明一下这些异常是怎么产生的？</p><h3 id="1-Java异常的理解？"><a href="#1-Java异常的理解？" class="headerlink" title="1 Java异常的理解？"></a>1 Java异常的理解？</h3><p>异常主要处理编译期不能捕获的错误。出现问题时能继续顺利执行下去，而不导致程序终止。确保程序的健壮性。</p><p>处理过程：产生异常状态时，如果当前的context不具备处理当前异常的能力，将在heap上new出来一个异常对象，停止当前的执行路线，把产生的异常对象抛给更高层的context。<br><a id="more"></a><br>Throwable：异常类；Error ：系统异常；不能恢复；Exception ：普通异常；可恢复。</p><p>利用try／catch／finally来处理异常。</p><p>在你会到了上面的东西，有的面试官会问你什么时候用到finally呢？你应该这样回答，某些事物（除内存外）在异常处理完后需要恢复到原始状态，如：开启的文件，网络连接等。</p><h3 id="2-运行时异常和一般异常有何异同？"><a href="#2-运行时异常和一般异常有何异同？" class="headerlink" title="2 运行时异常和一般异常有何异同？"></a>2 运行时异常和一般异常有何异同？</h3><p>异常分为runtime exception和checked exception。</p><p>checked exception：java编译器强制要求catch此类异常，如io异常、sql异常。</p><p>runtime exception：不需要强制性处理，一旦出现异常，交由虚拟机接管。</p><h3 id="3-遇到的异常类有哪些-产生的原因？"><a href="#3-遇到的异常类有哪些-产生的原因？" class="headerlink" title="3 遇到的异常类有哪些?产生的原因？"></a>3 遇到的异常类有哪些?产生的原因？</h3><p>NullPointerException：空指针。</p><p>ArrayIndexOutOfBoundsException：数组越界。</p><p>IllegalArgumentException：参数非法。</p><p>BufferOverflowException：缓存溢出。</p><p>ClassNotFoundException：在编译时无法找到指定的类。</p><p>ClassCastException：类型强转。</p><p>ExceptionInInitializerError：静态初始值或静态变量初始值期间发生异常。</p><p>UnsatisfiedLinkError：JNI加载dll或者so文件时未找到。</p><p>NoClassDefFoundError：在编译时能找到合适的类，而在运行时不能找到合适的类。</p><p>上面说了这么多常见的异常类，下面咱们详细的聊一下OutOfMemoryError（内存溢出）这个异常。</p><h4 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a>产生的原因：</h4><ul><li><p>内存中加载的数据量过于庞大，如一次从数据库取出过多数据。</p></li><li><p>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。</p></li><li><p>代码中存在死循环或循环产生过多重复的对象实体。</p></li><li><p>使用的第三方软件中的BUG。</p></li><li><p>启动参数内存值设定的过小。</p></li></ul><h3 id="重点排查以下几点："><a href="#重点排查以下几点：" class="headerlink" title="重点排查以下几点："></a>重点排查以下几点：</h3><ul><li><p>1 检查代码中是否有死循环或递归调用。</p></li><li><p>2 检查是否有大循环重复产生新对象实体。</p></li><li><p>3 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p></li><li><p>4 检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</p></li><li><p>5 检查对大文件的读取是否采用类nio的方式。</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> exception </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot配置文件放在jar外部</title>
      <link href="/2017/06/28/java/Spring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8jar%E5%A4%96%E9%83%A8.html"/>
      <content type="html"><![CDATA[<p>Spring Boot程序默认从application.properties或者application.yaml读取配置，如何将配置信息外置，方便配置呢？<br>查询官网，可以得到下面的几种方案:</p><h3 id="1-通过命令行指定"><a href="#1-通过命令行指定" class="headerlink" title="1. 通过命令行指定"></a>1. 通过命令行指定</h3><p>SpringApplication会默认将命令行选项参数转换为配置信息<br>例如，启动时命令参数指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar demo.jar --server.port = 9011</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="2-外置配置文件"><a href="#2-外置配置文件" class="headerlink" title="2.外置配置文件"></a>2.外置配置文件</h3><p>Spring程序会按优先级从下面这些路径来加载application.properties配置文件<br>当前目录下的/config目录<br>当前目录<br>classpath里的/config目录<br>classpath 跟目录<br>因此，要外置配置文件就很简单了，在jar所在目录新建config文件夹，然后放入配置文件，或者直接放在配置文件在jar目录.</p><h3 id="3-自定义配置文件"><a href="#3-自定义配置文件" class="headerlink" title="3.自定义配置文件"></a>3.自定义配置文件</h3><p>如果你不想使用application.properties作为配置文件，怎么办？完全没问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar demo.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Dspring.config.location=D:\config\config.properties demo.jar</span><br></pre></td></tr></table></figure></p><p>当然，还能在代码里指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@PropertySource(value=&#123;&quot;file:config.properties&quot;&#125;)</span><br><span class="line">public class SpringbootrestdemoApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootrestdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 图片加水印（图片或者文本）</title>
      <link href="/2017/05/11/java/java-%E5%9B%BE%E7%89%87%E5%8A%A0%E6%B0%B4%E5%8D%B0%EF%BC%88%E5%9B%BE%E7%89%87%E6%88%96%E8%80%85%E6%96%87%E6%9C%AC%EF%BC%89.html"/>
      <content type="html"><![CDATA[<p>对于上传的图片，有时候我们需要加上水印来标识图片的来源，以下java代码用来处理图片加文字和图片水印<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.font.FontRenderContext;</span><br><span class="line"><span class="keyword">import</span> java.awt.geom.Rectangle2D;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jasonLu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/5/11 12:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:图片添加水印 水印适用于 图片或文字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterMaskImgUtils</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加图片水印</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetImg 目标图片路径，如：C://myPictrue//1.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waterImg 水印图片路径，如：C://myPictrue//logo.png</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 水印图片距离目标图片左侧的偏移量，如果x&lt;0, 则在正中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 水印图片距离目标图片上侧的偏移量，如果y&lt;0, 则在正中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alpha 透明度(0.0 -- 1.0, 0.0为完全透明，1.0为完全不透明)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> degree 水印图片旋转角度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pressImage</span><span class="params">(String targetImg, String waterImg,  <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">float</span> alpha, Integer degree,String suffix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         pressImage(targetImg,waterImg,<span class="keyword">null</span>,x,y,alpha,<span class="keyword">null</span>,suffix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加图片水印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetImg 目标图片路径，如：C://myPictrue//1.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waterImg 水印图片路径，如：C://myPictrue//logo.png</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outImg 图片输出位置，如果为空，则覆盖原文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 水印图片距离目标图片左侧的偏移量，如果x&lt;0, 则在正中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 水印图片距离目标图片上侧的偏移量，如果y&lt;0, 则在正中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alpha 透明度(0.0 -- 1.0, 0.0为完全透明，1.0为完全不透明)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> degree 水印图片旋转角度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pressImage</span><span class="params">(String targetImg, String waterImg, String outImg, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">float</span> alpha, Integer degree,String suffix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(targetImg);</span><br><span class="line">            <span class="comment">//如果没有指定文件存放地址，则默认替换掉原图片</span></span><br><span class="line">            File outFile;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(outImg))</span><br><span class="line">            &#123;</span><br><span class="line">                outFile = file;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                outFile = <span class="keyword">new</span> File(outImg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Image image = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                image = ImageIO.read(file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> width = image.getWidth(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> height = image.getHeight(<span class="keyword">null</span>);</span><br><span class="line">            BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">            Graphics2D g = bufferedImage.createGraphics();</span><br><span class="line">            g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degree)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置水印旋转</span></span><br><span class="line">                g.rotate(Math.toRadians(degree), (<span class="keyword">double</span>) bufferedImage.getWidth() / <span class="number">2</span>, (<span class="keyword">double</span>) bufferedImage.getHeight() / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Image waterImage = ImageIO.read(<span class="keyword">new</span> File(waterImg));    <span class="comment">// 水印文件</span></span><br><span class="line">            <span class="keyword">int</span> width_1 = waterImage.getWidth(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> height_1 = waterImage.getHeight(<span class="keyword">null</span>);</span><br><span class="line">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, alpha));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> widthDiff = width - width_1;</span><br><span class="line">            <span class="keyword">int</span> heightDiff = height - height_1;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = widthDiff / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; widthDiff)</span><br><span class="line">            &#123;</span><br><span class="line">                x = widthDiff;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                y = heightDiff / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; heightDiff)</span><br><span class="line">            &#123;</span><br><span class="line">                y = heightDiff;</span><br><span class="line">            &#125;</span><br><span class="line">            g.drawImage(waterImage, x, y, width_1, height_1, <span class="keyword">null</span>); <span class="comment">// 水印文件结束</span></span><br><span class="line">            g.dispose();</span><br><span class="line">            <span class="comment">//注意这里的后缀不能带 .</span></span><br><span class="line">            ImageIO.write(bufferedImage, suffix.substring(<span class="number">1</span>), outFile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加文字水印</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetImg 目标图片路径，如：C://myPictrue//1.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressText 水印文字， 如：云账房</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontName 字体名称，    如：宋体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontStyle 字体样式，如：粗体和斜体(Font.BOLD|Font.ITALIC)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontSize 字体大小，单位为像素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color 字体颜色</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 水印文字距离目标图片左侧的偏移量，如果x&lt;0, 则在正中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 水印文字距离目标图片上侧的偏移量，如果y&lt;0, 则在正中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alpha 透明度(0.0 -- 1.0, 0.0为完全透明，1.0为完全不透明)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pressText</span><span class="params">(String targetImg, String pressText, String fontName, <span class="keyword">int</span> fontStyle, <span class="keyword">int</span> fontSize, Color color, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">float</span> alpha,String suffix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pressText(targetImg,pressText,<span class="keyword">null</span>,fontName,fontStyle,fontSize,color,x,y,alpha,<span class="keyword">null</span>,suffix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加文字水印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 坐标(0,0)在图片的左上角，(负数，负数)在中心位置，(0,xxx)在左边，(x,0)在最上边，其他位置根据图片来确定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetImg 目标图片路径，如：C://myPictrue//1.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressText 水印文字， 如：云账房</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outImg 图片输出位置，如果为空，则覆盖原文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontName 字体名称，    如：宋体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontStyle 字体样式，如：粗体和斜体(Font.BOLD|Font.ITALIC)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontSize 字体大小，单位为像素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color 字体颜色</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> positionX 水印文字距离目标图片左侧的偏移量，如果x&lt;0, 则在正中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> positionY 水印文字距离目标图片上侧的偏移量，如果y&lt;0, 则在正中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alpha 透明度(0.0 -- 1.0, 0.0为完全透明，1.0为完全不透明)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> degree 水印图片旋转角度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pressText</span><span class="params">(String targetImg, String pressText, String outImg, String fontName, <span class="keyword">int</span> fontStyle, <span class="keyword">int</span> fontSize, Color color, <span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY, <span class="keyword">float</span> alpha, Integer degree,String suffix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(targetImg);</span><br><span class="line">            <span class="comment">// 如果没有指定文件存放地址，则默认替换掉原图片</span></span><br><span class="line">            File outFile;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(outImg))</span><br><span class="line">            &#123;</span><br><span class="line">                outFile = file;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                outFile = <span class="keyword">new</span> File(outImg);</span><br><span class="line">            &#125;</span><br><span class="line">            Image image = ImageIO.read(file);</span><br><span class="line">            <span class="keyword">int</span> width = image.getWidth(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> height = image.getHeight(<span class="keyword">null</span>);</span><br><span class="line">            BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">            Font font = <span class="keyword">new</span> Font(fontName, fontStyle, fontSize);</span><br><span class="line">            Graphics2D g = bufferedImage.createGraphics();</span><br><span class="line">            g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line">            g.setFont(font);</span><br><span class="line">            g.setColor(color);</span><br><span class="line">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, alpha));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degree)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置水印旋转</span></span><br><span class="line">                g.rotate(Math.toRadians(degree), (<span class="keyword">double</span>) bufferedImage.getWidth() / <span class="number">2</span>, (<span class="keyword">double</span>) bufferedImage.getHeight() / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取文字所占的像素</span></span><br><span class="line">            FontRenderContext context = g.getFontRenderContext();</span><br><span class="line">            Rectangle2D stringBounds = font.getStringBounds(pressText,context);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> textWidth = (<span class="keyword">int</span>) stringBounds.getWidth() ;</span><br><span class="line">            <span class="keyword">int</span> textHeight = (<span class="keyword">int</span>) stringBounds.getHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> widthDiff = width - textWidth;</span><br><span class="line">            <span class="keyword">int</span> heightDiff = height - textHeight;</span><br><span class="line">            <span class="keyword">if</span> (positionX &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                positionX = widthDiff / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (positionX &gt; widthDiff)</span><br><span class="line">            &#123;</span><br><span class="line">                positionX = widthDiff;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (positionY &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                positionY = heightDiff / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (positionY &gt; heightDiff)</span><br><span class="line">            &#123;</span><br><span class="line">                positionY = heightDiff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            g.drawString(pressText, positionX, positionY + textHeight);</span><br><span class="line">            g.dispose();</span><br><span class="line">            ImageIO.write(bufferedImage, suffix, outFile);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加文字水印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetImg 目标图片路径，如：C://myPictrue//1.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressText 水印文字， 如：云账房</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontName 字体名称，    如：宋体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontStyle 字体样式，如：粗体和斜体(Font.BOLD|Font.ITALIC)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontSize 字体大小，单位为像素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alpha 透明度(0.0 -- 1.0, 0.0为完全透明，1.0为完全不透明)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pressTextToRightBottom</span><span class="params">(String targetImg, String pressText, String fontName, <span class="keyword">int</span> fontStyle, <span class="keyword">int</span> fontSize, Color color, <span class="keyword">float</span> alpha,String suffix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        pressTextToRightBottom(targetImg,pressText,<span class="keyword">null</span>,fontName,fontStyle,fontSize,color,alpha,<span class="keyword">null</span>,suffix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在图片的右下角添加水印</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetImg 目标图片路径，如：C://myPictrue//1.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressText 水印文字， 如：云账房</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outImg 图片输出位置，如果为空，则覆盖原文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontName 体名称， 如：宋体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontStyle 字体样式，如：粗体和斜体(Font.BOLD|Font.ITALIC)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fontSize 字体大小，单位为像素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alpha 透明度(0.0 -- 1.0, 0.0为完全透明，1.0为完全不透明)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> degree 水印图片旋转角度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pressTextToRightBottom</span><span class="params">(String targetImg, String pressText, String outImg, String fontName, <span class="keyword">int</span> fontStyle, <span class="keyword">int</span> fontSize, Color color, <span class="keyword">float</span> alpha, Integer degree,String suffix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(targetImg);</span><br><span class="line">            File outFile;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(outImg))</span><br><span class="line">            &#123;</span><br><span class="line">                outFile = file;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                outFile = <span class="keyword">new</span> File(outImg);</span><br><span class="line">            &#125;</span><br><span class="line">            Image image = ImageIO.read(file);</span><br><span class="line">            <span class="keyword">int</span> width = image.getWidth(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> height = image.getHeight(<span class="keyword">null</span>);</span><br><span class="line">            BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">            Font font = <span class="keyword">new</span> Font(fontName, fontStyle, fontSize);</span><br><span class="line">            Graphics2D g = bufferedImage.createGraphics();</span><br><span class="line">            g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line">            g.setFont(font);</span><br><span class="line">            g.setColor(color);</span><br><span class="line">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, alpha));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degree)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置水印旋转</span></span><br><span class="line">                g.rotate(Math.toRadians(degree), (<span class="keyword">double</span>) bufferedImage.getWidth() / <span class="number">2</span>, (<span class="keyword">double</span>) bufferedImage.getHeight() / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取文字所占的像素</span></span><br><span class="line">            FontRenderContext context = g.getFontRenderContext();</span><br><span class="line">            Rectangle2D stringBounds = font.getStringBounds(pressText,context);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> textWidth = (<span class="keyword">int</span>) stringBounds.getWidth() ;</span><br><span class="line">            <span class="keyword">int</span> textHight = (<span class="keyword">int</span>) stringBounds.getHeight();</span><br><span class="line"></span><br><span class="line">            g.drawString(pressText, width - textWidth, height - textHight);</span><br><span class="line">            g.dispose();</span><br><span class="line">            ImageIO.write(bufferedImage, suffix.substring(<span class="number">1</span>), outFile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 图片加水印 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle恢复到某一个时间点</title>
      <link href="/2017/03/24/DB/Oracle%E6%81%A2%E5%A4%8D%E5%88%B0%E6%9F%90%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E7%82%B9.html"/>
      <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flashback table tb_goods_sku to timestamp to_timestamp('2016-04-29 12:12:12','yyyy-mm-dd hh24:mi:ss');</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_goods_sku <span class="keyword">enable</span> <span class="keyword">row</span> <span class="keyword">movement</span>;</span><br></pre></td></tr></table></figure><p>操作数据库一不小心将很重要的数据删除了，找备份也没有，幸好Oracle有闪回的功能。<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flashback table pb_acc_user  to timestamp to_timestamp</span><br><span class="line">('2014-0315 09:30:00','yyyy-mm-dd hh24:mi:ss');</span><br></pre></td></tr></table></figure></p><p>提示ORA-08189: 因为未启用行移动功能, 不能闪回表 。一般来说出现这种错误，就是数据库表不支持闪回功能，修复很简单，开启即可。<br>所以执行以下语句 再执行闪回.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> pb_acc_user <span class="keyword">enable</span> <span class="keyword">row</span> <span class="keyword">movement</span>;</span><br></pre></td></tr></table></figure></p><p>成功闪回修改.</p>]]></content>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mybatis传 ARRAY给Oracle存储过程</title>
      <link href="/2017/03/10/java/Mybatis%E4%BC%A0-ARRAY%E7%BB%99Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html"/>
      <content type="html"><![CDATA[<h3 id="1-首先建立相关的存储过程，如图："><a href="#1-首先建立相关的存储过程，如图：" class="headerlink" title="1. 首先建立相关的存储过程，如图："></a>1. 首先建立相关的存储过程，如图：</h3><p><img src="http://upload-images.jianshu.io/upload_images/3353177-084719ab0ad30505.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"><br><a id="more"></a></p><h3 id="2-在service实现层填充参数-例如："><a href="#2-在service实现层填充参数-例如：" class="headerlink" title="2.在service实现层填充参数 例如："></a>2.在service实现层填充参数 例如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dto <span class="title">addFloorList</span><span class="params">(BannerRequest req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dto dto = <span class="keyword">new</span> Dto();</span><br><span class="line">List&lt;IndexFloor&gt; list = <span class="keyword">new</span> ArrayList&lt;IndexFloor&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">IndexFloor flr = <span class="keyword">new</span> IndexFloor();</span><br><span class="line">flr.setFloorId(i + <span class="number">3</span>);</span><br><span class="line">flr.setFloorTitle(<span class="string">"测试数据 "</span> + i + <span class="number">1</span>);</span><br><span class="line">flr.setFlrSort(i + <span class="number">1</span>);</span><br><span class="line">flr.setFlrCat(<span class="number">2</span>);</span><br><span class="line">list.add(flr);</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Object&gt; param = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">param.put(<span class="string">"id"</span>, <span class="number">2</span>);</span><br><span class="line">param.put(<span class="string">"floor_list"</span>, list);</span><br><span class="line"><span class="comment">//调用存储过程</span></span><br><span class="line">webMapper.spInsertInfo(param);</span><br><span class="line"><span class="keyword">int</span> rtnCode = (Integer) param.get(<span class="string">"rtnCode"</span>);</span><br><span class="line">String rtnMsg = String.valueOf(param.get(<span class="string">"rtnMsg"</span>));</span><br><span class="line">System.out.print(rtnCode + <span class="string">"------"</span> + rtnMsg);</span><br></pre></td></tr></table></figure><h3 id="3-编写工具类，用来处理Array参数："><a href="#3-编写工具类，用来处理Array参数：" class="headerlink" title="3.编写工具类，用来处理Array参数："></a>3.编写工具类，用来处理Array参数：</h3><p>  核心代码如下（详见附件中的 handler/ArrayHandler.java）:</p><p><img src="http://upload-images.jianshu.io/upload_images/3353177-0c0e8e0d9bfd65bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"></p><p>（注意：上图中的IndexFloor为测试bean。具体bean对象，根据需要编写）</p><h3 id="4-在MyBatis配置文件中，配置，handler为我们写好的工具类："><a href="#4-在MyBatis配置文件中，配置，handler为我们写好的工具类：" class="headerlink" title="4.在MyBatis配置文件中，配置，handler为我们写好的工具类："></a>4.在MyBatis配置文件中，配置<typehandlers>，handler为我们写好的工具类：</typehandlers></h3><p>配置代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 自定义传入参数类型(TypeHandler) --&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 如果没有在Handler中加注解，用第一个 --&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--&lt;typeHandler javaType="list" jdbcType="ARRAY" handler="cn.hao24.api.handler.ArrayHandler"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">javaType</span>=<span class="string">"list"</span> <span class="attr">handler</span>=<span class="string">"cn.hao24.api.handler.ArrayHandler"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="5-在Mapper-xml文件中调用存储过程并传参数："><a href="#5-在Mapper-xml文件中调用存储过程并传参数：" class="headerlink" title="5.在Mapper.xml文件中调用存储过程并传参数："></a>5.在Mapper.xml文件中调用存储过程并传参数：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"spInsertInfo"</span> <span class="attr">parameterType</span>=<span class="string">"Map"</span> <span class="attr">resultType</span>=<span class="string">"Map"</span> <span class="attr">statementType</span>=<span class="string">"CALLABLE"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> call TMP_LUJIE_TEST_ARRAY</span><br><span class="line"></span><br><span class="line"> (</span><br><span class="line"></span><br><span class="line"> #&#123;rtnCode,mode=OUT,jdbcType=INTEGER,javaType=Integer&#125;,</span><br><span class="line"></span><br><span class="line"> #&#123;rtnMsg,mode=OUT,jdbcType=VARCHAR,javaType=String&#125;,</span><br><span class="line"></span><br><span class="line"> #&#123;id,mode=IN,jdbcType=INTEGER,javaType=Integer&#125;,</span><br><span class="line"></span><br><span class="line"> **  #&#123;floor_list,jdbcType=ARRAY,javaType=list&#125;**</span><br><span class="line"></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6．调试代码。"><a href="#6．调试代码。" class="headerlink" title="6．调试代码。"></a>6．调试代码。</h3><p>参考资料：</p><p>1.how-to-pass-java-list-of-objects-to-oracle-stored-procedure-using-mybatis：</p><p><a href="http://stackoverflow.com/questions/12719689/how-to-pass-java-list-of-objects-to-oracle-stored-procedure-using-mybatis" target="_blank" rel="noopener">http://stackoverflow.com/questions/12719689/how-to-pass-java-list-of-objects-to-oracle-stored-procedure-using-mybatis</a></p><p>2. myBatis自定义传入参数类型(TypeHandler)</p><p><a href="http://jusesgod.iteye.com/blog/1740889" target="_blank" rel="noopener">http://jusesgod.iteye.com/blog/1740889</a></p>]]></content>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>oracle 用interval 求时间</title>
      <link href="/2016/10/19/DB/oracle-%E7%94%A8interval-%E6%B1%82%E6%97%B6%E9%97%B4.html"/>
      <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'20'</span> <span class="keyword">day</span> <span class="keyword">as</span> <span class="string">"20天前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'20'</span> <span class="keyword">hour</span> <span class="keyword">as</span> <span class="string">"20小时前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'20'</span> <span class="keyword">minute</span> <span class="keyword">as</span> <span class="string">"20分钟前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'20'</span> <span class="keyword">second</span> <span class="keyword">as</span> <span class="string">"20秒钟前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="number">20</span> <span class="keyword">as</span> <span class="string">"20天前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="number">20</span> / <span class="number">24</span> <span class="keyword">as</span> <span class="string">"20小时前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="number">20</span> / (<span class="number">24</span> * <span class="number">60</span>) <span class="keyword">as</span> <span class="string">"20分钟前"</span>,</span><br><span class="line"><span class="keyword">sysdate</span> - <span class="number">20</span> / (<span class="number">24</span> * <span class="number">3600</span>) <span class="keyword">as</span> <span class="string">"20秒钟前"</span></span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure><p>这里的 interval表示某段时间,格式是: interval ‘时间’ ;</p><p>例如 interval ‘20’ day 表示20天</p>]]></content>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cordova不能拨打电话号码的解决办法</title>
      <link href="/2015/08/02/js/cordova%E4%B8%8D%E8%83%BD%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html"/>
      <content type="html"><![CDATA[<p>在html里面直接使用不能拨打电话的解决方法如下：</p><ol><li>下载cordova的访问白名单插件 ：</li></ol><p>命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cordova plugins add cordova-plugin-whitelist</span><br><span class="line">``</span><br><span class="line">2. 在config.xml里面添加 如下配置：</span><br><span class="line">```xml</span><br><span class="line">&lt;content src = <span class="string">"index.html"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;plugin name = <span class="string">"cordova-plugin-whitelist"</span> version=<span class="string">"1"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;access orgin = <span class="string">"*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"http://*/*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"https://*/*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"tel:*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"sms:*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"mailto:*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"geo:*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;platform name = <span class="string">"android"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"market:*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/platform&gt;</span><br><span class="line"></span><br><span class="line">&lt;platform name = <span class="string">"ios"</span> &gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"itms:*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;allow-intent href = <span class="string">"itms-apps:*"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;platform&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
